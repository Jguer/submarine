/* bierdopje.c generated by valac 0.28.0, the Vala compiler
 * generated from bierdopje.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <libsoup/soup.h>
#include <stdio.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <float.h>
#include <math.h>


#define SUBMARINE_TYPE_SUBTITLE_SERVER (submarine_subtitle_server_get_type ())
#define SUBMARINE_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer))
#define SUBMARINE_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))
#define SUBMARINE_IS_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_IS_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_SUBTITLE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))

typedef struct _SubmarineSubtitleServer SubmarineSubtitleServer;
typedef struct _SubmarineSubtitleServerClass SubmarineSubtitleServerClass;
typedef struct _SubmarineSubtitleServerPrivate SubmarineSubtitleServerPrivate;

#define SUBMARINE_TYPE_SUBTITLE (submarine_subtitle_get_type ())
#define SUBMARINE_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitle))
#define SUBMARINE_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))
#define SUBMARINE_IS_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_IS_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_SUBTITLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))

typedef struct _SubmarineSubtitle SubmarineSubtitle;
typedef struct _SubmarineSubtitleClass SubmarineSubtitleClass;

#define SUBMARINE_TYPE_BIERDOPJE_SERVER (submarine_bierdopje_server_get_type ())
#define SUBMARINE_BIERDOPJE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_BIERDOPJE_SERVER, SubmarineBierdopjeServer))
#define SUBMARINE_BIERDOPJE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_BIERDOPJE_SERVER, SubmarineBierdopjeServerClass))
#define SUBMARINE_IS_BIERDOPJE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_BIERDOPJE_SERVER))
#define SUBMARINE_IS_BIERDOPJE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_BIERDOPJE_SERVER))
#define SUBMARINE_BIERDOPJE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_BIERDOPJE_SERVER, SubmarineBierdopjeServerClass))

typedef struct _SubmarineBierdopjeServer SubmarineBierdopjeServer;
typedef struct _SubmarineBierdopjeServerClass SubmarineBierdopjeServerClass;
typedef struct _SubmarineBierdopjeServerPrivate SubmarineBierdopjeServerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define SUBMARINE_TYPE_NAME_PARSER (submarine_name_parser_get_type ())
#define SUBMARINE_NAME_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParser))
#define SUBMARINE_NAME_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParserClass))
#define SUBMARINE_IS_NAME_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_NAME_PARSER))
#define SUBMARINE_IS_NAME_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_NAME_PARSER))
#define SUBMARINE_NAME_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParserClass))

typedef struct _SubmarineNameParser SubmarineNameParser;
typedef struct _SubmarineNameParserClass SubmarineNameParserClass;
typedef struct _SubmarineNameParserPrivate SubmarineNameParserPrivate;

#define SUBMARINE_TYPE_RESOLUTION (submarine_resolution_get_type ())

#define SUBMARINE_TYPE_CODEC (submarine_codec_get_type ())

#define SUBMARINE_TYPE_SOURCE (submarine_source_get_type ())
#define _submarine_name_parser_unref0(var) ((var == NULL) ? NULL : (var = (submarine_name_parser_unref (var), NULL)))

#define SUBMARINE_TYPE_CACHE_DATA (submarine_cache_data_get_type ())
#define SUBMARINE_CACHE_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_CACHE_DATA, SubmarineCacheData))
#define SUBMARINE_CACHE_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_CACHE_DATA, SubmarineCacheDataClass))
#define SUBMARINE_IS_CACHE_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_CACHE_DATA))
#define SUBMARINE_IS_CACHE_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_CACHE_DATA))
#define SUBMARINE_CACHE_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_CACHE_DATA, SubmarineCacheDataClass))

typedef struct _SubmarineCacheData SubmarineCacheData;
typedef struct _SubmarineCacheDataClass SubmarineCacheDataClass;
#define _submarine_cache_data_unref0(var) ((var == NULL) ? NULL : (var = (submarine_cache_data_unref (var), NULL)))

#define SUBMARINE_TYPE_SERVER_INFO (submarine_server_info_get_type ())
typedef struct _SubmarineServerInfo SubmarineServerInfo;
#define _submarine_subtitle_unref0(var) ((var == NULL) ? NULL : (var = (submarine_subtitle_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define __vala_SoupMessageHeaders_free0(var) ((var == NULL) ? NULL : (var = (_vala_SoupMessageHeaders_free (var), NULL)))

struct _SubmarineSubtitleServer {
	GObject parent_instance;
	SubmarineSubtitleServerPrivate * priv;
};

struct _SubmarineSubtitleServerClass {
	GObjectClass parent_class;
	gboolean (*connect) (SubmarineSubtitleServer* self);
	void (*disconnect) (SubmarineSubtitleServer* self);
	GeeSet* (*search) (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
	GeeMultiMap* (*search_multiple) (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
	SubmarineSubtitle* (*download) (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
	GeeSet* (*download_multiple) (SubmarineSubtitleServer* self, GeeCollection* subtitles);
};

struct _SubmarineBierdopjeServer {
	SubmarineSubtitleServer parent_instance;
	SubmarineBierdopjeServerPrivate * priv;
};

struct _SubmarineBierdopjeServerClass {
	SubmarineSubtitleServerClass parent_class;
};

struct _SubmarineBierdopjeServerPrivate {
	SoupSessionSync* session;
	gchar* filepath;
};

typedef enum  {
	SUBMARINE_RESOLUTION_PAL_NTSC,
	SUBMARINE_RESOLUTION_HDREADY,
	SUBMARINE_RESOLUTION_FULLHD,
	SUBMARINE_RESOLUTION_UNKNOWN
} SubmarineResolution;

typedef enum  {
	SUBMARINE_CODEC_X264,
	SUBMARINE_CODEC_DIVX,
	SUBMARINE_CODEC_XVID,
	SUBMARINE_CODEC_MPEG,
	SUBMARINE_CODEC_UNKNOWN
} SubmarineCodec;

typedef enum  {
	SUBMARINE_SOURCE_DVDRIP,
	SUBMARINE_SOURCE_BDRIP,
	SUBMARINE_SOURCE_HDTV,
	SUBMARINE_SOURCE_UNKNOWN
} SubmarineSource;

struct _SubmarineNameParser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SubmarineNameParserPrivate * priv;
	gchar* title;
	gint year;
	gint season;
	gint chapter;
	SubmarineResolution resolution;
	SubmarineCodec codec;
	SubmarineSource source;
};

struct _SubmarineNameParserClass {
	GTypeClass parent_class;
	void (*finalize) (SubmarineNameParser *self);
};

struct _SubmarineServerInfo {
	gchar* _name;
	gchar* _address;
	gchar* _code;
};


static gpointer submarine_bierdopje_server_parent_class = NULL;

GType submarine_subtitle_server_get_type (void) G_GNUC_CONST;
gpointer submarine_subtitle_ref (gpointer instance);
void submarine_subtitle_unref (gpointer instance);
GParamSpec* submarine_param_spec_subtitle (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_subtitle (GValue* value, gpointer v_object);
void submarine_value_take_subtitle (GValue* value, gpointer v_object);
gpointer submarine_value_get_subtitle (const GValue* value);
GType submarine_subtitle_get_type (void) G_GNUC_CONST;
GType submarine_bierdopje_server_get_type (void) G_GNUC_CONST;
#define SUBMARINE_BIERDOPJE_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_BIERDOPJE_SERVER, SubmarineBierdopjeServerPrivate))
enum  {
	SUBMARINE_BIERDOPJE_SERVER_DUMMY_PROPERTY
};
#define SUBMARINE_BIERDOPJE_SERVER_XMLRPC_URI "http://api.bierdopje.com/79FD9171317EC74E/"
#define SUBMARINE_BIERDOPJE_SERVER_USER_AGENT "submarine/0.1"
static gboolean submarine_bierdopje_server_real_connect (SubmarineSubtitleServer* base);
static void submarine_bierdopje_server_real_disconnect (SubmarineSubtitleServer* base);
static GeeSet* submarine_bierdopje_server_real_search (SubmarineSubtitleServer* base, GFile* file, GeeCollection* languages);
gpointer submarine_name_parser_ref (gpointer instance);
void submarine_name_parser_unref (gpointer instance);
GParamSpec* submarine_param_spec_name_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_name_parser (GValue* value, gpointer v_object);
void submarine_value_take_name_parser (GValue* value, gpointer v_object);
gpointer submarine_value_get_name_parser (const GValue* value);
GType submarine_name_parser_get_type (void) G_GNUC_CONST;
SubmarineNameParser* submarine_name_parser_new (GFile* file);
SubmarineNameParser* submarine_name_parser_construct (GType object_type, GFile* file);
GType submarine_resolution_get_type (void) G_GNUC_CONST;
GType submarine_codec_get_type (void) G_GNUC_CONST;
GType submarine_source_get_type (void) G_GNUC_CONST;
gpointer submarine_cache_data_ref (gpointer instance);
void submarine_cache_data_unref (gpointer instance);
GParamSpec* submarine_param_spec_cache_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_cache_data (GValue* value, gpointer v_object);
void submarine_value_take_cache_data (GValue* value, gpointer v_object);
gpointer submarine_value_get_cache_data (const GValue* value);
GType submarine_cache_data_get_type (void) G_GNUC_CONST;
SubmarineCacheData* submarine_cache_data_new (const gchar* filename, gint64 version);
SubmarineCacheData* submarine_cache_data_construct (GType object_type, const gchar* filename, gint64 version);
gchar* submarine_cache_data_get_key (SubmarineCacheData* self, const gchar* key);
static xmlNode* submarine_bierdopje_server_find_xml_content (SubmarineBierdopjeServer* self, const gchar* content, xmlNode* node);
void submarine_cache_data_set_key (SubmarineCacheData* self, const gchar* key, const gchar* val);
GType submarine_server_info_get_type (void) G_GNUC_CONST;
SubmarineServerInfo* submarine_server_info_dup (const SubmarineServerInfo* self);
void submarine_server_info_free (SubmarineServerInfo* self);
void submarine_server_info_copy (const SubmarineServerInfo* self, SubmarineServerInfo* dest);
void submarine_server_info_destroy (SubmarineServerInfo* self);
void submarine_subtitle_server_get_info (SubmarineSubtitleServer* self, SubmarineServerInfo* result);
SubmarineSubtitle* submarine_subtitle_new (SubmarineServerInfo* server_info, GValue* server_data);
SubmarineSubtitle* submarine_subtitle_construct (GType object_type, SubmarineServerInfo* server_info, GValue* server_data);
void submarine_subtitle_set_language (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_rating (SubmarineSubtitle* self, gdouble value);
static SubmarineSubtitle* submarine_bierdopje_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle);
void submarine_subtitle_get_server_data (SubmarineSubtitle* self, GValue* result);
static SoupMessageHeaders* _vala_SoupMessageHeaders_copy (SoupMessageHeaders* self);
void submarine_subtitle_set_format (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_data (SubmarineSubtitle* self, const gchar* value);
static void _vala_SoupMessageHeaders_free (SoupMessageHeaders* self);
SubmarineBierdopjeServer* submarine_bierdopje_server_new (void);
SubmarineBierdopjeServer* submarine_bierdopje_server_construct (GType object_type);
SubmarineSubtitleServer* submarine_subtitle_server_construct (GType object_type);
static GObject * submarine_bierdopje_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void submarine_server_info_init (SubmarineServerInfo *self, const gchar* name, const gchar* address, const gchar* code);
void submarine_subtitle_server_set_info (SubmarineSubtitleServer* self, SubmarineServerInfo* value);
static void submarine_bierdopje_server_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gboolean submarine_bierdopje_server_real_connect (SubmarineSubtitleServer* base) {
	SubmarineBierdopjeServer * self;
	gboolean result = FALSE;
	SoupSessionSync* _tmp0_ = NULL;
	self = (SubmarineBierdopjeServer*) base;
	_tmp0_ = (SoupSessionSync*) soup_session_sync_new ();
	_g_object_unref0 (self->priv->session);
	self->priv->session = _tmp0_;
	result = TRUE;
	return result;
}


static void submarine_bierdopje_server_real_disconnect (SubmarineSubtitleServer* base) {
	SubmarineBierdopjeServer * self;
	self = (SubmarineBierdopjeServer*) base;
}


static gint string_last_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


static GeeSet* submarine_bierdopje_server_real_search (SubmarineSubtitleServer* base, GFile* file, GeeCollection* languages) {
	SubmarineBierdopjeServer * self;
	GeeSet* result = NULL;
	gchar* showid = NULL;
	gchar* _tmp0_ = NULL;
	gchar* tvdbid = NULL;
	gchar* _tmp1_ = NULL;
	GeeHashSet* subtitles_downloaded = NULL;
	GeeHashSet* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* tmp = NULL;
	GFile* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gint pos = 0;
	const gchar* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gchar* main_filename = NULL;
	const gchar* _tmp9_ = NULL;
	gint _tmp10_ = 0;
	gchar* _tmp11_ = NULL;
	SubmarineNameParser* parser = NULL;
	GFile* _tmp12_ = NULL;
	SubmarineNameParser* _tmp13_ = NULL;
	SubmarineNameParser* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	SubmarineCacheData* cache = NULL;
	SubmarineCacheData* _tmp17_ = NULL;
	gchar* title = NULL;
	SubmarineNameParser* _tmp18_ = NULL;
	gint _tmp19_ = 0;
	FILE* _tmp28_ = NULL;
	const gchar* _tmp29_ = NULL;
	SubmarineNameParser* _tmp30_ = NULL;
	gint _tmp31_ = 0;
	SubmarineNameParser* _tmp32_ = NULL;
	gint _tmp33_ = 0;
	gchar* retval = NULL;
	SubmarineCacheData* _tmp34_ = NULL;
	const gchar* _tmp35_ = NULL;
	gchar* _tmp36_ = NULL;
	gboolean get_keys = FALSE;
	const gchar* _tmp37_ = NULL;
	gboolean _tmp48_ = FALSE;
	self = (SubmarineBierdopjeServer*) base;
	g_return_val_if_fail (file != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_tmp0_ = g_strdup ("X");
	showid = _tmp0_;
	_tmp1_ = g_strdup ("X");
	tvdbid = _tmp1_;
	_tmp2_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_downloaded = _tmp2_;
	_tmp3_ = file;
	_tmp4_ = g_file_get_path (_tmp3_);
	_g_free0 (self->priv->filepath);
	self->priv->filepath = _tmp4_;
	_tmp5_ = file;
	_tmp6_ = g_file_get_basename (_tmp5_);
	tmp = _tmp6_;
	_tmp7_ = tmp;
	_tmp8_ = string_last_index_of (_tmp7_, ".", 0);
	pos = _tmp8_;
	_tmp9_ = tmp;
	_tmp10_ = pos;
	_tmp11_ = string_substring (_tmp9_, (glong) 0, (glong) _tmp10_);
	main_filename = _tmp11_;
	_tmp12_ = file;
	_tmp13_ = submarine_name_parser_new (_tmp12_);
	parser = _tmp13_;
	_tmp14_ = parser;
	_tmp15_ = _tmp14_->title;
	if (_tmp15_ == NULL) {
		FILE* _tmp16_ = NULL;
		_tmp16_ = stdout;
		fprintf (_tmp16_, "Can't determine the serie/movie title\n");
		result = (GeeSet*) subtitles_downloaded;
		_submarine_name_parser_unref0 (parser);
		_g_free0 (main_filename);
		_g_free0 (tmp);
		_g_free0 (tvdbid);
		_g_free0 (showid);
		return result;
	}
	_tmp17_ = submarine_cache_data_new ("submarine_bierdopje", (gint64) 1);
	cache = _tmp17_;
	_tmp18_ = parser;
	_tmp19_ = _tmp18_->year;
	if (_tmp19_ != (-1)) {
		SubmarineNameParser* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		SubmarineNameParser* _tmp22_ = NULL;
		gint _tmp23_ = 0;
		gchar* _tmp24_ = NULL;
		_tmp20_ = parser;
		_tmp21_ = _tmp20_->title;
		_tmp22_ = parser;
		_tmp23_ = _tmp22_->year;
		_tmp24_ = g_strdup_printf ("%s (%d)", _tmp21_, _tmp23_);
		_g_free0 (title);
		title = _tmp24_;
	} else {
		SubmarineNameParser* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		gchar* _tmp27_ = NULL;
		_tmp25_ = parser;
		_tmp26_ = _tmp25_->title;
		_tmp27_ = g_strdup_printf ("%s", _tmp26_);
		_g_free0 (title);
		title = _tmp27_;
	}
	_tmp28_ = stdout;
	_tmp29_ = title;
	_tmp30_ = parser;
	_tmp31_ = _tmp30_->season;
	_tmp32_ = parser;
	_tmp33_ = _tmp32_->chapter;
	fprintf (_tmp28_, "BierDopje: asking for \"%s\", Season %d, Chapter %d\n", _tmp29_, _tmp31_, _tmp33_);
	_tmp34_ = cache;
	_tmp35_ = title;
	_tmp36_ = submarine_cache_data_get_key (_tmp34_, _tmp35_);
	retval = _tmp36_;
	get_keys = FALSE;
	_tmp37_ = retval;
	if (_tmp37_ == NULL) {
		get_keys = TRUE;
	} else {
		gchar** res = NULL;
		const gchar* _tmp38_ = NULL;
		gchar** _tmp39_ = NULL;
		gchar** _tmp40_ = NULL;
		gint res_length1 = 0;
		gint _res_size_ = 0;
		gchar** _tmp41_ = NULL;
		gint _tmp41__length1 = 0;
		const gchar* _tmp42_ = NULL;
		gchar* _tmp43_ = NULL;
		gchar** _tmp44_ = NULL;
		gint _tmp44__length1 = 0;
		const gchar* _tmp45_ = NULL;
		gchar* _tmp46_ = NULL;
		const gchar* _tmp47_ = NULL;
		_tmp38_ = retval;
		_tmp40_ = _tmp39_ = g_strsplit (_tmp38_, ",", 0);
		res = _tmp40_;
		res_length1 = _vala_array_length (_tmp39_);
		_res_size_ = res_length1;
		_tmp41_ = res;
		_tmp41__length1 = res_length1;
		_tmp42_ = _tmp41_[0];
		_tmp43_ = g_strdup (_tmp42_);
		_g_free0 (showid);
		showid = _tmp43_;
		_tmp44_ = res;
		_tmp44__length1 = res_length1;
		_tmp45_ = _tmp44_[1];
		_tmp46_ = g_strdup (_tmp45_);
		_g_free0 (tvdbid);
		tvdbid = _tmp46_;
		_tmp47_ = showid;
		if (g_strcmp0 (_tmp47_, "X") == 0) {
			get_keys = TRUE;
		}
		res = (_vala_array_free (res, res_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp48_ = get_keys;
	if (_tmp48_) {
		gchar* petition = NULL;
		const gchar* _tmp49_ = NULL;
		gchar* _tmp50_ = NULL;
		SoupMessage* message = NULL;
		const gchar* _tmp51_ = NULL;
		SoupMessage* _tmp52_ = NULL;
		SoupMessage* _tmp53_ = NULL;
		SoupMessageHeaders* _tmp54_ = NULL;
		guint status_code = 0U;
		SoupSessionSync* _tmp55_ = NULL;
		SoupMessage* _tmp56_ = NULL;
		guint _tmp57_ = 0U;
		guint _tmp58_ = 0U;
		_tmp49_ = title;
		_tmp50_ = g_strdup_printf ("%sGetShowByName/%s", SUBMARINE_BIERDOPJE_SERVER_XMLRPC_URI, _tmp49_);
		petition = _tmp50_;
		_tmp51_ = petition;
		_tmp52_ = soup_message_new ("GET", _tmp51_);
		message = _tmp52_;
		_tmp53_ = message;
		_tmp54_ = _tmp53_->request_headers;
		soup_message_headers_append (_tmp54_, "User-Agent", SUBMARINE_BIERDOPJE_SERVER_USER_AGENT);
		_tmp55_ = self->priv->session;
		_tmp56_ = message;
		_tmp57_ = soup_session_send_message ((SoupSession*) _tmp55_, _tmp56_);
		status_code = _tmp57_;
		_tmp58_ = status_code;
		if (_tmp58_ == ((guint) 200)) {
			gchar* rv = NULL;
			SoupMessage* _tmp59_ = NULL;
			SoupMessageBody* _tmp60_ = NULL;
			guint8* _tmp61_ = NULL;
			gint _tmp61__length1 = 0;
			gchar* _tmp62_ = NULL;
			xmlDoc* x = NULL;
			const gchar* _tmp63_ = NULL;
			const gchar* _tmp64_ = NULL;
			gint _tmp65_ = 0;
			gint _tmp66_ = 0;
			xmlDoc* _tmp67_ = NULL;
			xmlNode* node = NULL;
			xmlDoc* _tmp68_ = NULL;
			xmlNode* _tmp69_ = NULL;
			xmlNode* node2 = NULL;
			xmlNode* _tmp70_ = NULL;
			xmlNode* _tmp71_ = NULL;
			gboolean _tmp72_ = FALSE;
			gboolean _tmp73_ = FALSE;
			xmlNode* _tmp74_ = NULL;
			_tmp59_ = message;
			_tmp60_ = _tmp59_->response_body;
			_tmp61_ = _tmp60_->data;
			_tmp61__length1 = (gint) _tmp60_->length;
			_tmp62_ = g_strdup ((const gchar*) _tmp61_);
			rv = _tmp62_;
			_tmp63_ = rv;
			_tmp64_ = rv;
			_tmp65_ = strlen (_tmp64_);
			_tmp66_ = _tmp65_;
			_tmp67_ = xmlParseMemory (_tmp63_, _tmp66_);
			x = _tmp67_;
			_tmp68_ = x;
			_tmp69_ = xmlDocGetRootElement (_tmp68_);
			node = _tmp69_;
			_tmp70_ = node;
			_tmp71_ = submarine_bierdopje_server_find_xml_content (self, "status", _tmp70_);
			node2 = _tmp71_;
			_tmp74_ = node2;
			if (_tmp74_ != NULL) {
				xmlNode* _tmp75_ = NULL;
				xmlNode* _tmp76_ = NULL;
				_tmp75_ = node2;
				_tmp76_ = _tmp75_->children;
				_tmp73_ = _tmp76_ != NULL;
			} else {
				_tmp73_ = FALSE;
			}
			if (_tmp73_) {
				xmlNode* _tmp77_ = NULL;
				xmlNode* _tmp78_ = NULL;
				const gchar* _tmp79_ = NULL;
				_tmp77_ = node2;
				_tmp78_ = _tmp77_->children;
				_tmp79_ = _tmp78_->content;
				_tmp72_ = g_strcmp0 (_tmp79_, "true") == 0;
			} else {
				_tmp72_ = FALSE;
			}
			if (_tmp72_) {
				xmlNode* node3 = NULL;
				xmlNode* _tmp80_ = NULL;
				xmlNode* _tmp81_ = NULL;
				xmlNode* node4 = NULL;
				xmlNode* _tmp82_ = NULL;
				xmlNode* _tmp83_ = NULL;
				gboolean _tmp84_ = FALSE;
				xmlNode* _tmp85_ = NULL;
				gboolean _tmp92_ = FALSE;
				xmlNode* _tmp93_ = NULL;
				SubmarineCacheData* _tmp100_ = NULL;
				const gchar* _tmp101_ = NULL;
				const gchar* _tmp102_ = NULL;
				const gchar* _tmp103_ = NULL;
				gchar* _tmp104_ = NULL;
				gchar* _tmp105_ = NULL;
				_tmp80_ = node;
				_tmp81_ = submarine_bierdopje_server_find_xml_content (self, "showid", _tmp80_);
				node3 = _tmp81_;
				_tmp82_ = node;
				_tmp83_ = submarine_bierdopje_server_find_xml_content (self, "tvdbid", _tmp82_);
				node4 = _tmp83_;
				_tmp85_ = node3;
				if (_tmp85_ != NULL) {
					xmlNode* _tmp86_ = NULL;
					xmlNode* _tmp87_ = NULL;
					_tmp86_ = node3;
					_tmp87_ = _tmp86_->children;
					_tmp84_ = _tmp87_ != NULL;
				} else {
					_tmp84_ = FALSE;
				}
				if (_tmp84_) {
					xmlNode* _tmp88_ = NULL;
					xmlNode* _tmp89_ = NULL;
					const gchar* _tmp90_ = NULL;
					gchar* _tmp91_ = NULL;
					_tmp88_ = node3;
					_tmp89_ = _tmp88_->children;
					_tmp90_ = _tmp89_->content;
					_tmp91_ = g_strdup (_tmp90_);
					_g_free0 (showid);
					showid = _tmp91_;
				}
				_tmp93_ = node4;
				if (_tmp93_ != NULL) {
					xmlNode* _tmp94_ = NULL;
					xmlNode* _tmp95_ = NULL;
					_tmp94_ = node4;
					_tmp95_ = _tmp94_->children;
					_tmp92_ = _tmp95_ != NULL;
				} else {
					_tmp92_ = FALSE;
				}
				if (_tmp92_) {
					xmlNode* _tmp96_ = NULL;
					xmlNode* _tmp97_ = NULL;
					const gchar* _tmp98_ = NULL;
					gchar* _tmp99_ = NULL;
					_tmp96_ = node4;
					_tmp97_ = _tmp96_->children;
					_tmp98_ = _tmp97_->content;
					_tmp99_ = g_strdup (_tmp98_);
					_g_free0 (tvdbid);
					tvdbid = _tmp99_;
				}
				_tmp100_ = cache;
				_tmp101_ = title;
				_tmp102_ = showid;
				_tmp103_ = tvdbid;
				_tmp104_ = g_strdup_printf ("%s,%s", _tmp102_, _tmp103_);
				_tmp105_ = _tmp104_;
				submarine_cache_data_set_key (_tmp100_, _tmp101_, _tmp105_);
				_g_free0 (_tmp105_);
			} else {
				result = (GeeSet*) subtitles_downloaded;
				_g_free0 (rv);
				_g_object_unref0 (message);
				_g_free0 (petition);
				_g_free0 (retval);
				_g_free0 (title);
				_submarine_cache_data_unref0 (cache);
				_submarine_name_parser_unref0 (parser);
				_g_free0 (main_filename);
				_g_free0 (tmp);
				_g_free0 (tvdbid);
				_g_free0 (showid);
				return result;
			}
			_g_free0 (rv);
		} else {
			result = (GeeSet*) subtitles_downloaded;
			_g_object_unref0 (message);
			_g_free0 (petition);
			_g_free0 (retval);
			_g_free0 (title);
			_submarine_cache_data_unref0 (cache);
			_submarine_name_parser_unref0 (parser);
			_g_free0 (main_filename);
			_g_free0 (tmp);
			_g_free0 (tvdbid);
			_g_free0 (showid);
			return result;
		}
		_g_object_unref0 (message);
		_g_free0 (petition);
	}
	{
		GeeIterator* _l_it = NULL;
		GeeCollection* _tmp106_ = NULL;
		GeeIterator* _tmp107_ = NULL;
		_tmp106_ = languages;
		_tmp107_ = gee_iterable_iterator ((GeeIterable*) _tmp106_);
		_l_it = _tmp107_;
		while (TRUE) {
			GeeIterator* _tmp108_ = NULL;
			gboolean _tmp109_ = FALSE;
			gchar* l = NULL;
			GeeIterator* _tmp110_ = NULL;
			gpointer _tmp111_ = NULL;
			gchar* petition = NULL;
			const gchar* _tmp112_ = NULL;
			SubmarineNameParser* _tmp113_ = NULL;
			gint _tmp114_ = 0;
			SubmarineNameParser* _tmp115_ = NULL;
			gint _tmp116_ = 0;
			const gchar* _tmp117_ = NULL;
			gchar* _tmp118_ = NULL;
			SoupMessage* message = NULL;
			const gchar* _tmp119_ = NULL;
			SoupMessage* _tmp120_ = NULL;
			SoupMessage* _tmp121_ = NULL;
			SoupMessageHeaders* _tmp122_ = NULL;
			guint status_code = 0U;
			SoupSessionSync* _tmp123_ = NULL;
			SoupMessage* _tmp124_ = NULL;
			guint _tmp125_ = 0U;
			guint _tmp126_ = 0U;
			_tmp108_ = _l_it;
			_tmp109_ = gee_iterator_next (_tmp108_);
			if (!_tmp109_) {
				break;
			}
			_tmp110_ = _l_it;
			_tmp111_ = gee_iterator_get (_tmp110_);
			l = (gchar*) _tmp111_;
			_tmp112_ = showid;
			_tmp113_ = parser;
			_tmp114_ = _tmp113_->season;
			_tmp115_ = parser;
			_tmp116_ = _tmp115_->chapter;
			_tmp117_ = l;
			_tmp118_ = g_strdup_printf ("%sGetAllSubsFor/%s/%d/%d/%s", SUBMARINE_BIERDOPJE_SERVER_XMLRPC_URI, _tmp112_, _tmp114_, _tmp116_, _tmp117_);
			petition = _tmp118_;
			_tmp119_ = petition;
			_tmp120_ = soup_message_new ("GET", _tmp119_);
			message = _tmp120_;
			_tmp121_ = message;
			_tmp122_ = _tmp121_->request_headers;
			soup_message_headers_append (_tmp122_, "User-Agent", SUBMARINE_BIERDOPJE_SERVER_USER_AGENT);
			_tmp123_ = self->priv->session;
			_tmp124_ = message;
			_tmp125_ = soup_session_send_message ((SoupSession*) _tmp123_, _tmp124_);
			status_code = _tmp125_;
			_tmp126_ = status_code;
			if (_tmp126_ == ((guint) 200)) {
				gchar* rv = NULL;
				SoupMessage* _tmp127_ = NULL;
				SoupMessageBody* _tmp128_ = NULL;
				guint8* _tmp129_ = NULL;
				gint _tmp129__length1 = 0;
				gchar* _tmp130_ = NULL;
				xmlDoc* x = NULL;
				const gchar* _tmp131_ = NULL;
				const gchar* _tmp132_ = NULL;
				gint _tmp133_ = 0;
				gint _tmp134_ = 0;
				xmlDoc* _tmp135_ = NULL;
				xmlNode* node = NULL;
				xmlDoc* _tmp136_ = NULL;
				xmlNode* _tmp137_ = NULL;
				xmlNode* node2 = NULL;
				xmlNode* _tmp138_ = NULL;
				xmlNode* _tmp139_ = NULL;
				gboolean _tmp140_ = FALSE;
				gboolean _tmp141_ = FALSE;
				xmlNode* _tmp142_ = NULL;
				_tmp127_ = message;
				_tmp128_ = _tmp127_->response_body;
				_tmp129_ = _tmp128_->data;
				_tmp129__length1 = (gint) _tmp128_->length;
				_tmp130_ = g_strdup ((const gchar*) _tmp129_);
				rv = _tmp130_;
				_tmp131_ = rv;
				_tmp132_ = rv;
				_tmp133_ = strlen (_tmp132_);
				_tmp134_ = _tmp133_;
				_tmp135_ = xmlParseMemory (_tmp131_, _tmp134_);
				x = _tmp135_;
				_tmp136_ = x;
				_tmp137_ = xmlDocGetRootElement (_tmp136_);
				node = _tmp137_;
				_tmp138_ = node;
				_tmp139_ = submarine_bierdopje_server_find_xml_content (self, "status", _tmp138_);
				node2 = _tmp139_;
				_tmp142_ = node2;
				if (_tmp142_ != NULL) {
					xmlNode* _tmp143_ = NULL;
					xmlNode* _tmp144_ = NULL;
					_tmp143_ = node2;
					_tmp144_ = _tmp143_->children;
					_tmp141_ = _tmp144_ != NULL;
				} else {
					_tmp141_ = FALSE;
				}
				if (_tmp141_) {
					xmlNode* _tmp145_ = NULL;
					xmlNode* _tmp146_ = NULL;
					const gchar* _tmp147_ = NULL;
					_tmp145_ = node2;
					_tmp146_ = _tmp145_->children;
					_tmp147_ = _tmp146_->content;
					_tmp140_ = g_strcmp0 (_tmp147_, "true") == 0;
				} else {
					_tmp140_ = FALSE;
				}
				if (_tmp140_) {
					gboolean found_subs = FALSE;
					xmlNode* node3 = NULL;
					xmlNode* _tmp148_ = NULL;
					xmlNode* _tmp149_ = NULL;
					xmlNode* _tmp150_ = NULL;
					gboolean _tmp192_ = FALSE;
					found_subs = FALSE;
					_tmp148_ = node;
					_tmp149_ = submarine_bierdopje_server_find_xml_content (self, "results", _tmp148_);
					node3 = _tmp149_;
					_tmp150_ = node3;
					if (_tmp150_ != NULL) {
						xmlNode* node4 = NULL;
						xmlNode* _tmp151_ = NULL;
						xmlNode* _tmp152_ = NULL;
						_tmp151_ = node3;
						_tmp152_ = _tmp151_->children;
						node4 = _tmp152_;
						while (TRUE) {
							xmlNode* _tmp153_ = NULL;
							xmlNode* _tmp154_ = NULL;
							const gchar* _tmp155_ = NULL;
							xmlNode* _tmp190_ = NULL;
							xmlNode* _tmp191_ = NULL;
							_tmp153_ = node4;
							if (!(_tmp153_ != NULL)) {
								break;
							}
							_tmp154_ = node4;
							_tmp155_ = _tmp154_->name;
							if (g_strcmp0 (_tmp155_, "result") == 0) {
								xmlNode* node5 = NULL;
								xmlNode* _tmp156_ = NULL;
								xmlNode* _tmp157_ = NULL;
								gchar* c_filename = NULL;
								gchar* _tmp158_ = NULL;
								gchar* c_uri = NULL;
								gchar* _tmp159_ = NULL;
								gboolean _tmp175_ = FALSE;
								const gchar* _tmp176_ = NULL;
								const gchar* _tmp177_ = NULL;
								_tmp156_ = node4;
								_tmp157_ = _tmp156_->children;
								node5 = _tmp157_;
								_tmp158_ = g_strdup ("");
								c_filename = _tmp158_;
								_tmp159_ = g_strdup ("");
								c_uri = _tmp159_;
								while (TRUE) {
									xmlNode* _tmp160_ = NULL;
									xmlNode* _tmp161_ = NULL;
									const gchar* _tmp162_ = NULL;
									xmlNode* _tmp167_ = NULL;
									const gchar* _tmp168_ = NULL;
									xmlNode* _tmp173_ = NULL;
									xmlNode* _tmp174_ = NULL;
									_tmp160_ = node5;
									if (!(_tmp160_ != NULL)) {
										break;
									}
									_tmp161_ = node5;
									_tmp162_ = _tmp161_->name;
									if (g_strcmp0 (_tmp162_, "filename") == 0) {
										xmlNode* _tmp163_ = NULL;
										xmlNode* _tmp164_ = NULL;
										const gchar* _tmp165_ = NULL;
										gchar* _tmp166_ = NULL;
										_tmp163_ = node5;
										_tmp164_ = _tmp163_->children;
										_tmp165_ = _tmp164_->content;
										_tmp166_ = g_strdup (_tmp165_);
										_g_free0 (c_filename);
										c_filename = _tmp166_;
									}
									_tmp167_ = node5;
									_tmp168_ = _tmp167_->name;
									if (g_strcmp0 (_tmp168_, "downloadlink") == 0) {
										xmlNode* _tmp169_ = NULL;
										xmlNode* _tmp170_ = NULL;
										const gchar* _tmp171_ = NULL;
										gchar* _tmp172_ = NULL;
										_tmp169_ = node5;
										_tmp170_ = _tmp169_->children;
										_tmp171_ = _tmp170_->content;
										_tmp172_ = g_strdup (_tmp171_);
										_g_free0 (c_uri);
										c_uri = _tmp172_;
									}
									_tmp173_ = node5;
									_tmp174_ = _tmp173_->next;
									node5 = _tmp174_;
								}
								_tmp176_ = c_filename;
								_tmp177_ = main_filename;
								if (g_strcmp0 (_tmp176_, _tmp177_) == 0) {
									const gchar* _tmp178_ = NULL;
									_tmp178_ = c_uri;
									_tmp175_ = g_strcmp0 (_tmp178_, "") != 0;
								} else {
									_tmp175_ = FALSE;
								}
								if (_tmp175_) {
									GValue v = {0};
									const gchar* _tmp179_ = NULL;
									GValue _tmp180_ = {0};
									SubmarineSubtitle* subtitle = NULL;
									SubmarineServerInfo _tmp181_ = {0};
									SubmarineServerInfo _tmp182_ = {0};
									GValue _tmp183_ = {0};
									SubmarineSubtitle* _tmp184_ = NULL;
									SubmarineSubtitle* _tmp185_ = NULL;
									const gchar* _tmp186_ = NULL;
									SubmarineSubtitle* _tmp187_ = NULL;
									GeeHashSet* _tmp188_ = NULL;
									SubmarineSubtitle* _tmp189_ = NULL;
									found_subs = TRUE;
									_tmp179_ = c_uri;
									g_value_init (&_tmp180_, G_TYPE_STRING);
									g_value_set_string (&_tmp180_, _tmp179_);
									v = _tmp180_;
									submarine_subtitle_server_get_info ((SubmarineSubtitleServer*) self, &_tmp181_);
									_tmp182_ = _tmp181_;
									_tmp183_ = v;
									_tmp184_ = submarine_subtitle_new (&_tmp182_, &_tmp183_);
									subtitle = _tmp184_;
									_tmp185_ = subtitle;
									_tmp186_ = l;
									submarine_subtitle_set_language (_tmp185_, _tmp186_);
									_tmp187_ = subtitle;
									submarine_subtitle_set_rating (_tmp187_, 7.0);
									_tmp188_ = subtitles_downloaded;
									_tmp189_ = subtitle;
									gee_abstract_collection_add ((GeeAbstractCollection*) _tmp188_, _tmp189_);
									_submarine_subtitle_unref0 (subtitle);
									G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
								}
								_g_free0 (c_uri);
								_g_free0 (c_filename);
							}
							_tmp190_ = node4;
							_tmp191_ = _tmp190_->next;
							node4 = _tmp191_;
						}
					}
					_tmp192_ = found_subs;
					if (_tmp192_ == FALSE) {
						xmlNode* _tmp193_ = NULL;
						xmlNode* _tmp194_ = NULL;
						xmlNode* _tmp195_ = NULL;
						_tmp193_ = node;
						_tmp194_ = submarine_bierdopje_server_find_xml_content (self, "results", _tmp193_);
						node3 = _tmp194_;
						_tmp195_ = node3;
						if (_tmp195_ != NULL) {
							xmlNode* node4 = NULL;
							xmlNode* _tmp196_ = NULL;
							xmlNode* _tmp197_ = NULL;
							gint len2 = 0;
							const gchar* _tmp198_ = NULL;
							gint _tmp199_ = 0;
							gint _tmp200_ = 0;
							_tmp196_ = node3;
							_tmp197_ = _tmp196_->children;
							node4 = _tmp197_;
							_tmp198_ = main_filename;
							_tmp199_ = strlen (_tmp198_);
							_tmp200_ = _tmp199_;
							len2 = _tmp200_;
							while (TRUE) {
								xmlNode* _tmp201_ = NULL;
								xmlNode* _tmp202_ = NULL;
								const gchar* _tmp203_ = NULL;
								xmlNode* _tmp246_ = NULL;
								xmlNode* _tmp247_ = NULL;
								_tmp201_ = node4;
								if (!(_tmp201_ != NULL)) {
									break;
								}
								_tmp202_ = node4;
								_tmp203_ = _tmp202_->name;
								if (g_strcmp0 (_tmp203_, "result") == 0) {
									xmlNode* node5 = NULL;
									xmlNode* _tmp204_ = NULL;
									xmlNode* _tmp205_ = NULL;
									gchar* c_filename = NULL;
									gchar* _tmp206_ = NULL;
									gchar* c_uri = NULL;
									gchar* _tmp207_ = NULL;
									gint len = 0;
									const gchar* _tmp223_ = NULL;
									gint _tmp224_ = 0;
									gint _tmp225_ = 0;
									gint _tmp226_ = 0;
									gint _tmp227_ = 0;
									_tmp204_ = node4;
									_tmp205_ = _tmp204_->children;
									node5 = _tmp205_;
									_tmp206_ = g_strdup ("");
									c_filename = _tmp206_;
									_tmp207_ = g_strdup ("");
									c_uri = _tmp207_;
									while (TRUE) {
										xmlNode* _tmp208_ = NULL;
										xmlNode* _tmp209_ = NULL;
										const gchar* _tmp210_ = NULL;
										xmlNode* _tmp215_ = NULL;
										const gchar* _tmp216_ = NULL;
										xmlNode* _tmp221_ = NULL;
										xmlNode* _tmp222_ = NULL;
										_tmp208_ = node5;
										if (!(_tmp208_ != NULL)) {
											break;
										}
										_tmp209_ = node5;
										_tmp210_ = _tmp209_->name;
										if (g_strcmp0 (_tmp210_, "filename") == 0) {
											xmlNode* _tmp211_ = NULL;
											xmlNode* _tmp212_ = NULL;
											const gchar* _tmp213_ = NULL;
											gchar* _tmp214_ = NULL;
											_tmp211_ = node5;
											_tmp212_ = _tmp211_->children;
											_tmp213_ = _tmp212_->content;
											_tmp214_ = g_strdup (_tmp213_);
											_g_free0 (c_filename);
											c_filename = _tmp214_;
										}
										_tmp215_ = node5;
										_tmp216_ = _tmp215_->name;
										if (g_strcmp0 (_tmp216_, "downloadlink") == 0) {
											xmlNode* _tmp217_ = NULL;
											xmlNode* _tmp218_ = NULL;
											const gchar* _tmp219_ = NULL;
											gchar* _tmp220_ = NULL;
											_tmp217_ = node5;
											_tmp218_ = _tmp217_->children;
											_tmp219_ = _tmp218_->content;
											_tmp220_ = g_strdup (_tmp219_);
											_g_free0 (c_uri);
											c_uri = _tmp220_;
										}
										_tmp221_ = node5;
										_tmp222_ = _tmp221_->next;
										node5 = _tmp222_;
									}
									_tmp223_ = c_filename;
									_tmp224_ = strlen (_tmp223_);
									_tmp225_ = _tmp224_;
									len = _tmp225_;
									_tmp226_ = len;
									_tmp227_ = len2;
									if (_tmp226_ < _tmp227_) {
										gboolean _tmp228_ = FALSE;
										const gchar* _tmp229_ = NULL;
										const gchar* _tmp230_ = NULL;
										gint _tmp231_ = 0;
										gchar* _tmp232_ = NULL;
										gchar* _tmp233_ = NULL;
										gboolean _tmp234_ = FALSE;
										_tmp229_ = c_filename;
										_tmp230_ = main_filename;
										_tmp231_ = len;
										_tmp232_ = string_substring (_tmp230_, (glong) 0, (glong) _tmp231_);
										_tmp233_ = _tmp232_;
										_tmp234_ = g_strcmp0 (_tmp229_, _tmp233_) == 0;
										_g_free0 (_tmp233_);
										if (_tmp234_) {
											const gchar* _tmp235_ = NULL;
											_tmp235_ = c_uri;
											_tmp228_ = g_strcmp0 (_tmp235_, "") != 0;
										} else {
											_tmp228_ = FALSE;
										}
										if (_tmp228_) {
											GValue v = {0};
											const gchar* _tmp236_ = NULL;
											GValue _tmp237_ = {0};
											SubmarineSubtitle* subtitle = NULL;
											SubmarineServerInfo _tmp238_ = {0};
											SubmarineServerInfo _tmp239_ = {0};
											GValue _tmp240_ = {0};
											SubmarineSubtitle* _tmp241_ = NULL;
											SubmarineSubtitle* _tmp242_ = NULL;
											const gchar* _tmp243_ = NULL;
											GeeHashSet* _tmp244_ = NULL;
											SubmarineSubtitle* _tmp245_ = NULL;
											_tmp236_ = c_uri;
											g_value_init (&_tmp237_, G_TYPE_STRING);
											g_value_set_string (&_tmp237_, _tmp236_);
											v = _tmp237_;
											submarine_subtitle_server_get_info ((SubmarineSubtitleServer*) self, &_tmp238_);
											_tmp239_ = _tmp238_;
											_tmp240_ = v;
											_tmp241_ = submarine_subtitle_new (&_tmp239_, &_tmp240_);
											subtitle = _tmp241_;
											_tmp242_ = subtitle;
											_tmp243_ = l;
											submarine_subtitle_set_language (_tmp242_, _tmp243_);
											_tmp244_ = subtitles_downloaded;
											_tmp245_ = subtitle;
											gee_abstract_collection_add ((GeeAbstractCollection*) _tmp244_, _tmp245_);
											_submarine_subtitle_unref0 (subtitle);
											G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
										}
									}
									_g_free0 (c_uri);
									_g_free0 (c_filename);
								}
								_tmp246_ = node4;
								_tmp247_ = _tmp246_->next;
								node4 = _tmp247_;
							}
						}
					}
				}
				_g_free0 (rv);
			}
			_g_object_unref0 (message);
			_g_free0 (petition);
			_g_free0 (l);
		}
		_g_object_unref0 (_l_it);
	}
	result = (GeeSet*) subtitles_downloaded;
	_g_free0 (retval);
	_g_free0 (title);
	_submarine_cache_data_unref0 (cache);
	_submarine_name_parser_unref0 (parser);
	_g_free0 (main_filename);
	_g_free0 (tmp);
	_g_free0 (tvdbid);
	_g_free0 (showid);
	return result;
}


static xmlNode* submarine_bierdopje_server_find_xml_content (SubmarineBierdopjeServer* self, const gchar* content, xmlNode* node) {
	xmlNode* result = NULL;
	xmlNode* tmp = NULL;
	xmlNode* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	xmlNode* _tmp4_ = NULL;
	xmlNode* _tmp5_ = NULL;
	xmlNode* _tmp12_ = NULL;
	xmlNode* _tmp13_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (content != NULL, NULL);
	_tmp0_ = node;
	_tmp1_ = _tmp0_->name;
	_tmp2_ = content;
	if (g_strcmp0 (_tmp1_, _tmp2_) == 0) {
		xmlNode* _tmp3_ = NULL;
		_tmp3_ = node;
		result = _tmp3_;
		return result;
	}
	_tmp4_ = node;
	_tmp5_ = _tmp4_->children;
	if (_tmp5_ != NULL) {
		const gchar* _tmp6_ = NULL;
		xmlNode* _tmp7_ = NULL;
		xmlNode* _tmp8_ = NULL;
		xmlNode* _tmp9_ = NULL;
		xmlNode* _tmp10_ = NULL;
		_tmp6_ = content;
		_tmp7_ = node;
		_tmp8_ = _tmp7_->children;
		_tmp9_ = submarine_bierdopje_server_find_xml_content (self, _tmp6_, _tmp8_);
		tmp = _tmp9_;
		_tmp10_ = tmp;
		if (_tmp10_ != NULL) {
			xmlNode* _tmp11_ = NULL;
			_tmp11_ = tmp;
			result = _tmp11_;
			return result;
		}
	}
	_tmp12_ = node;
	_tmp13_ = _tmp12_->next;
	if (_tmp13_ != NULL) {
		const gchar* _tmp14_ = NULL;
		xmlNode* _tmp15_ = NULL;
		xmlNode* _tmp16_ = NULL;
		xmlNode* _tmp17_ = NULL;
		xmlNode* _tmp18_ = NULL;
		_tmp14_ = content;
		_tmp15_ = node;
		_tmp16_ = _tmp15_->next;
		_tmp17_ = submarine_bierdopje_server_find_xml_content (self, _tmp14_, _tmp16_);
		tmp = _tmp17_;
		_tmp18_ = tmp;
		if (_tmp18_ != NULL) {
			xmlNode* _tmp19_ = NULL;
			_tmp19_ = tmp;
			result = _tmp19_;
			return result;
		}
	}
	result = NULL;
	return result;
}


static SoupMessageHeaders* _vala_SoupMessageHeaders_copy (SoupMessageHeaders* self) {
	return g_boxed_copy (soup_message_headers_get_type (), self);
}


static gpointer __vala_SoupMessageHeaders_copy0 (gpointer self) {
	return self ? _vala_SoupMessageHeaders_copy (self) : NULL;
}


static gpointer _submarine_subtitle_ref0 (gpointer self) {
	return self ? submarine_subtitle_ref (self) : NULL;
}


static void _vala_SoupMessageHeaders_free (SoupMessageHeaders* self) {
	g_boxed_free (soup_message_headers_get_type (), self);
}


static SubmarineSubtitle* submarine_bierdopje_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle) {
	SubmarineBierdopjeServer * self;
	SubmarineSubtitle* result = NULL;
	SoupMessage* message = NULL;
	SubmarineSubtitle* _tmp0_ = NULL;
	GValue _tmp1_ = {0};
	GValue _tmp2_ = {0};
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	SoupMessage* _tmp6_ = NULL;
	SoupMessage* _tmp7_ = NULL;
	SoupMessage* _tmp8_ = NULL;
	SoupMessageHeaders* _tmp9_ = NULL;
	guint status_code = 0U;
	SoupSessionSync* _tmp10_ = NULL;
	SoupMessage* _tmp11_ = NULL;
	guint _tmp12_ = 0U;
	guint _tmp13_ = 0U;
	self = (SubmarineBierdopjeServer*) base;
	g_return_val_if_fail (subtitle != NULL, NULL);
	_tmp0_ = subtitle;
	submarine_subtitle_get_server_data (_tmp0_, &_tmp1_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_value_get_string (&_tmp2_);
	_tmp4_ = g_strdup_printf ("%s", _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = soup_message_new ("GET", _tmp5_);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	message = _tmp7_;
	_tmp8_ = message;
	_tmp9_ = _tmp8_->request_headers;
	soup_message_headers_append (_tmp9_, "User-Agent", SUBMARINE_BIERDOPJE_SERVER_USER_AGENT);
	_tmp10_ = self->priv->session;
	_tmp11_ = message;
	_tmp12_ = soup_session_send_message ((SoupSession*) _tmp10_, _tmp11_);
	status_code = _tmp12_;
	_tmp13_ = status_code;
	if (_tmp13_ == ((guint) 200)) {
		SoupMessageHeaders* rsp = NULL;
		SoupMessage* _tmp14_ = NULL;
		SoupMessageHeaders* _tmp15_ = NULL;
		SoupMessageHeaders* _tmp16_ = NULL;
		gchar* type = NULL;
		gchar* _tmp17_ = NULL;
		gchar* cadena = NULL;
		GHashTable* params = NULL;
		SoupMessageHeaders* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		GHashTable* _tmp20_ = NULL;
		gboolean _tmp21_ = FALSE;
		gboolean _tmp35_ = FALSE;
		const gchar* _tmp36_ = NULL;
		gchar* _tmp37_ = NULL;
		gchar* _tmp38_ = NULL;
		gchar* _tmp39_ = NULL;
		gchar* _tmp40_ = NULL;
		gboolean _tmp41_ = FALSE;
		_tmp14_ = message;
		_tmp15_ = _tmp14_->response_headers;
		_tmp16_ = __vala_SoupMessageHeaders_copy0 (_tmp15_);
		rsp = _tmp16_;
		_tmp17_ = g_strdup ("");
		type = _tmp17_;
		_tmp18_ = rsp;
		_tmp21_ = soup_message_headers_get_content_disposition (_tmp18_, &_tmp19_, &_tmp20_);
		_g_free0 (cadena);
		cadena = _tmp19_;
		_g_hash_table_unref0 (params);
		params = _tmp20_;
		if (_tmp21_) {
			GList* lista = NULL;
			GHashTable* _tmp22_ = NULL;
			GList* _tmp23_ = NULL;
			GList* _tmp24_ = NULL;
			_tmp22_ = params;
			_tmp23_ = g_hash_table_get_keys (_tmp22_);
			lista = _tmp23_;
			_tmp24_ = lista;
			{
				GList* entrada_collection = NULL;
				GList* entrada_it = NULL;
				entrada_collection = _tmp24_;
				for (entrada_it = entrada_collection; entrada_it != NULL; entrada_it = entrada_it->next) {
					gchar* _tmp25_ = NULL;
					gchar* entrada = NULL;
					_tmp25_ = g_strdup ((const gchar*) entrada_it->data);
					entrada = _tmp25_;
					{
						const gchar* _tmp26_ = NULL;
						_tmp26_ = entrada;
						if (g_strcmp0 (_tmp26_, "filename") == 0) {
							gchar* valor = NULL;
							GHashTable* _tmp27_ = NULL;
							const gchar* _tmp28_ = NULL;
							gconstpointer _tmp29_ = NULL;
							gchar* _tmp30_ = NULL;
							const gchar* _tmp31_ = NULL;
							const gchar* _tmp32_ = NULL;
							gint _tmp33_ = 0;
							gchar* _tmp34_ = NULL;
							_tmp27_ = params;
							_tmp28_ = entrada;
							_tmp29_ = g_hash_table_lookup (_tmp27_, _tmp28_);
							_tmp30_ = g_strdup ((const gchar*) _tmp29_);
							valor = _tmp30_;
							_tmp31_ = valor;
							_tmp32_ = valor;
							_tmp33_ = string_last_index_of (_tmp32_, ".", 0);
							_tmp34_ = string_substring (_tmp31_, (glong) (_tmp33_ + 1), (glong) (-1));
							_g_free0 (type);
							type = _tmp34_;
							_g_free0 (valor);
						}
						_g_free0 (entrada);
					}
				}
			}
			_g_list_free0 (lista);
		}
		_tmp36_ = type;
		_tmp37_ = g_utf8_casefold (_tmp36_, (gssize) (-1));
		_tmp38_ = _tmp37_;
		_tmp39_ = g_utf8_casefold ("sub", (gssize) (-1));
		_tmp40_ = _tmp39_;
		_tmp41_ = g_strcmp0 (_tmp38_, _tmp40_) == 0;
		_g_free0 (_tmp40_);
		_g_free0 (_tmp38_);
		if (_tmp41_) {
			_tmp35_ = TRUE;
		} else {
			const gchar* _tmp42_ = NULL;
			gchar* _tmp43_ = NULL;
			gchar* _tmp44_ = NULL;
			gchar* _tmp45_ = NULL;
			gchar* _tmp46_ = NULL;
			_tmp42_ = type;
			_tmp43_ = g_utf8_casefold (_tmp42_, (gssize) (-1));
			_tmp44_ = _tmp43_;
			_tmp45_ = g_utf8_casefold ("srt", (gssize) (-1));
			_tmp46_ = _tmp45_;
			_tmp35_ = g_strcmp0 (_tmp44_, _tmp46_) == 0;
			_g_free0 (_tmp46_);
			_g_free0 (_tmp44_);
		}
		if (_tmp35_) {
			SubmarineSubtitle* _tmp47_ = NULL;
			const gchar* _tmp48_ = NULL;
			SubmarineSubtitle* _tmp49_ = NULL;
			SoupMessage* _tmp50_ = NULL;
			SoupMessageBody* _tmp51_ = NULL;
			guint8* _tmp52_ = NULL;
			gint _tmp52__length1 = 0;
			SubmarineSubtitle* _tmp53_ = NULL;
			SubmarineSubtitle* _tmp54_ = NULL;
			_tmp47_ = subtitle;
			_tmp48_ = type;
			submarine_subtitle_set_format (_tmp47_, _tmp48_);
			_tmp49_ = subtitle;
			_tmp50_ = message;
			_tmp51_ = _tmp50_->response_body;
			_tmp52_ = _tmp51_->data;
			_tmp52__length1 = (gint) _tmp51_->length;
			submarine_subtitle_set_data (_tmp49_, (const gchar*) _tmp52_);
			_tmp53_ = subtitle;
			_tmp54_ = _submarine_subtitle_ref0 (_tmp53_);
			result = _tmp54_;
			_g_hash_table_unref0 (params);
			_g_free0 (cadena);
			_g_free0 (type);
			__vala_SoupMessageHeaders_free0 (rsp);
			_g_object_unref0 (message);
			return result;
		}
		_g_hash_table_unref0 (params);
		_g_free0 (cadena);
		_g_free0 (type);
		__vala_SoupMessageHeaders_free0 (rsp);
	}
	result = NULL;
	_g_object_unref0 (message);
	return result;
}


SubmarineBierdopjeServer* submarine_bierdopje_server_construct (GType object_type) {
	SubmarineBierdopjeServer * self = NULL;
	self = (SubmarineBierdopjeServer*) submarine_subtitle_server_construct (object_type);
	return self;
}


SubmarineBierdopjeServer* submarine_bierdopje_server_new (void) {
	return submarine_bierdopje_server_construct (SUBMARINE_TYPE_BIERDOPJE_SERVER);
}


static GObject * submarine_bierdopje_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SubmarineBierdopjeServer * self;
	SubmarineServerInfo _tmp0_ = {0};
	SubmarineServerInfo _tmp1_ = {0};
	gchar* _tmp2_ = NULL;
	parent_class = G_OBJECT_CLASS (submarine_bierdopje_server_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_BIERDOPJE_SERVER, SubmarineBierdopjeServer);
	submarine_server_info_init (&_tmp0_, "Bierdopje", "http://www.bierdopje.com", "bd");
	_tmp1_ = _tmp0_;
	submarine_subtitle_server_set_info ((SubmarineSubtitleServer*) self, &_tmp1_);
	submarine_server_info_destroy (&_tmp1_);
	_tmp2_ = g_strdup ("");
	_g_free0 (self->priv->filepath);
	self->priv->filepath = _tmp2_;
	return obj;
}


static void submarine_bierdopje_server_class_init (SubmarineBierdopjeServerClass * klass) {
	submarine_bierdopje_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SubmarineBierdopjeServerPrivate));
	((SubmarineSubtitleServerClass *) klass)->connect = submarine_bierdopje_server_real_connect;
	((SubmarineSubtitleServerClass *) klass)->disconnect = submarine_bierdopje_server_real_disconnect;
	((SubmarineSubtitleServerClass *) klass)->search = submarine_bierdopje_server_real_search;
	((SubmarineSubtitleServerClass *) klass)->download = submarine_bierdopje_server_real_download;
	G_OBJECT_CLASS (klass)->constructor = submarine_bierdopje_server_constructor;
	G_OBJECT_CLASS (klass)->finalize = submarine_bierdopje_server_finalize;
}


static void submarine_bierdopje_server_instance_init (SubmarineBierdopjeServer * self) {
	self->priv = SUBMARINE_BIERDOPJE_SERVER_GET_PRIVATE (self);
}


static void submarine_bierdopje_server_finalize (GObject* obj) {
	SubmarineBierdopjeServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_BIERDOPJE_SERVER, SubmarineBierdopjeServer);
	_g_object_unref0 (self->priv->session);
	_g_free0 (self->priv->filepath);
	G_OBJECT_CLASS (submarine_bierdopje_server_parent_class)->finalize (obj);
}


GType submarine_bierdopje_server_get_type (void) {
	static volatile gsize submarine_bierdopje_server_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_bierdopje_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineBierdopjeServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_bierdopje_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineBierdopjeServer), 0, (GInstanceInitFunc) submarine_bierdopje_server_instance_init, NULL };
		GType submarine_bierdopje_server_type_id;
		submarine_bierdopje_server_type_id = g_type_register_static (SUBMARINE_TYPE_SUBTITLE_SERVER, "SubmarineBierdopjeServer", &g_define_type_info, 0);
		g_once_init_leave (&submarine_bierdopje_server_type_id__volatile, submarine_bierdopje_server_type_id);
	}
	return submarine_bierdopje_server_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



