/* cachedata.c generated by valac 0.28.0, the Vala compiler
 * generated from cachedata.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define SUBMARINE_TYPE_CACHE_DATA (submarine_cache_data_get_type ())
#define SUBMARINE_CACHE_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_CACHE_DATA, SubmarineCacheData))
#define SUBMARINE_CACHE_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_CACHE_DATA, SubmarineCacheDataClass))
#define SUBMARINE_IS_CACHE_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_CACHE_DATA))
#define SUBMARINE_IS_CACHE_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_CACHE_DATA))
#define SUBMARINE_CACHE_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_CACHE_DATA, SubmarineCacheDataClass))

typedef struct _SubmarineCacheData SubmarineCacheData;
typedef struct _SubmarineCacheDataClass SubmarineCacheDataClass;
typedef struct _SubmarineCacheDataPrivate SubmarineCacheDataPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _SubmarineParamSpecCacheData SubmarineParamSpecCacheData;

struct _SubmarineCacheData {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SubmarineCacheDataPrivate * priv;
};

struct _SubmarineCacheDataClass {
	GTypeClass parent_class;
	void (*finalize) (SubmarineCacheData *self);
};

struct _SubmarineCacheDataPrivate {
	GeeHashMap* key_values;
	gchar* filepath;
	gint64 c_version;
};

struct _SubmarineParamSpecCacheData {
	GParamSpec parent_instance;
};


static gpointer submarine_cache_data_parent_class = NULL;

gpointer submarine_cache_data_ref (gpointer instance);
void submarine_cache_data_unref (gpointer instance);
GParamSpec* submarine_param_spec_cache_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_cache_data (GValue* value, gpointer v_object);
void submarine_value_take_cache_data (GValue* value, gpointer v_object);
gpointer submarine_value_get_cache_data (const GValue* value);
GType submarine_cache_data_get_type (void) G_GNUC_CONST;
#define SUBMARINE_CACHE_DATA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_CACHE_DATA, SubmarineCacheDataPrivate))
enum  {
	SUBMARINE_CACHE_DATA_DUMMY_PROPERTY
};
SubmarineCacheData* submarine_cache_data_new (const gchar* filename, gint64 version);
SubmarineCacheData* submarine_cache_data_construct (GType object_type, const gchar* filename, gint64 version);
gchar* submarine_cache_data_get_key (SubmarineCacheData* self, const gchar* key);
void submarine_cache_data_set_key (SubmarineCacheData* self, const gchar* key, const gchar* val);
static void submarine_cache_data_finalize (SubmarineCacheData* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch2_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) (-1), 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch2_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally2;
	__catch2_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gint64 int64_parse (const gchar* str) {
	gint64 result = 0LL;
	const gchar* _tmp0_ = NULL;
	gint64 _tmp1_ = 0LL;
	g_return_val_if_fail (str != NULL, 0LL);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtoll (_tmp0_, NULL, (guint) 0);
	result = _tmp1_;
	return result;
}


SubmarineCacheData* submarine_cache_data_construct (GType object_type, const gchar* filename, gint64 version) {
	SubmarineCacheData* self = NULL;
	gint64 _tmp0_ = 0LL;
	GeeHashMap* _tmp1_ = NULL;
	GFileInputStream* file_read = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	GFile* config_file = NULL;
	const gchar* _tmp7_ = NULL;
	GFile* _tmp8_ = NULL;
	GFile* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	GDataInputStream* in_stream = NULL;
	GFileInputStream* _tmp15_ = NULL;
	GDataInputStream* _tmp16_ = NULL;
	gchar* line = NULL;
	gboolean first_line = FALSE;
	GDataInputStream* _tmp65_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (SubmarineCacheData*) g_type_create_instance (object_type);
	_tmp0_ = version;
	self->priv->c_version = _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->key_values);
	self->priv->key_values = _tmp1_;
	_tmp2_ = g_get_home_dir ();
	_tmp3_ = filename;
	_tmp4_ = g_strconcat (".", _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_build_filename (_tmp2_, _tmp5_, NULL);
	_g_free0 (self->priv->filepath);
	self->priv->filepath = _tmp6_;
	_g_free0 (_tmp5_);
	_tmp7_ = self->priv->filepath;
	_tmp8_ = g_file_new_for_path (_tmp7_);
	config_file = _tmp8_;
	_tmp9_ = config_file;
	_tmp10_ = g_file_query_exists (_tmp9_, NULL);
	if (!_tmp10_) {
		_g_object_unref0 (config_file);
		_g_object_unref0 (file_read);
		return self;
	}
	{
		GFileInputStream* _tmp11_ = NULL;
		GFile* _tmp12_ = NULL;
		GFileInputStream* _tmp13_ = NULL;
		GFileInputStream* _tmp14_ = NULL;
		_tmp12_ = config_file;
		_tmp13_ = g_file_read (_tmp12_, NULL, &_inner_error_);
		_tmp11_ = _tmp13_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch1_g_error;
		}
		_tmp14_ = _tmp11_;
		_tmp11_ = NULL;
		_g_object_unref0 (file_read);
		file_read = _tmp14_;
		_g_object_unref0 (_tmp11_);
	}
	goto __finally1;
	__catch1_g_error:
	{
		g_clear_error (&_inner_error_);
		_inner_error_ = NULL;
		_g_object_unref0 (config_file);
		_g_object_unref0 (file_read);
		return self;
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (config_file);
		_g_object_unref0 (file_read);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp15_ = file_read;
	_tmp16_ = g_data_input_stream_new ((GInputStream*) _tmp15_);
	in_stream = _tmp16_;
	first_line = TRUE;
	while (TRUE) {
		gchar* _tmp17_ = NULL;
		GDataInputStream* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		const gchar* _tmp22_ = NULL;
		gint _tmp23_ = 0;
		gint _tmp24_ = 0;
		gchar** values = NULL;
		const gchar* _tmp25_ = NULL;
		gchar** _tmp26_ = NULL;
		gchar** _tmp27_ = NULL;
		gint values_length1 = 0;
		gint _values_size_ = 0;
		gchar** _tmp28_ = NULL;
		gint _tmp28__length1 = 0;
		const gchar* _tmp29_ = NULL;
		gchar* _tmp30_ = NULL;
		gchar* _tmp31_ = NULL;
		gchar** _tmp32_ = NULL;
		gint _tmp32__length1 = 0;
		const gchar* _tmp33_ = NULL;
		gchar* _tmp34_ = NULL;
		gchar* _tmp35_ = NULL;
		gchar** _tmp36_ = NULL;
		gint _tmp36__length1 = 0;
		const gchar* _tmp37_ = NULL;
		gchar* _tmp38_ = NULL;
		gchar* _tmp39_ = NULL;
		gchar** _tmp40_ = NULL;
		gint _tmp40__length1 = 0;
		const gchar* _tmp41_ = NULL;
		gchar* _tmp42_ = NULL;
		gchar* _tmp43_ = NULL;
		gchar** _tmp44_ = NULL;
		gint _tmp44__length1 = 0;
		const gchar* _tmp45_ = NULL;
		gchar* _tmp46_ = NULL;
		gchar* _tmp47_ = NULL;
		gchar** _tmp48_ = NULL;
		gint _tmp48__length1 = 0;
		const gchar* _tmp49_ = NULL;
		gchar* _tmp50_ = NULL;
		gchar* _tmp51_ = NULL;
		gboolean _tmp52_ = FALSE;
		_tmp18_ = in_stream;
		_tmp19_ = g_data_input_stream_read_line (_tmp18_, NULL, NULL, &_inner_error_);
		_tmp17_ = _tmp19_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (line);
			_g_object_unref0 (in_stream);
			_g_object_unref0 (config_file);
			_g_object_unref0 (file_read);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp20_ = _tmp17_;
		_tmp17_ = NULL;
		_g_free0 (line);
		line = _tmp20_;
		_tmp21_ = line;
		if (!(_tmp21_ != NULL)) {
			_g_free0 (_tmp17_);
			break;
		}
		_tmp22_ = line;
		_tmp23_ = strlen (_tmp22_);
		_tmp24_ = _tmp23_;
		if (_tmp24_ == 0) {
			_g_free0 (_tmp17_);
			continue;
		}
		_tmp25_ = line;
		_tmp27_ = _tmp26_ = g_strsplit (_tmp25_, "=", 0);
		values = _tmp27_;
		values_length1 = _vala_array_length (_tmp26_);
		_values_size_ = values_length1;
		_tmp28_ = values;
		_tmp28__length1 = values_length1;
		_tmp29_ = _tmp28_[0];
		_tmp30_ = string_replace (_tmp29_, "\\=", "=");
		_tmp31_ = _tmp30_;
		_g_free0 (_tmp31_);
		_tmp32_ = values;
		_tmp32__length1 = values_length1;
		_tmp33_ = _tmp32_[1];
		_tmp34_ = string_replace (_tmp33_, "\\=", "=");
		_tmp35_ = _tmp34_;
		_g_free0 (_tmp35_);
		_tmp36_ = values;
		_tmp36__length1 = values_length1;
		_tmp37_ = _tmp36_[0];
		_tmp38_ = string_replace (_tmp37_, "\\\\", "\\");
		_tmp39_ = _tmp38_;
		_g_free0 (_tmp39_);
		_tmp40_ = values;
		_tmp40__length1 = values_length1;
		_tmp41_ = _tmp40_[1];
		_tmp42_ = string_replace (_tmp41_, "\\\\", "\\");
		_tmp43_ = _tmp42_;
		_g_free0 (_tmp43_);
		_tmp44_ = values;
		_tmp44__length1 = values_length1;
		_tmp45_ = _tmp44_[0];
		_tmp46_ = string_replace (_tmp45_, "\n", "");
		_tmp47_ = _tmp46_;
		_g_free0 (_tmp47_);
		_tmp48_ = values;
		_tmp48__length1 = values_length1;
		_tmp49_ = _tmp48_[1];
		_tmp50_ = string_replace (_tmp49_, "\n", "");
		_tmp51_ = _tmp50_;
		_g_free0 (_tmp51_);
		_tmp52_ = first_line;
		if (_tmp52_) {
			gboolean _tmp53_ = FALSE;
			gchar** _tmp54_ = NULL;
			gint _tmp54__length1 = 0;
			const gchar* _tmp55_ = NULL;
			first_line = FALSE;
			_tmp54_ = values;
			_tmp54__length1 = values_length1;
			_tmp55_ = _tmp54_[0];
			if (g_strcmp0 (_tmp55_, "version") != 0) {
				_tmp53_ = TRUE;
			} else {
				gchar** _tmp56_ = NULL;
				gint _tmp56__length1 = 0;
				const gchar* _tmp57_ = NULL;
				gint64 _tmp58_ = 0LL;
				gint64 _tmp59_ = 0LL;
				_tmp56_ = values;
				_tmp56__length1 = values_length1;
				_tmp57_ = _tmp56_[1];
				_tmp58_ = int64_parse (_tmp57_);
				_tmp59_ = self->priv->c_version;
				_tmp53_ = _tmp58_ < _tmp59_;
			}
			if (_tmp53_) {
				values = (_vala_array_free (values, values_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (_tmp17_);
				break;
			}
		} else {
			GeeHashMap* _tmp60_ = NULL;
			gchar** _tmp61_ = NULL;
			gint _tmp61__length1 = 0;
			const gchar* _tmp62_ = NULL;
			gchar** _tmp63_ = NULL;
			gint _tmp63__length1 = 0;
			const gchar* _tmp64_ = NULL;
			_tmp60_ = self->priv->key_values;
			_tmp61_ = values;
			_tmp61__length1 = values_length1;
			_tmp62_ = _tmp61_[0];
			_tmp63_ = values;
			_tmp63__length1 = values_length1;
			_tmp64_ = _tmp63_[1];
			gee_abstract_map_set ((GeeAbstractMap*) _tmp60_, _tmp62_, _tmp64_);
		}
		values = (_vala_array_free (values, values_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_tmp17_);
	}
	_tmp65_ = in_stream;
	g_input_stream_close ((GInputStream*) _tmp65_, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (line);
		_g_object_unref0 (in_stream);
		_g_object_unref0 (config_file);
		_g_object_unref0 (file_read);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_g_free0 (line);
	_g_object_unref0 (in_stream);
	_g_object_unref0 (config_file);
	_g_object_unref0 (file_read);
	return self;
}


SubmarineCacheData* submarine_cache_data_new (const gchar* filename, gint64 version) {
	return submarine_cache_data_construct (SUBMARINE_TYPE_CACHE_DATA, filename, version);
}


gchar* submarine_cache_data_get_key (SubmarineCacheData* self, const gchar* key) {
	gchar* result = NULL;
	GeeHashMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp0_ = self->priv->key_values;
	_tmp1_ = key;
	_tmp2_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp1_);
	if (_tmp2_) {
		GeeHashMap* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		_tmp3_ = self->priv->key_values;
		_tmp4_ = key;
		_tmp5_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp3_, _tmp4_);
		result = (gchar*) _tmp5_;
		return result;
	} else {
		result = NULL;
		return result;
	}
}


static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res = NULL;
	gint res_length1 = 0;
	gint _res_size_ = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	guint8* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res_length1;
	_tmp3_ = res;
	_tmp3__length1 = res_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


void submarine_cache_data_set_key (SubmarineCacheData* self, const gchar* key, const gchar* val) {
	GeeHashMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	GeeHashMap* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	GFile* config_file = NULL;
	const gchar* _tmp8_ = NULL;
	GFile* _tmp9_ = NULL;
	GFileOutputStream* file_write = NULL;
	GFile* _tmp10_ = NULL;
	GFileOutputStream* _tmp11_ = NULL;
	GFileOutputStream* _tmp12_ = NULL;
	gint64 _tmp13_ = 0LL;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	guint8* _tmp16_ = NULL;
	gint _tmp16__length1 = 0;
	guint8* _tmp17_ = NULL;
	gint _tmp17__length1 = 0;
	GFileOutputStream* _tmp50_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	g_return_if_fail (val != NULL);
	_tmp0_ = self->priv->key_values;
	_tmp1_ = key;
	_tmp2_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, _tmp1_);
	if (_tmp2_) {
		GeeHashMap* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		_tmp3_ = self->priv->key_values;
		_tmp4_ = key;
		gee_abstract_map_unset ((GeeAbstractMap*) _tmp3_, _tmp4_, NULL);
	}
	_tmp5_ = self->priv->key_values;
	_tmp6_ = key;
	_tmp7_ = val;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp5_, _tmp6_, _tmp7_);
	_tmp8_ = self->priv->filepath;
	_tmp9_ = g_file_new_for_path (_tmp8_);
	config_file = _tmp9_;
	_tmp10_ = config_file;
	_tmp11_ = g_file_replace (_tmp10_, NULL, FALSE, G_FILE_CREATE_NONE, NULL, &_inner_error_);
	file_write = _tmp11_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (config_file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp12_ = file_write;
	_tmp13_ = self->priv->c_version;
	_tmp14_ = g_strdup_printf ("version=%lld\n", _tmp13_);
	_tmp15_ = _tmp14_;
	_tmp16_ = string_get_data (_tmp15_, &_tmp16__length1);
	_tmp17_ = _tmp16_;
	_tmp17__length1 = _tmp16__length1;
	g_output_stream_write ((GOutputStream*) _tmp12_, _tmp17_, (gsize) _tmp17__length1, NULL, &_inner_error_);
	_g_free0 (_tmp15_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (file_write);
		_g_object_unref0 (config_file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		GeeIterator* _vkey_it = NULL;
		GeeHashMap* _tmp18_ = NULL;
		GeeSet* _tmp19_ = NULL;
		GeeSet* _tmp20_ = NULL;
		GeeSet* _tmp21_ = NULL;
		GeeIterator* _tmp22_ = NULL;
		GeeIterator* _tmp23_ = NULL;
		_tmp18_ = self->priv->key_values;
		_tmp19_ = gee_abstract_map_get_keys ((GeeMap*) _tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = _tmp20_;
		_tmp22_ = gee_iterable_iterator ((GeeIterable*) _tmp21_);
		_tmp23_ = _tmp22_;
		_g_object_unref0 (_tmp21_);
		_vkey_it = _tmp23_;
		while (TRUE) {
			GeeIterator* _tmp24_ = NULL;
			gboolean _tmp25_ = FALSE;
			gchar* vkey = NULL;
			GeeIterator* _tmp26_ = NULL;
			gpointer _tmp27_ = NULL;
			gchar* vval = NULL;
			GeeHashMap* _tmp28_ = NULL;
			const gchar* _tmp29_ = NULL;
			gpointer _tmp30_ = NULL;
			const gchar* _tmp31_ = NULL;
			gchar* _tmp32_ = NULL;
			gchar* _tmp33_ = NULL;
			const gchar* _tmp34_ = NULL;
			gchar* _tmp35_ = NULL;
			gchar* _tmp36_ = NULL;
			const gchar* _tmp37_ = NULL;
			gchar* _tmp38_ = NULL;
			gchar* _tmp39_ = NULL;
			const gchar* _tmp40_ = NULL;
			gchar* _tmp41_ = NULL;
			gchar* _tmp42_ = NULL;
			GFileOutputStream* _tmp43_ = NULL;
			const gchar* _tmp44_ = NULL;
			const gchar* _tmp45_ = NULL;
			gchar* _tmp46_ = NULL;
			gchar* _tmp47_ = NULL;
			guint8* _tmp48_ = NULL;
			gint _tmp48__length1 = 0;
			guint8* _tmp49_ = NULL;
			gint _tmp49__length1 = 0;
			_tmp24_ = _vkey_it;
			_tmp25_ = gee_iterator_next (_tmp24_);
			if (!_tmp25_) {
				break;
			}
			_tmp26_ = _vkey_it;
			_tmp27_ = gee_iterator_get (_tmp26_);
			vkey = (gchar*) _tmp27_;
			_tmp28_ = self->priv->key_values;
			_tmp29_ = vkey;
			_tmp30_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp28_, _tmp29_);
			vval = (gchar*) _tmp30_;
			_tmp31_ = vkey;
			_tmp32_ = string_replace (_tmp31_, "\\", "\\\\");
			_tmp33_ = _tmp32_;
			_g_free0 (_tmp33_);
			_tmp34_ = vkey;
			_tmp35_ = string_replace (_tmp34_, "=", "\\=");
			_tmp36_ = _tmp35_;
			_g_free0 (_tmp36_);
			_tmp37_ = vval;
			_tmp38_ = string_replace (_tmp37_, "\\", "\\\\");
			_tmp39_ = _tmp38_;
			_g_free0 (_tmp39_);
			_tmp40_ = vval;
			_tmp41_ = string_replace (_tmp40_, "=", "\\=");
			_tmp42_ = _tmp41_;
			_g_free0 (_tmp42_);
			_tmp43_ = file_write;
			_tmp44_ = vkey;
			_tmp45_ = vval;
			_tmp46_ = g_strdup_printf ("%s=%s\n", _tmp44_, _tmp45_);
			_tmp47_ = _tmp46_;
			_tmp48_ = string_get_data (_tmp47_, &_tmp48__length1);
			_tmp49_ = _tmp48_;
			_tmp49__length1 = _tmp48__length1;
			g_output_stream_write ((GOutputStream*) _tmp43_, _tmp49_, (gsize) _tmp49__length1, NULL, &_inner_error_);
			_g_free0 (_tmp47_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (vval);
				_g_free0 (vkey);
				_g_object_unref0 (_vkey_it);
				_g_object_unref0 (file_write);
				_g_object_unref0 (config_file);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_g_free0 (vval);
			_g_free0 (vkey);
		}
		_g_object_unref0 (_vkey_it);
	}
	_tmp50_ = file_write;
	g_output_stream_close ((GOutputStream*) _tmp50_, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (file_write);
		_g_object_unref0 (config_file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (file_write);
	_g_object_unref0 (config_file);
}


static void submarine_value_cache_data_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void submarine_value_cache_data_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		submarine_cache_data_unref (value->data[0].v_pointer);
	}
}


static void submarine_value_cache_data_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = submarine_cache_data_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer submarine_value_cache_data_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* submarine_value_cache_data_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SubmarineCacheData* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = submarine_cache_data_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* submarine_value_cache_data_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SubmarineCacheData** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = submarine_cache_data_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* submarine_param_spec_cache_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	SubmarineParamSpecCacheData* spec;
	g_return_val_if_fail (g_type_is_a (object_type, SUBMARINE_TYPE_CACHE_DATA), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer submarine_value_get_cache_data (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SUBMARINE_TYPE_CACHE_DATA), NULL);
	return value->data[0].v_pointer;
}


void submarine_value_set_cache_data (GValue* value, gpointer v_object) {
	SubmarineCacheData* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SUBMARINE_TYPE_CACHE_DATA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SUBMARINE_TYPE_CACHE_DATA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		submarine_cache_data_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		submarine_cache_data_unref (old);
	}
}


void submarine_value_take_cache_data (GValue* value, gpointer v_object) {
	SubmarineCacheData* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SUBMARINE_TYPE_CACHE_DATA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SUBMARINE_TYPE_CACHE_DATA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		submarine_cache_data_unref (old);
	}
}


static void submarine_cache_data_class_init (SubmarineCacheDataClass * klass) {
	submarine_cache_data_parent_class = g_type_class_peek_parent (klass);
	((SubmarineCacheDataClass *) klass)->finalize = submarine_cache_data_finalize;
	g_type_class_add_private (klass, sizeof (SubmarineCacheDataPrivate));
}


static void submarine_cache_data_instance_init (SubmarineCacheData * self) {
	self->priv = SUBMARINE_CACHE_DATA_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void submarine_cache_data_finalize (SubmarineCacheData* obj) {
	SubmarineCacheData * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_CACHE_DATA, SubmarineCacheData);
	g_signal_handlers_destroy (self);
	_g_object_unref0 (self->priv->key_values);
	_g_free0 (self->priv->filepath);
}


GType submarine_cache_data_get_type (void) {
	static volatile gsize submarine_cache_data_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_cache_data_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { submarine_value_cache_data_init, submarine_value_cache_data_free_value, submarine_value_cache_data_copy_value, submarine_value_cache_data_peek_pointer, "p", submarine_value_cache_data_collect_value, "p", submarine_value_cache_data_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineCacheDataClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_cache_data_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineCacheData), 0, (GInstanceInitFunc) submarine_cache_data_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType submarine_cache_data_type_id;
		submarine_cache_data_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SubmarineCacheData", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&submarine_cache_data_type_id__volatile, submarine_cache_data_type_id);
	}
	return submarine_cache_data_type_id__volatile;
}


gpointer submarine_cache_data_ref (gpointer instance) {
	SubmarineCacheData* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void submarine_cache_data_unref (gpointer instance) {
	SubmarineCacheData* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SUBMARINE_CACHE_DATA_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



