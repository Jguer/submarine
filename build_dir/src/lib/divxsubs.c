/* divxsubs.c generated by valac 0.28.0, the Vala compiler
 * generated from divxsubs.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <libsoup/soup.h>
#include <float.h>
#include <math.h>


#define SUBMARINE_TYPE_SUBTITLE_SERVER (submarine_subtitle_server_get_type ())
#define SUBMARINE_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer))
#define SUBMARINE_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))
#define SUBMARINE_IS_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_IS_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_SUBTITLE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))

typedef struct _SubmarineSubtitleServer SubmarineSubtitleServer;
typedef struct _SubmarineSubtitleServerClass SubmarineSubtitleServerClass;
typedef struct _SubmarineSubtitleServerPrivate SubmarineSubtitleServerPrivate;

#define SUBMARINE_TYPE_SUBTITLE (submarine_subtitle_get_type ())
#define SUBMARINE_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitle))
#define SUBMARINE_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))
#define SUBMARINE_IS_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_IS_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_SUBTITLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))

typedef struct _SubmarineSubtitle SubmarineSubtitle;
typedef struct _SubmarineSubtitleClass SubmarineSubtitleClass;

#define SUBMARINE_TYPE_DIV_XSUBS_SERVER (submarine_div_xsubs_server_get_type ())
#define SUBMARINE_DIV_XSUBS_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_DIV_XSUBS_SERVER, SubmarineDivXsubsServer))
#define SUBMARINE_DIV_XSUBS_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_DIV_XSUBS_SERVER, SubmarineDivXsubsServerClass))
#define SUBMARINE_IS_DIV_XSUBS_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_DIV_XSUBS_SERVER))
#define SUBMARINE_IS_DIV_XSUBS_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_DIV_XSUBS_SERVER))
#define SUBMARINE_DIV_XSUBS_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_DIV_XSUBS_SERVER, SubmarineDivXsubsServerClass))

typedef struct _SubmarineDivXsubsServer SubmarineDivXsubsServer;
typedef struct _SubmarineDivXsubsServerClass SubmarineDivXsubsServerClass;
typedef struct _SubmarineDivXsubsServerPrivate SubmarineDivXsubsServerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define SUBMARINE_TYPE_SERVER_INFO (submarine_server_info_get_type ())
typedef struct _SubmarineServerInfo SubmarineServerInfo;
#define _submarine_subtitle_unref0(var) ((var == NULL) ? NULL : (var = (submarine_subtitle_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _SubmarineSubtitleServer {
	GObject parent_instance;
	SubmarineSubtitleServerPrivate * priv;
};

struct _SubmarineSubtitleServerClass {
	GObjectClass parent_class;
	gboolean (*connect) (SubmarineSubtitleServer* self);
	void (*disconnect) (SubmarineSubtitleServer* self);
	GeeSet* (*search) (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
	GeeMultiMap* (*search_multiple) (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
	SubmarineSubtitle* (*download) (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
	GeeSet* (*download_multiple) (SubmarineSubtitleServer* self, GeeCollection* subtitles);
};

struct _SubmarineDivXsubsServer {
	SubmarineSubtitleServer parent_instance;
	SubmarineDivXsubsServerPrivate * priv;
};

struct _SubmarineDivXsubsServerClass {
	SubmarineSubtitleServerClass parent_class;
};

struct _SubmarineDivXsubsServerPrivate {
	SoupSessionSync* session;
	gchar* filepath;
};

struct _SubmarineServerInfo {
	gchar* _name;
	gchar* _address;
	gchar* _code;
};


static gpointer submarine_div_xsubs_server_parent_class = NULL;

GType submarine_subtitle_server_get_type (void) G_GNUC_CONST;
gpointer submarine_subtitle_ref (gpointer instance);
void submarine_subtitle_unref (gpointer instance);
GParamSpec* submarine_param_spec_subtitle (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_subtitle (GValue* value, gpointer v_object);
void submarine_value_take_subtitle (GValue* value, gpointer v_object);
gpointer submarine_value_get_subtitle (const GValue* value);
GType submarine_subtitle_get_type (void) G_GNUC_CONST;
GType submarine_div_xsubs_server_get_type (void) G_GNUC_CONST;
#define SUBMARINE_DIV_XSUBS_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_DIV_XSUBS_SERVER, SubmarineDivXsubsServerPrivate))
enum  {
	SUBMARINE_DIV_XSUBS_SERVER_DUMMY_PROPERTY
};
#define SUBMARINE_DIV_XSUBS_SERVER_MAIN_URI "http://www.divxsubs.com"
#define SUBMARINE_DIV_XSUBS_SERVER_USER_AGENT "submarine/0.1"
static gboolean submarine_div_xsubs_server_real_connect (SubmarineSubtitleServer* base);
static void submarine_div_xsubs_server_real_disconnect (SubmarineSubtitleServer* base);
static GeeSet* submarine_div_xsubs_server_real_search (SubmarineSubtitleServer* base, GFile* file, GeeCollection* languages);
gchar* submarine_get_alternate (const gchar* language);
GType submarine_server_info_get_type (void) G_GNUC_CONST;
SubmarineServerInfo* submarine_server_info_dup (const SubmarineServerInfo* self);
void submarine_server_info_free (SubmarineServerInfo* self);
void submarine_server_info_copy (const SubmarineServerInfo* self, SubmarineServerInfo* dest);
void submarine_server_info_destroy (SubmarineServerInfo* self);
void submarine_subtitle_server_get_info (SubmarineSubtitleServer* self, SubmarineServerInfo* result);
SubmarineSubtitle* submarine_subtitle_new (SubmarineServerInfo* server_info, GValue* server_data);
SubmarineSubtitle* submarine_subtitle_construct (GType object_type, SubmarineServerInfo* server_info, GValue* server_data);
void submarine_subtitle_set_language (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_rating (SubmarineSubtitle* self, gdouble value);
static gboolean submarine_div_xsubs_server_remove_directory (SubmarineDivXsubsServer* self, const gchar* path);
static SubmarineSubtitle* submarine_div_xsubs_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle);
void submarine_subtitle_get_server_data (SubmarineSubtitle* self, GValue* result);
static guint8* _vala_array_dup1 (guint8* self, int length);
void submarine_subtitle_set_data (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_format (SubmarineSubtitle* self, const gchar* value);
SubmarineDivXsubsServer* submarine_div_xsubs_server_new (void);
SubmarineDivXsubsServer* submarine_div_xsubs_server_construct (GType object_type);
SubmarineSubtitleServer* submarine_subtitle_server_construct (GType object_type);
static GObject * submarine_div_xsubs_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void submarine_server_info_init (SubmarineServerInfo *self, const gchar* name, const gchar* address, const gchar* code);
void submarine_subtitle_server_set_info (SubmarineSubtitleServer* self, SubmarineServerInfo* value);
static void submarine_div_xsubs_server_finalize (GObject* obj);


static gboolean submarine_div_xsubs_server_real_connect (SubmarineSubtitleServer* base) {
	SubmarineDivXsubsServer * self;
	gboolean result = FALSE;
	SoupSessionSync* _tmp0_ = NULL;
	self = (SubmarineDivXsubsServer*) base;
	_tmp0_ = (SoupSessionSync*) soup_session_sync_new ();
	_g_object_unref0 (self->priv->session);
	self->priv->session = _tmp0_;
	result = TRUE;
	return result;
}


static void submarine_div_xsubs_server_real_disconnect (SubmarineSubtitleServer* base) {
	SubmarineDivXsubsServer * self;
	self = (SubmarineDivXsubsServer*) base;
}


static gint string_last_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static GeeSet* submarine_div_xsubs_server_real_search (SubmarineSubtitleServer* base, GFile* file, GeeCollection* languages) {
	SubmarineDivXsubsServer * self;
	GeeSet* result = NULL;
	GeeHashSet* subtitles_downloaded = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* tmp = NULL;
	GFile* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gint pos = 0;
	const gchar* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gchar* main_filename = NULL;
	const gchar* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gchar* _tmp9_ = NULL;
	gchar* lang = NULL;
	self = (SubmarineDivXsubsServer*) base;
	g_return_val_if_fail (file != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_downloaded = _tmp0_;
	_tmp1_ = file;
	_tmp2_ = g_file_get_path (_tmp1_);
	_g_free0 (self->priv->filepath);
	self->priv->filepath = _tmp2_;
	_tmp3_ = file;
	_tmp4_ = g_file_get_basename (_tmp3_);
	tmp = _tmp4_;
	_tmp5_ = tmp;
	_tmp6_ = string_last_index_of (_tmp5_, ".", 0);
	pos = _tmp6_;
	_tmp7_ = tmp;
	_tmp8_ = pos;
	_tmp9_ = string_substring (_tmp7_, (glong) 0, (glong) _tmp8_);
	main_filename = _tmp9_;
	{
		GeeIterator* _l_it = NULL;
		GeeCollection* _tmp10_ = NULL;
		GeeIterator* _tmp11_ = NULL;
		_tmp10_ = languages;
		_tmp11_ = gee_iterable_iterator ((GeeIterable*) _tmp10_);
		_l_it = _tmp11_;
		while (TRUE) {
			GeeIterator* _tmp12_ = NULL;
			gboolean _tmp13_ = FALSE;
			gchar* l = NULL;
			GeeIterator* _tmp14_ = NULL;
			gpointer _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gint _tmp17_ = 0;
			gint _tmp18_ = 0;
			SoupMessage* message = NULL;
			const gchar* _tmp23_ = NULL;
			const gchar* _tmp24_ = NULL;
			SoupMessage* _tmp25_ = NULL;
			SoupMessage* _tmp26_ = NULL;
			SoupMessageHeaders* _tmp27_ = NULL;
			SoupMessage* _tmp28_ = NULL;
			SoupMessageHeaders* _tmp29_ = NULL;
			SoupMessage* _tmp30_ = NULL;
			SoupMessageHeaders* _tmp31_ = NULL;
			SoupMessage* _tmp32_ = NULL;
			SoupMessageHeaders* _tmp33_ = NULL;
			guint status_code = 0U;
			SoupSessionSync* _tmp34_ = NULL;
			SoupMessage* _tmp35_ = NULL;
			guint _tmp36_ = 0U;
			guint _tmp37_ = 0U;
			gchar* rv = NULL;
			SoupMessage* _tmp38_ = NULL;
			SoupMessageBody* _tmp39_ = NULL;
			guint8* _tmp40_ = NULL;
			gint _tmp40__length1 = 0;
			gchar* _tmp41_ = NULL;
			gint pos_ini = 0;
			_tmp12_ = _l_it;
			_tmp13_ = gee_iterator_next (_tmp12_);
			if (!_tmp13_) {
				break;
			}
			_tmp14_ = _l_it;
			_tmp15_ = gee_iterator_get (_tmp14_);
			l = (gchar*) _tmp15_;
			_tmp16_ = l;
			_tmp17_ = strlen (_tmp16_);
			_tmp18_ = _tmp17_;
			if (_tmp18_ == 3) {
				const gchar* _tmp19_ = NULL;
				gchar* _tmp20_ = NULL;
				_tmp19_ = l;
				_tmp20_ = g_strdup (_tmp19_);
				_g_free0 (lang);
				lang = _tmp20_;
			} else {
				const gchar* _tmp21_ = NULL;
				gchar* _tmp22_ = NULL;
				_tmp21_ = l;
				_tmp22_ = submarine_get_alternate (_tmp21_);
				_g_free0 (lang);
				lang = _tmp22_;
			}
			_tmp23_ = main_filename;
			_tmp24_ = lang;
			_tmp25_ = soup_form_request_new ("POST", SUBMARINE_DIV_XSUBS_SERVER_MAIN_URI "/results.php", "keyword", _tmp23_, "country", _tmp24_, "x", "106", "y", "11", NULL);
			message = _tmp25_;
			_tmp26_ = message;
			_tmp27_ = _tmp26_->request_headers;
			soup_message_headers_append (_tmp27_, "User-Agent", SUBMARINE_DIV_XSUBS_SERVER_USER_AGENT);
			_tmp28_ = message;
			_tmp29_ = _tmp28_->request_headers;
			soup_message_headers_append (_tmp29_, "Accept-Language", "es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3");
			_tmp30_ = message;
			_tmp31_ = _tmp30_->request_headers;
			soup_message_headers_append (_tmp31_, "Referer", SUBMARINE_DIV_XSUBS_SERVER_MAIN_URI);
			_tmp32_ = message;
			_tmp33_ = _tmp32_->request_headers;
			soup_message_headers_append (_tmp33_, "Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
			_tmp34_ = self->priv->session;
			_tmp35_ = message;
			_tmp36_ = soup_session_send_message ((SoupSession*) _tmp34_, _tmp35_);
			status_code = _tmp36_;
			_tmp37_ = status_code;
			if (_tmp37_ != ((guint) 200)) {
				_g_object_unref0 (message);
				_g_free0 (l);
				continue;
			}
			_tmp38_ = message;
			_tmp39_ = _tmp38_->response_body;
			_tmp40_ = _tmp39_->data;
			_tmp40__length1 = (gint) _tmp39_->length;
			_tmp41_ = g_strdup ((const gchar*) _tmp40_);
			rv = _tmp41_;
			pos_ini = 0;
			while (TRUE) {
				gint pos1 = 0;
				const gchar* _tmp42_ = NULL;
				const gchar* _tmp43_ = NULL;
				gchar* _tmp44_ = NULL;
				gchar* _tmp45_ = NULL;
				gint _tmp46_ = 0;
				gint _tmp47_ = 0;
				gint _tmp48_ = 0;
				gint _tmp49_ = 0;
				gint _tmp50_ = 0;
				gint pos2 = 0;
				const gchar* _tmp51_ = NULL;
				gint _tmp52_ = 0;
				gint _tmp53_ = 0;
				gint _tmp54_ = 0;
				gint pos3 = 0;
				const gchar* _tmp55_ = NULL;
				gint _tmp56_ = 0;
				gint _tmp57_ = 0;
				gint _tmp58_ = 0;
				gchar* uri = NULL;
				const gchar* _tmp59_ = NULL;
				gint _tmp60_ = 0;
				gint _tmp61_ = 0;
				gint _tmp62_ = 0;
				gchar* _tmp63_ = NULL;
				gchar* _tmp64_ = NULL;
				gchar* _tmp65_ = NULL;
				gchar* _tmp66_ = NULL;
				GValue v = {0};
				const gchar* _tmp67_ = NULL;
				GValue _tmp68_ = {0};
				SubmarineSubtitle* subtitle = NULL;
				SubmarineServerInfo _tmp69_ = {0};
				SubmarineServerInfo _tmp70_ = {0};
				GValue _tmp71_ = {0};
				SubmarineSubtitle* _tmp72_ = NULL;
				SubmarineSubtitle* _tmp73_ = NULL;
				const gchar* _tmp74_ = NULL;
				SubmarineSubtitle* _tmp75_ = NULL;
				GeeHashSet* _tmp76_ = NULL;
				SubmarineSubtitle* _tmp77_ = NULL;
				_tmp42_ = rv;
				_tmp43_ = main_filename;
				_tmp44_ = g_strconcat ("<td>", _tmp43_, NULL);
				_tmp45_ = _tmp44_;
				_tmp46_ = pos_ini;
				_tmp47_ = string_index_of (_tmp42_, _tmp45_, _tmp46_);
				_tmp48_ = _tmp47_;
				_g_free0 (_tmp45_);
				pos1 = _tmp48_;
				_tmp49_ = pos1;
				if (_tmp49_ == (-1)) {
					break;
				}
				_tmp50_ = pos1;
				pos_ini = _tmp50_ + 4;
				_tmp51_ = rv;
				_tmp52_ = pos1;
				_tmp53_ = string_index_of (_tmp51_, "<a href=\"", _tmp52_ + 4);
				pos2 = _tmp53_;
				_tmp54_ = pos2;
				if (_tmp54_ == (-1)) {
					continue;
				}
				_tmp55_ = rv;
				_tmp56_ = pos2;
				_tmp57_ = string_index_of (_tmp55_, "\"", _tmp56_ + 9);
				pos3 = _tmp57_;
				_tmp58_ = pos3;
				if (_tmp58_ == (-1)) {
					continue;
				}
				_tmp59_ = rv;
				_tmp60_ = pos2;
				_tmp61_ = pos3;
				_tmp62_ = pos2;
				_tmp63_ = string_substring (_tmp59_, (glong) (_tmp60_ + 9), (glong) ((_tmp61_ - _tmp62_) - 9));
				_tmp64_ = _tmp63_;
				_tmp65_ = g_strconcat (SUBMARINE_DIV_XSUBS_SERVER_MAIN_URI "/", _tmp64_, NULL);
				_tmp66_ = _tmp65_;
				_g_free0 (_tmp64_);
				uri = _tmp66_;
				_tmp67_ = uri;
				g_value_init (&_tmp68_, G_TYPE_STRING);
				g_value_set_string (&_tmp68_, _tmp67_);
				v = _tmp68_;
				submarine_subtitle_server_get_info ((SubmarineSubtitleServer*) self, &_tmp69_);
				_tmp70_ = _tmp69_;
				_tmp71_ = v;
				_tmp72_ = submarine_subtitle_new (&_tmp70_, &_tmp71_);
				subtitle = _tmp72_;
				_tmp73_ = subtitle;
				_tmp74_ = l;
				submarine_subtitle_set_language (_tmp73_, _tmp74_);
				_tmp75_ = subtitle;
				submarine_subtitle_set_rating (_tmp75_, 8.0);
				_tmp76_ = subtitles_downloaded;
				_tmp77_ = subtitle;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp76_, _tmp77_);
				_submarine_subtitle_unref0 (subtitle);
				G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
				_g_free0 (uri);
			}
			_g_free0 (rv);
			_g_object_unref0 (message);
			_g_free0 (l);
		}
		_g_object_unref0 (_l_it);
	}
	result = (GeeSet*) subtitles_downloaded;
	_g_free0 (lang);
	_g_free0 (main_filename);
	_g_free0 (tmp);
	return result;
}


static gboolean submarine_div_xsubs_server_remove_directory (SubmarineDivXsubsServer* self, const gchar* path) {
	gboolean result = FALSE;
	gboolean flag = FALSE;
	GFile* directory = NULL;
	const gchar* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFile* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	GFileEnumerator* enumerator = NULL;
	GFile* _tmp4_ = NULL;
	GFileEnumerator* _tmp5_ = NULL;
	GFileInfo* file_info = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (path != NULL, FALSE);
	flag = FALSE;
	_tmp0_ = path;
	_tmp1_ = g_file_new_for_path (_tmp0_);
	directory = _tmp1_;
	_tmp2_ = directory;
	_tmp3_ = g_file_query_exists (_tmp2_, NULL);
	if (_tmp3_ == FALSE) {
		result = FALSE;
		_g_object_unref0 (directory);
		return result;
	}
	_tmp4_ = directory;
	_tmp5_ = g_file_enumerate_children (_tmp4_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
	enumerator = _tmp5_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (directory);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	while (TRUE) {
		GFileInfo* _tmp6_ = NULL;
		GFileEnumerator* _tmp7_ = NULL;
		GFileInfo* _tmp8_ = NULL;
		GFileInfo* _tmp9_ = NULL;
		GFileInfo* _tmp10_ = NULL;
		gchar* newpath = NULL;
		const gchar* _tmp11_ = NULL;
		GFileInfo* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		GFileInfo* _tmp15_ = NULL;
		GFileType _tmp16_ = 0;
		GFile* newfile = NULL;
		const gchar* _tmp19_ = NULL;
		GFile* _tmp20_ = NULL;
		gboolean _tmp21_ = FALSE;
		GFile* _tmp22_ = NULL;
		gboolean _tmp23_ = FALSE;
		_tmp7_ = enumerator;
		_tmp8_ = g_file_enumerator_next_file (_tmp7_, NULL, &_inner_error_);
		_tmp6_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (file_info);
			_g_object_unref0 (enumerator);
			_g_object_unref0 (directory);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_tmp9_ = _tmp6_;
		_tmp6_ = NULL;
		_g_object_unref0 (file_info);
		file_info = _tmp9_;
		_tmp10_ = file_info;
		if (!(_tmp10_ != NULL)) {
			_g_object_unref0 (_tmp6_);
			break;
		}
		_tmp11_ = path;
		_tmp12_ = file_info;
		_tmp13_ = g_file_info_get_name (_tmp12_);
		_tmp14_ = g_build_filename (_tmp11_, _tmp13_, NULL);
		newpath = _tmp14_;
		_tmp15_ = file_info;
		_tmp16_ = g_file_info_get_file_type (_tmp15_);
		if (_tmp16_ == G_FILE_TYPE_DIRECTORY) {
			const gchar* _tmp17_ = NULL;
			gboolean _tmp18_ = FALSE;
			_tmp17_ = newpath;
			_tmp18_ = submarine_div_xsubs_server_remove_directory (self, _tmp17_);
			if (_tmp18_) {
				flag = TRUE;
			}
		}
		_tmp19_ = newpath;
		_tmp20_ = g_file_new_for_path (_tmp19_);
		newfile = _tmp20_;
		_tmp22_ = newfile;
		_tmp23_ = g_file_delete (_tmp22_, NULL, &_inner_error_);
		_tmp21_ = _tmp23_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (newfile);
			_g_free0 (newpath);
			_g_object_unref0 (_tmp6_);
			_g_object_unref0 (file_info);
			_g_object_unref0 (enumerator);
			_g_object_unref0 (directory);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		if (FALSE == _tmp21_) {
			flag = TRUE;
		}
		_g_object_unref0 (newfile);
		_g_free0 (newpath);
		_g_object_unref0 (_tmp6_);
	}
	result = flag;
	_g_object_unref0 (file_info);
	_g_object_unref0 (enumerator);
	_g_object_unref0 (directory);
	return result;
}


static guint8* _vala_array_dup1 (guint8* self, int length) {
	return g_memdup (self, length * sizeof (guint8));
}


static gpointer _submarine_subtitle_ref0 (gpointer self) {
	return self ? submarine_subtitle_ref (self) : NULL;
}


static SubmarineSubtitle* submarine_div_xsubs_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle) {
	SubmarineDivXsubsServer * self;
	SubmarineSubtitle* result = NULL;
	SoupMessage* message = NULL;
	SubmarineSubtitle* _tmp0_ = NULL;
	GValue _tmp1_ = {0};
	GValue _tmp2_ = {0};
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	SoupMessage* _tmp6_ = NULL;
	SoupMessage* _tmp7_ = NULL;
	SoupMessage* _tmp8_ = NULL;
	SoupMessageHeaders* _tmp9_ = NULL;
	guint status_code = 0U;
	SoupSessionSync* _tmp10_ = NULL;
	SoupMessage* _tmp11_ = NULL;
	guint _tmp12_ = 0U;
	guint _tmp13_ = 0U;
	GError * _inner_error_ = NULL;
	self = (SubmarineDivXsubsServer*) base;
	g_return_val_if_fail (subtitle != NULL, NULL);
	_tmp0_ = subtitle;
	submarine_subtitle_get_server_data (_tmp0_, &_tmp1_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_value_get_string (&_tmp2_);
	_tmp4_ = g_strdup_printf ("%s", _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = soup_message_new ("GET", _tmp5_);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	message = _tmp7_;
	_tmp8_ = message;
	_tmp9_ = _tmp8_->request_headers;
	soup_message_headers_append (_tmp9_, "User-Agent", SUBMARINE_DIV_XSUBS_SERVER_USER_AGENT);
	_tmp10_ = self->priv->session;
	_tmp11_ = message;
	_tmp12_ = soup_session_send_message ((SoupSession*) _tmp10_, _tmp11_);
	status_code = _tmp12_;
	_tmp13_ = status_code;
	if (_tmp13_ == ((guint) 200)) {
		GFile* tmp_path = NULL;
		GFile* _tmp14_ = NULL;
		GFile* output_file = NULL;
		GFile* _tmp16_ = NULL;
		GFile* directory = NULL;
		GFile* _tmp27_ = NULL;
		GFileEnumerator* enumerator = NULL;
		GFile* _tmp28_ = NULL;
		GFileEnumerator* _tmp29_ = NULL;
		GFileInfo* file_info = NULL;
		gchar* ext1 = NULL;
		gchar* _tmp30_ = NULL;
		gchar* ext2 = NULL;
		gchar* _tmp31_ = NULL;
		gboolean found = FALSE;
		gboolean _tmp72_ = FALSE;
		submarine_div_xsubs_server_remove_directory (self, "/tmp/submarine");
		_tmp14_ = g_file_new_for_path ("/tmp/submarine");
		tmp_path = _tmp14_;
		{
			GFile* _tmp15_ = NULL;
			_tmp15_ = tmp_path;
			g_file_make_directory_with_parents (_tmp15_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch3_g_error;
			}
		}
		goto __finally3;
		__catch3_g_error:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_g_error_free0 (e);
		}
		__finally3:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (tmp_path);
			_g_object_unref0 (message);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp16_ = g_file_new_for_path ("/tmp/submarine/data.zip");
		output_file = _tmp16_;
		{
			GFileOutputStream* output_stream = NULL;
			GFile* _tmp17_ = NULL;
			GFileOutputStream* _tmp18_ = NULL;
			guint8* file_data = NULL;
			SoupMessage* _tmp19_ = NULL;
			SoupMessageBody* _tmp20_ = NULL;
			guint8* _tmp21_ = NULL;
			gint _tmp21__length1 = 0;
			guint8* _tmp22_ = NULL;
			gint _tmp22__length1 = 0;
			gint file_data_length1 = 0;
			gint _file_data_size_ = 0;
			GFileOutputStream* _tmp23_ = NULL;
			guint8* _tmp24_ = NULL;
			gint _tmp24__length1 = 0;
			GFileOutputStream* _tmp25_ = NULL;
			_tmp17_ = output_file;
			_tmp18_ = g_file_create (_tmp17_, G_FILE_CREATE_NONE, NULL, &_inner_error_);
			output_stream = _tmp18_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch4_g_error;
			}
			_tmp19_ = message;
			_tmp20_ = _tmp19_->response_body;
			_tmp21_ = _tmp20_->data;
			_tmp21__length1 = (gint) _tmp20_->length;
			_tmp22_ = (_tmp21_ != NULL) ? _vala_array_dup1 (_tmp21_, _tmp21__length1) : ((gpointer) _tmp21_);
			_tmp22__length1 = _tmp21__length1;
			file_data = _tmp22_;
			file_data_length1 = _tmp22__length1;
			_file_data_size_ = file_data_length1;
			_tmp23_ = output_stream;
			_tmp24_ = file_data;
			_tmp24__length1 = file_data_length1;
			g_output_stream_write ((GOutputStream*) _tmp23_, _tmp24_, (gsize) _tmp24__length1, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				file_data = (g_free (file_data), NULL);
				_g_object_unref0 (output_stream);
				goto __catch4_g_error;
			}
			_tmp25_ = output_stream;
			g_output_stream_close ((GOutputStream*) _tmp25_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				file_data = (g_free (file_data), NULL);
				_g_object_unref0 (output_stream);
				goto __catch4_g_error;
			}
			file_data = (g_free (file_data), NULL);
			_g_object_unref0 (output_stream);
		}
		goto __finally4;
		__catch4_g_error:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			submarine_div_xsubs_server_remove_directory (self, "/tmp/submarine");
			result = NULL;
			_g_error_free0 (e);
			_g_object_unref0 (output_file);
			_g_object_unref0 (tmp_path);
			_g_object_unref0 (message);
			return result;
		}
		__finally4:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (output_file);
			_g_object_unref0 (tmp_path);
			_g_object_unref0 (message);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		system ("unzip /tmp/submarine/data.zip -d /tmp/submarine/");
		{
			GFile* _tmp26_ = NULL;
			_tmp26_ = output_file;
			g_file_delete (_tmp26_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch5_g_error;
			}
		}
		goto __finally5;
		__catch5_g_error:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_g_error_free0 (e);
		}
		__finally5:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (output_file);
			_g_object_unref0 (tmp_path);
			_g_object_unref0 (message);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp27_ = g_file_new_for_path ("/tmp/submarine");
		directory = _tmp27_;
		_tmp28_ = directory;
		_tmp29_ = g_file_enumerate_children (_tmp28_, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_SIZE, 0, NULL, &_inner_error_);
		enumerator = _tmp29_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (directory);
			_g_object_unref0 (output_file);
			_g_object_unref0 (tmp_path);
			_g_object_unref0 (message);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp30_ = g_utf8_casefold ("srt", (gssize) (-1));
		ext1 = _tmp30_;
		_tmp31_ = g_utf8_casefold ("sub", (gssize) (-1));
		ext2 = _tmp31_;
		found = FALSE;
		while (TRUE) {
			GFileInfo* _tmp32_ = NULL;
			GFileEnumerator* _tmp33_ = NULL;
			GFileInfo* _tmp34_ = NULL;
			GFileInfo* _tmp35_ = NULL;
			GFileInfo* _tmp36_ = NULL;
			gchar* tmp = NULL;
			GFileInfo* _tmp37_ = NULL;
			const gchar* _tmp38_ = NULL;
			gchar* _tmp39_ = NULL;
			gint pos = 0;
			const gchar* _tmp40_ = NULL;
			gint _tmp41_ = 0;
			gchar* ext = NULL;
			const gchar* _tmp42_ = NULL;
			gint _tmp43_ = 0;
			gchar* _tmp44_ = NULL;
			gchar* _tmp45_ = NULL;
			gchar* _tmp46_ = NULL;
			gchar* _tmp47_ = NULL;
			gboolean _tmp48_ = FALSE;
			const gchar* _tmp49_ = NULL;
			const gchar* _tmp50_ = NULL;
			gchar* newpath = NULL;
			const gchar* _tmp53_ = NULL;
			gchar* _tmp54_ = NULL;
			guint8* buffer = NULL;
			GFileInfo* _tmp55_ = NULL;
			gint64 _tmp56_ = 0LL;
			guint8* _tmp57_ = NULL;
			gint buffer_length1 = 0;
			gint _buffer_size_ = 0;
			SubmarineSubtitle* _tmp66_ = NULL;
			guint8* _tmp67_ = NULL;
			gint _tmp67__length1 = 0;
			const gchar* _tmp68_ = NULL;
			const gchar* _tmp69_ = NULL;
			_tmp33_ = enumerator;
			_tmp34_ = g_file_enumerator_next_file (_tmp33_, NULL, &_inner_error_);
			_tmp32_ = _tmp34_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (ext2);
				_g_free0 (ext1);
				_g_object_unref0 (file_info);
				_g_object_unref0 (enumerator);
				_g_object_unref0 (directory);
				_g_object_unref0 (output_file);
				_g_object_unref0 (tmp_path);
				_g_object_unref0 (message);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_tmp35_ = _tmp32_;
			_tmp32_ = NULL;
			_g_object_unref0 (file_info);
			file_info = _tmp35_;
			_tmp36_ = file_info;
			if (!(_tmp36_ != NULL)) {
				_g_object_unref0 (_tmp32_);
				break;
			}
			_tmp37_ = file_info;
			_tmp38_ = g_file_info_get_name (_tmp37_);
			_tmp39_ = g_strdup (_tmp38_);
			tmp = _tmp39_;
			_tmp40_ = tmp;
			_tmp41_ = string_last_index_of (_tmp40_, ".", 0);
			pos = _tmp41_;
			_tmp42_ = tmp;
			_tmp43_ = pos;
			_tmp44_ = string_substring (_tmp42_, (glong) (_tmp43_ + 1), (glong) (-1));
			_tmp45_ = _tmp44_;
			_tmp46_ = g_utf8_casefold (_tmp45_, (gssize) (-1));
			_tmp47_ = _tmp46_;
			_g_free0 (_tmp45_);
			ext = _tmp47_;
			_tmp49_ = ext;
			_tmp50_ = ext1;
			if (g_strcmp0 (_tmp49_, _tmp50_) != 0) {
				const gchar* _tmp51_ = NULL;
				const gchar* _tmp52_ = NULL;
				_tmp51_ = ext;
				_tmp52_ = ext2;
				_tmp48_ = g_strcmp0 (_tmp51_, _tmp52_) != 0;
			} else {
				_tmp48_ = FALSE;
			}
			if (_tmp48_) {
				_g_free0 (ext);
				_g_free0 (tmp);
				_g_object_unref0 (_tmp32_);
				continue;
			}
			_tmp53_ = tmp;
			_tmp54_ = g_build_filename ("/tmp/submarine", _tmp53_, NULL);
			newpath = _tmp54_;
			_tmp55_ = file_info;
			_tmp56_ = g_file_info_get_size (_tmp55_);
			_tmp57_ = g_new0 (guint8, _tmp56_);
			buffer = _tmp57_;
			buffer_length1 = _tmp56_;
			_buffer_size_ = buffer_length1;
			{
				GFileInputStream* input_stream = NULL;
				const gchar* _tmp58_ = NULL;
				GFile* _tmp59_ = NULL;
				GFile* _tmp60_ = NULL;
				GFileInputStream* _tmp61_ = NULL;
				GFileInputStream* _tmp62_ = NULL;
				GFileInputStream* _tmp63_ = NULL;
				guint8* _tmp64_ = NULL;
				gint _tmp64__length1 = 0;
				GFileInputStream* _tmp65_ = NULL;
				_tmp58_ = newpath;
				_tmp59_ = g_file_new_for_path (_tmp58_);
				_tmp60_ = _tmp59_;
				_tmp61_ = g_file_read (_tmp60_, NULL, &_inner_error_);
				_tmp62_ = _tmp61_;
				_g_object_unref0 (_tmp60_);
				input_stream = _tmp62_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch6_g_error;
				}
				_tmp63_ = input_stream;
				_tmp64_ = buffer;
				_tmp64__length1 = buffer_length1;
				g_input_stream_read ((GInputStream*) _tmp63_, _tmp64_, (gsize) _tmp64__length1, NULL, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (input_stream);
					goto __catch6_g_error;
				}
				_tmp65_ = input_stream;
				g_input_stream_close ((GInputStream*) _tmp65_, NULL, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (input_stream);
					goto __catch6_g_error;
				}
				_g_object_unref0 (input_stream);
			}
			goto __finally6;
			__catch6_g_error:
			{
				GError* e = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				submarine_div_xsubs_server_remove_directory (self, "/tmp/submarine");
				result = NULL;
				_g_error_free0 (e);
				buffer = (g_free (buffer), NULL);
				_g_free0 (newpath);
				_g_free0 (ext);
				_g_free0 (tmp);
				_g_object_unref0 (_tmp32_);
				_g_free0 (ext2);
				_g_free0 (ext1);
				_g_object_unref0 (file_info);
				_g_object_unref0 (enumerator);
				_g_object_unref0 (directory);
				_g_object_unref0 (output_file);
				_g_object_unref0 (tmp_path);
				_g_object_unref0 (message);
				return result;
			}
			__finally6:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				buffer = (g_free (buffer), NULL);
				_g_free0 (newpath);
				_g_free0 (ext);
				_g_free0 (tmp);
				_g_object_unref0 (_tmp32_);
				_g_free0 (ext2);
				_g_free0 (ext1);
				_g_object_unref0 (file_info);
				_g_object_unref0 (enumerator);
				_g_object_unref0 (directory);
				_g_object_unref0 (output_file);
				_g_object_unref0 (tmp_path);
				_g_object_unref0 (message);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_tmp66_ = subtitle;
			_tmp67_ = buffer;
			_tmp67__length1 = buffer_length1;
			submarine_subtitle_set_data (_tmp66_, (const gchar*) _tmp67_);
			_tmp68_ = ext;
			_tmp69_ = ext1;
			if (g_strcmp0 (_tmp68_, _tmp69_) == 0) {
				SubmarineSubtitle* _tmp70_ = NULL;
				_tmp70_ = subtitle;
				submarine_subtitle_set_format (_tmp70_, "srt");
			} else {
				SubmarineSubtitle* _tmp71_ = NULL;
				_tmp71_ = subtitle;
				submarine_subtitle_set_format (_tmp71_, "sub");
			}
			found = TRUE;
			buffer = (g_free (buffer), NULL);
			_g_free0 (newpath);
			_g_free0 (ext);
			_g_free0 (tmp);
			_g_object_unref0 (_tmp32_);
			break;
		}
		submarine_div_xsubs_server_remove_directory (self, "/tmp/submarine");
		_tmp72_ = found;
		if (_tmp72_) {
			SubmarineSubtitle* _tmp73_ = NULL;
			SubmarineSubtitle* _tmp74_ = NULL;
			_tmp73_ = subtitle;
			_tmp74_ = _submarine_subtitle_ref0 (_tmp73_);
			result = _tmp74_;
			_g_free0 (ext2);
			_g_free0 (ext1);
			_g_object_unref0 (file_info);
			_g_object_unref0 (enumerator);
			_g_object_unref0 (directory);
			_g_object_unref0 (output_file);
			_g_object_unref0 (tmp_path);
			_g_object_unref0 (message);
			return result;
		} else {
			result = NULL;
			_g_free0 (ext2);
			_g_free0 (ext1);
			_g_object_unref0 (file_info);
			_g_object_unref0 (enumerator);
			_g_object_unref0 (directory);
			_g_object_unref0 (output_file);
			_g_object_unref0 (tmp_path);
			_g_object_unref0 (message);
			return result;
		}
		_g_free0 (ext2);
		_g_free0 (ext1);
		_g_object_unref0 (file_info);
		_g_object_unref0 (enumerator);
		_g_object_unref0 (directory);
		_g_object_unref0 (output_file);
		_g_object_unref0 (tmp_path);
	}
	submarine_div_xsubs_server_remove_directory (self, "/tmp/submarine");
	result = NULL;
	_g_object_unref0 (message);
	return result;
}


SubmarineDivXsubsServer* submarine_div_xsubs_server_construct (GType object_type) {
	SubmarineDivXsubsServer * self = NULL;
	self = (SubmarineDivXsubsServer*) submarine_subtitle_server_construct (object_type);
	return self;
}


SubmarineDivXsubsServer* submarine_div_xsubs_server_new (void) {
	return submarine_div_xsubs_server_construct (SUBMARINE_TYPE_DIV_XSUBS_SERVER);
}


static GObject * submarine_div_xsubs_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SubmarineDivXsubsServer * self;
	SubmarineServerInfo _tmp0_ = {0};
	SubmarineServerInfo _tmp1_ = {0};
	gchar* _tmp2_ = NULL;
	parent_class = G_OBJECT_CLASS (submarine_div_xsubs_server_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_DIV_XSUBS_SERVER, SubmarineDivXsubsServer);
	submarine_server_info_init (&_tmp0_, "DivXsubs", "http://www.divxsubs.com", "dx");
	_tmp1_ = _tmp0_;
	submarine_subtitle_server_set_info ((SubmarineSubtitleServer*) self, &_tmp1_);
	submarine_server_info_destroy (&_tmp1_);
	_tmp2_ = g_strdup ("");
	_g_free0 (self->priv->filepath);
	self->priv->filepath = _tmp2_;
	return obj;
}


static void submarine_div_xsubs_server_class_init (SubmarineDivXsubsServerClass * klass) {
	submarine_div_xsubs_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SubmarineDivXsubsServerPrivate));
	((SubmarineSubtitleServerClass *) klass)->connect = submarine_div_xsubs_server_real_connect;
	((SubmarineSubtitleServerClass *) klass)->disconnect = submarine_div_xsubs_server_real_disconnect;
	((SubmarineSubtitleServerClass *) klass)->search = submarine_div_xsubs_server_real_search;
	((SubmarineSubtitleServerClass *) klass)->download = submarine_div_xsubs_server_real_download;
	G_OBJECT_CLASS (klass)->constructor = submarine_div_xsubs_server_constructor;
	G_OBJECT_CLASS (klass)->finalize = submarine_div_xsubs_server_finalize;
}


static void submarine_div_xsubs_server_instance_init (SubmarineDivXsubsServer * self) {
	self->priv = SUBMARINE_DIV_XSUBS_SERVER_GET_PRIVATE (self);
}


static void submarine_div_xsubs_server_finalize (GObject* obj) {
	SubmarineDivXsubsServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_DIV_XSUBS_SERVER, SubmarineDivXsubsServer);
	_g_object_unref0 (self->priv->session);
	_g_free0 (self->priv->filepath);
	G_OBJECT_CLASS (submarine_div_xsubs_server_parent_class)->finalize (obj);
}


GType submarine_div_xsubs_server_get_type (void) {
	static volatile gsize submarine_div_xsubs_server_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_div_xsubs_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineDivXsubsServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_div_xsubs_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineDivXsubsServer), 0, (GInstanceInitFunc) submarine_div_xsubs_server_instance_init, NULL };
		GType submarine_div_xsubs_server_type_id;
		submarine_div_xsubs_server_type_id = g_type_register_static (SUBMARINE_TYPE_SUBTITLE_SERVER, "SubmarineDivXsubsServer", &g_define_type_info, 0);
		g_once_init_leave (&submarine_div_xsubs_server_type_id__volatile, submarine_div_xsubs_server_type_id);
	}
	return submarine_div_xsubs_server_type_id__volatile;
}



