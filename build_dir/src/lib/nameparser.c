/* nameparser.c generated by valac 0.28.0, the Vala compiler
 * generated from nameparser.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define SUBMARINE_TYPE_DATA_TYPE (submarine_data_type_get_type ())

#define SUBMARINE_TYPE_RESOLUTION (submarine_resolution_get_type ())

#define SUBMARINE_TYPE_CODEC (submarine_codec_get_type ())

#define SUBMARINE_TYPE_SOURCE (submarine_source_get_type ())

#define SUBMARINE_TYPE_NAME_PARSER_NODE (submarine_name_parser_node_get_type ())
#define SUBMARINE_NAME_PARSER_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_NAME_PARSER_NODE, SubmarineNameParserNode))
#define SUBMARINE_NAME_PARSER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_NAME_PARSER_NODE, SubmarineNameParserNodeClass))
#define SUBMARINE_IS_NAME_PARSER_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_NAME_PARSER_NODE))
#define SUBMARINE_IS_NAME_PARSER_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_NAME_PARSER_NODE))
#define SUBMARINE_NAME_PARSER_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_NAME_PARSER_NODE, SubmarineNameParserNodeClass))

typedef struct _SubmarineNameParserNode SubmarineNameParserNode;
typedef struct _SubmarineNameParserNodeClass SubmarineNameParserNodeClass;
typedef struct _SubmarineNameParserNodePrivate SubmarineNameParserNodePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _submarine_name_parser_node_unref0(var) ((var == NULL) ? NULL : (var = (submarine_name_parser_node_unref (var), NULL)))
#define _g_match_info_free0(var) ((var == NULL) ? NULL : (var = (g_match_info_free (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
typedef struct _SubmarineParamSpecNameParserNode SubmarineParamSpecNameParserNode;

#define SUBMARINE_TYPE_NAME_PARSER (submarine_name_parser_get_type ())
#define SUBMARINE_NAME_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParser))
#define SUBMARINE_NAME_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParserClass))
#define SUBMARINE_IS_NAME_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_NAME_PARSER))
#define SUBMARINE_IS_NAME_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_NAME_PARSER))
#define SUBMARINE_NAME_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParserClass))

typedef struct _SubmarineNameParser SubmarineNameParser;
typedef struct _SubmarineNameParserClass SubmarineNameParserClass;
typedef struct _SubmarineNameParserPrivate SubmarineNameParserPrivate;
typedef struct _SubmarineParamSpecNameParser SubmarineParamSpecNameParser;

typedef enum  {
	SUBMARINE_DATA_TYPE_UNKNOWN,
	SUBMARINE_DATA_TYPE_FREETEXT,
	SUBMARINE_DATA_TYPE_YEAR,
	SUBMARINE_DATA_TYPE_SEASON_CHAPTER,
	SUBMARINE_DATA_TYPE_CODEC,
	SUBMARINE_DATA_TYPE_RESOLUTION,
	SUBMARINE_DATA_TYPE_SOURCE
} SubmarineDataType;

typedef enum  {
	SUBMARINE_RESOLUTION_PAL_NTSC,
	SUBMARINE_RESOLUTION_HDREADY,
	SUBMARINE_RESOLUTION_FULLHD,
	SUBMARINE_RESOLUTION_UNKNOWN
} SubmarineResolution;

typedef enum  {
	SUBMARINE_CODEC_X264,
	SUBMARINE_CODEC_DIVX,
	SUBMARINE_CODEC_XVID,
	SUBMARINE_CODEC_MPEG,
	SUBMARINE_CODEC_UNKNOWN
} SubmarineCodec;

typedef enum  {
	SUBMARINE_SOURCE_DVDRIP,
	SUBMARINE_SOURCE_BDRIP,
	SUBMARINE_SOURCE_HDTV,
	SUBMARINE_SOURCE_UNKNOWN
} SubmarineSource;

struct _SubmarineNameParserNode {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SubmarineNameParserNodePrivate * priv;
	SubmarineNameParserNode* next;
	SubmarineNameParserNode* prev;
	SubmarineNameParserNode* child;
	SubmarineNameParserNode* iterator;
	SubmarineDataType type;
	SubmarineResolution resolution;
	SubmarineCodec codec;
	SubmarineSource source;
	gdouble confidence;
	gint year;
	gint season;
	gint chapter;
	gint level;
};

struct _SubmarineNameParserNodeClass {
	GTypeClass parent_class;
	void (*finalize) (SubmarineNameParserNode *self);
};

struct _SubmarineNameParserNodePrivate {
	gchar* text;
};

struct _SubmarineParamSpecNameParserNode {
	GParamSpec parent_instance;
};

struct _SubmarineNameParser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SubmarineNameParserPrivate * priv;
	gchar* title;
	gint year;
	gint season;
	gint chapter;
	SubmarineResolution resolution;
	SubmarineCodec codec;
	SubmarineSource source;
};

struct _SubmarineNameParserClass {
	GTypeClass parent_class;
	void (*finalize) (SubmarineNameParser *self);
};

struct _SubmarineNameParserPrivate {
	SubmarineNameParserNode* node;
	SubmarineNameParserNode* iterator;
};

struct _SubmarineParamSpecNameParser {
	GParamSpec parent_instance;
};


static gpointer submarine_name_parser_node_parent_class = NULL;
static gpointer submarine_name_parser_parent_class = NULL;

GType submarine_data_type_get_type (void) G_GNUC_CONST;
GType submarine_resolution_get_type (void) G_GNUC_CONST;
GType submarine_codec_get_type (void) G_GNUC_CONST;
GType submarine_source_get_type (void) G_GNUC_CONST;
gpointer submarine_name_parser_node_ref (gpointer instance);
void submarine_name_parser_node_unref (gpointer instance);
GParamSpec* submarine_param_spec_name_parser_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_name_parser_node (GValue* value, gpointer v_object);
void submarine_value_take_name_parser_node (GValue* value, gpointer v_object);
gpointer submarine_value_get_name_parser_node (const GValue* value);
GType submarine_name_parser_node_get_type (void) G_GNUC_CONST;
#define SUBMARINE_NAME_PARSER_NODE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_NAME_PARSER_NODE, SubmarineNameParserNodePrivate))
enum  {
	SUBMARINE_NAME_PARSER_NODE_DUMMY_PROPERTY
};
gchar* submarine_name_parser_node_get_inner_text (SubmarineNameParserNode* self);
static gchar* submarine_name_parser_node_return_type (SubmarineNameParserNode* self);
SubmarineNameParserNode* submarine_name_parser_node_new_empty (void);
SubmarineNameParserNode* submarine_name_parser_node_construct_empty (GType object_type);
static void submarine_name_parser_node_init_all (SubmarineNameParserNode* self);
SubmarineNameParserNode* submarine_name_parser_node_new_new_copy (SubmarineNameParserNode* p);
SubmarineNameParserNode* submarine_name_parser_node_construct_new_copy (GType object_type, SubmarineNameParserNode* p);
SubmarineNameParserNode* submarine_name_parser_node_new (const gchar* txt, SubmarineNameParserNode* thenext, gint c_level);
SubmarineNameParserNode* submarine_name_parser_node_construct (GType object_type, const gchar* txt, SubmarineNameParserNode* thenext, gint c_level);
static void submarine_name_parser_node_split (SubmarineNameParserNode* self, gunichar character, gunichar* c1, gunichar* c2);
static gboolean submarine_name_parser_node_check_pattern (SubmarineNameParserNode* self, const gchar* pattern, gint length, SubmarineDataType type);
void submarine_name_parser_node_print_content (SubmarineNameParserNode* self);
void submarine_name_parser_node_reset_iterator (SubmarineNameParserNode* self);
SubmarineNameParserNode* submarine_name_parser_node_get_next_iterator (SubmarineNameParserNode* self);
static void submarine_name_parser_node_finalize (SubmarineNameParserNode* obj);
gpointer submarine_name_parser_ref (gpointer instance);
void submarine_name_parser_unref (gpointer instance);
GParamSpec* submarine_param_spec_name_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_name_parser (GValue* value, gpointer v_object);
void submarine_value_take_name_parser (GValue* value, gpointer v_object);
gpointer submarine_value_get_name_parser (const GValue* value);
GType submarine_name_parser_get_type (void) G_GNUC_CONST;
#define SUBMARINE_NAME_PARSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParserPrivate))
enum  {
	SUBMARINE_NAME_PARSER_DUMMY_PROPERTY
};
static void submarine_name_parser_reset_iterator (SubmarineNameParser* self);
static SubmarineNameParserNode* submarine_name_parser_get_next_iterator (SubmarineNameParser* self);
SubmarineNameParser* submarine_name_parser_new (GFile* file);
SubmarineNameParser* submarine_name_parser_construct (GType object_type, GFile* file);
static void submarine_name_parser_finalize (SubmarineNameParser* obj);


GType submarine_data_type_get_type (void) {
	static volatile gsize submarine_data_type_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_data_type_type_id__volatile)) {
		static const GEnumValue values[] = {{SUBMARINE_DATA_TYPE_UNKNOWN, "SUBMARINE_DATA_TYPE_UNKNOWN", "unknown"}, {SUBMARINE_DATA_TYPE_FREETEXT, "SUBMARINE_DATA_TYPE_FREETEXT", "freetext"}, {SUBMARINE_DATA_TYPE_YEAR, "SUBMARINE_DATA_TYPE_YEAR", "year"}, {SUBMARINE_DATA_TYPE_SEASON_CHAPTER, "SUBMARINE_DATA_TYPE_SEASON_CHAPTER", "season-chapter"}, {SUBMARINE_DATA_TYPE_CODEC, "SUBMARINE_DATA_TYPE_CODEC", "codec"}, {SUBMARINE_DATA_TYPE_RESOLUTION, "SUBMARINE_DATA_TYPE_RESOLUTION", "resolution"}, {SUBMARINE_DATA_TYPE_SOURCE, "SUBMARINE_DATA_TYPE_SOURCE", "source"}, {0, NULL, NULL}};
		GType submarine_data_type_type_id;
		submarine_data_type_type_id = g_enum_register_static ("SubmarineDataType", values);
		g_once_init_leave (&submarine_data_type_type_id__volatile, submarine_data_type_type_id);
	}
	return submarine_data_type_type_id__volatile;
}


GType submarine_resolution_get_type (void) {
	static volatile gsize submarine_resolution_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_resolution_type_id__volatile)) {
		static const GEnumValue values[] = {{SUBMARINE_RESOLUTION_PAL_NTSC, "SUBMARINE_RESOLUTION_PAL_NTSC", "pal-ntsc"}, {SUBMARINE_RESOLUTION_HDREADY, "SUBMARINE_RESOLUTION_HDREADY", "hdready"}, {SUBMARINE_RESOLUTION_FULLHD, "SUBMARINE_RESOLUTION_FULLHD", "fullhd"}, {SUBMARINE_RESOLUTION_UNKNOWN, "SUBMARINE_RESOLUTION_UNKNOWN", "unknown"}, {0, NULL, NULL}};
		GType submarine_resolution_type_id;
		submarine_resolution_type_id = g_enum_register_static ("SubmarineResolution", values);
		g_once_init_leave (&submarine_resolution_type_id__volatile, submarine_resolution_type_id);
	}
	return submarine_resolution_type_id__volatile;
}


GType submarine_codec_get_type (void) {
	static volatile gsize submarine_codec_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_codec_type_id__volatile)) {
		static const GEnumValue values[] = {{SUBMARINE_CODEC_X264, "SUBMARINE_CODEC_X264", "x264"}, {SUBMARINE_CODEC_DIVX, "SUBMARINE_CODEC_DIVX", "divx"}, {SUBMARINE_CODEC_XVID, "SUBMARINE_CODEC_XVID", "xvid"}, {SUBMARINE_CODEC_MPEG, "SUBMARINE_CODEC_MPEG", "mpeg"}, {SUBMARINE_CODEC_UNKNOWN, "SUBMARINE_CODEC_UNKNOWN", "unknown"}, {0, NULL, NULL}};
		GType submarine_codec_type_id;
		submarine_codec_type_id = g_enum_register_static ("SubmarineCodec", values);
		g_once_init_leave (&submarine_codec_type_id__volatile, submarine_codec_type_id);
	}
	return submarine_codec_type_id__volatile;
}


GType submarine_source_get_type (void) {
	static volatile gsize submarine_source_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_source_type_id__volatile)) {
		static const GEnumValue values[] = {{SUBMARINE_SOURCE_DVDRIP, "SUBMARINE_SOURCE_DVDRIP", "dvdrip"}, {SUBMARINE_SOURCE_BDRIP, "SUBMARINE_SOURCE_BDRIP", "bdrip"}, {SUBMARINE_SOURCE_HDTV, "SUBMARINE_SOURCE_HDTV", "hdtv"}, {SUBMARINE_SOURCE_UNKNOWN, "SUBMARINE_SOURCE_UNKNOWN", "unknown"}, {0, NULL, NULL}};
		GType submarine_source_type_id;
		submarine_source_type_id = g_enum_register_static ("SubmarineSource", values);
		g_once_init_leave (&submarine_source_type_id__volatile, submarine_source_type_id);
	}
	return submarine_source_type_id__volatile;
}


gchar* submarine_name_parser_node_get_inner_text (SubmarineNameParserNode* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->text;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


static gchar* submarine_name_parser_node_return_type (SubmarineNameParserNode* self) {
	gchar* result = NULL;
	SubmarineDataType _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->type;
	switch (_tmp0_) {
		case SUBMARINE_DATA_TYPE_FREETEXT:
		{
			gchar* _tmp1_ = NULL;
			_tmp1_ = g_strdup ("Text");
			result = _tmp1_;
			return result;
		}
		case SUBMARINE_DATA_TYPE_YEAR:
		{
			gchar* _tmp2_ = NULL;
			_tmp2_ = g_strdup ("Year");
			result = _tmp2_;
			return result;
		}
		case SUBMARINE_DATA_TYPE_SEASON_CHAPTER:
		{
			gchar* _tmp3_ = NULL;
			_tmp3_ = g_strdup ("Season_Chapter");
			result = _tmp3_;
			return result;
		}
		case SUBMARINE_DATA_TYPE_CODEC:
		{
			gchar* _tmp4_ = NULL;
			_tmp4_ = g_strdup ("Codec");
			result = _tmp4_;
			return result;
		}
		case SUBMARINE_DATA_TYPE_RESOLUTION:
		{
			gchar* _tmp5_ = NULL;
			_tmp5_ = g_strdup ("Resolution");
			result = _tmp5_;
			return result;
		}
		case SUBMARINE_DATA_TYPE_SOURCE:
		{
			gchar* _tmp6_ = NULL;
			_tmp6_ = g_strdup ("Source");
			result = _tmp6_;
			return result;
		}
		default:
		{
			gchar* _tmp7_ = NULL;
			_tmp7_ = g_strdup ("Unknown");
			result = _tmp7_;
			return result;
		}
	}
}


SubmarineNameParserNode* submarine_name_parser_node_construct_empty (GType object_type) {
	SubmarineNameParserNode* self = NULL;
	gchar* _tmp0_ = NULL;
	self = (SubmarineNameParserNode*) g_type_create_instance (object_type);
	self->type = SUBMARINE_DATA_TYPE_UNKNOWN;
	_tmp0_ = g_strdup ("");
	_g_free0 (self->priv->text);
	self->priv->text = _tmp0_;
	_submarine_name_parser_node_unref0 (self->child);
	self->child = NULL;
	_submarine_name_parser_node_unref0 (self->next);
	self->next = NULL;
	self->prev = NULL;
	return self;
}


SubmarineNameParserNode* submarine_name_parser_node_new_empty (void) {
	return submarine_name_parser_node_construct_empty (SUBMARINE_TYPE_NAME_PARSER_NODE);
}


static void submarine_name_parser_node_init_all (SubmarineNameParserNode* self) {
	g_return_if_fail (self != NULL);
	self->type = SUBMARINE_DATA_TYPE_UNKNOWN;
	self->resolution = SUBMARINE_RESOLUTION_UNKNOWN;
	self->codec = SUBMARINE_CODEC_UNKNOWN;
	self->source = SUBMARINE_SOURCE_UNKNOWN;
	self->confidence = 0.0;
	self->year = -1;
	self->season = -1;
	self->chapter = -1;
}


SubmarineNameParserNode* submarine_name_parser_node_construct_new_copy (GType object_type, SubmarineNameParserNode* p) {
	SubmarineNameParserNode* self = NULL;
	SubmarineNameParserNode* _tmp0_ = NULL;
	self = (SubmarineNameParserNode*) g_type_create_instance (object_type);
	submarine_name_parser_node_init_all (self);
	_tmp0_ = p;
	if (_tmp0_ != NULL) {
		SubmarineNameParserNode* _tmp1_ = NULL;
		SubmarineDataType _tmp2_ = 0;
		SubmarineNameParserNode* _tmp3_ = NULL;
		gdouble _tmp4_ = 0.0;
		SubmarineNameParserNode* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		SubmarineDataType _tmp8_ = 0;
		_tmp1_ = p;
		_tmp2_ = _tmp1_->type;
		self->type = _tmp2_;
		_tmp3_ = p;
		_tmp4_ = _tmp3_->confidence;
		self->confidence = _tmp4_;
		_tmp5_ = p;
		_tmp6_ = _tmp5_->priv->text;
		_tmp7_ = g_strdup (_tmp6_);
		_g_free0 (self->priv->text);
		self->priv->text = _tmp7_;
		_submarine_name_parser_node_unref0 (self->child);
		self->child = NULL;
		_submarine_name_parser_node_unref0 (self->next);
		self->next = NULL;
		self->prev = NULL;
		_tmp8_ = self->type;
		switch (_tmp8_) {
			case SUBMARINE_DATA_TYPE_YEAR:
			{
				SubmarineNameParserNode* _tmp9_ = NULL;
				gint _tmp10_ = 0;
				_tmp9_ = p;
				_tmp10_ = _tmp9_->year;
				self->year = _tmp10_;
				break;
			}
			case SUBMARINE_DATA_TYPE_SEASON_CHAPTER:
			{
				SubmarineNameParserNode* _tmp11_ = NULL;
				gint _tmp12_ = 0;
				SubmarineNameParserNode* _tmp13_ = NULL;
				gint _tmp14_ = 0;
				_tmp11_ = p;
				_tmp12_ = _tmp11_->season;
				self->season = _tmp12_;
				_tmp13_ = p;
				_tmp14_ = _tmp13_->chapter;
				self->chapter = _tmp14_;
				break;
			}
			case SUBMARINE_DATA_TYPE_CODEC:
			{
				SubmarineNameParserNode* _tmp15_ = NULL;
				SubmarineCodec _tmp16_ = 0;
				_tmp15_ = p;
				_tmp16_ = _tmp15_->codec;
				self->codec = _tmp16_;
				break;
			}
			case SUBMARINE_DATA_TYPE_RESOLUTION:
			{
				SubmarineNameParserNode* _tmp17_ = NULL;
				SubmarineResolution _tmp18_ = 0;
				_tmp17_ = p;
				_tmp18_ = _tmp17_->resolution;
				self->resolution = _tmp18_;
				break;
			}
			case SUBMARINE_DATA_TYPE_SOURCE:
			{
				SubmarineNameParserNode* _tmp19_ = NULL;
				SubmarineSource _tmp20_ = 0;
				_tmp19_ = p;
				_tmp20_ = _tmp19_->source;
				self->source = _tmp20_;
				break;
			}
			default:
			{
				break;
			}
		}
	} else {
		FILE* _tmp21_ = NULL;
		_tmp21_ = stdout;
		fprintf (_tmp21_, "Copiando NULL\n");
	}
	return self;
}


SubmarineNameParserNode* submarine_name_parser_node_new_new_copy (SubmarineNameParserNode* p) {
	return submarine_name_parser_node_construct_new_copy (SUBMARINE_TYPE_NAME_PARSER_NODE, p);
}


static gpointer _submarine_name_parser_node_ref0 (gpointer self) {
	return self ? submarine_name_parser_node_ref (self) : NULL;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


SubmarineNameParserNode* submarine_name_parser_node_construct (GType object_type, const gchar* txt, SubmarineNameParserNode* thenext, gint c_level) {
	SubmarineNameParserNode* self = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	SubmarineNameParserNode* _tmp3_ = NULL;
	SubmarineNameParserNode* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp34_ = FALSE;
	gboolean _tmp44_ = FALSE;
	gboolean _tmp45_ = FALSE;
	gboolean _tmp48_ = FALSE;
	gboolean _tmp53_ = FALSE;
	g_return_val_if_fail (txt != NULL, NULL);
	self = (SubmarineNameParserNode*) g_type_create_instance (object_type);
	submarine_name_parser_node_init_all (self);
	_tmp0_ = c_level;
	self->level = _tmp0_;
	self->type = SUBMARINE_DATA_TYPE_UNKNOWN;
	_tmp1_ = txt;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (self->priv->text);
	self->priv->text = _tmp2_;
	_tmp3_ = thenext;
	_tmp4_ = _submarine_name_parser_node_ref0 (_tmp3_);
	_submarine_name_parser_node_unref0 (self->next);
	self->next = _tmp4_;
	self->prev = NULL;
	self->prev = NULL;
	_submarine_name_parser_node_unref0 (self->child);
	self->child = NULL;
	submarine_name_parser_node_split (self, (gunichar) ' ', NULL, NULL);
	submarine_name_parser_node_split (self, (gunichar) '-', NULL, NULL);
	submarine_name_parser_node_split (self, (gunichar) '_', NULL, NULL);
	submarine_name_parser_node_split (self, (gunichar) '.', NULL, NULL);
	submarine_name_parser_node_split (self, (gunichar) '[', NULL, NULL);
	submarine_name_parser_node_split (self, (gunichar) ']', NULL, NULL);
	submarine_name_parser_node_split (self, (gunichar) '{', NULL, NULL);
	submarine_name_parser_node_split (self, (gunichar) '}', NULL, NULL);
	_tmp5_ = submarine_name_parser_node_check_pattern (self, "s\\d\\de\\d\\d", 6, SUBMARINE_DATA_TYPE_SEASON_CHAPTER);
	if (_tmp5_) {
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		const gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		gint _tmp13_ = 0;
		_tmp6_ = self->priv->text;
		_tmp7_ = string_substring (_tmp6_, (glong) 1, (glong) 2);
		_tmp8_ = _tmp7_;
		_tmp9_ = atoi (_tmp8_);
		self->season = _tmp9_;
		_g_free0 (_tmp8_);
		_tmp10_ = self->priv->text;
		_tmp11_ = string_substring (_tmp10_, (glong) 4, (glong) 2);
		_tmp12_ = _tmp11_;
		_tmp13_ = atoi (_tmp12_);
		self->chapter = _tmp13_;
		_g_free0 (_tmp12_);
	} else {
		gboolean _tmp14_ = FALSE;
		_tmp14_ = submarine_name_parser_node_check_pattern (self, "\\d\\dx\\d\\d", 5, SUBMARINE_DATA_TYPE_SEASON_CHAPTER);
		if (_tmp14_) {
			const gchar* _tmp15_ = NULL;
			gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			gint _tmp18_ = 0;
			const gchar* _tmp19_ = NULL;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_ = NULL;
			gint _tmp22_ = 0;
			gdouble _tmp23_ = 0.0;
			_tmp15_ = self->priv->text;
			_tmp16_ = string_substring (_tmp15_, (glong) 0, (glong) 2);
			_tmp17_ = _tmp16_;
			_tmp18_ = atoi (_tmp17_);
			self->season = _tmp18_;
			_g_free0 (_tmp17_);
			_tmp19_ = self->priv->text;
			_tmp20_ = string_substring (_tmp19_, (glong) 3, (glong) 2);
			_tmp21_ = _tmp20_;
			_tmp22_ = atoi (_tmp21_);
			self->chapter = _tmp22_;
			_g_free0 (_tmp21_);
			_tmp23_ = self->confidence;
			self->confidence = _tmp23_ * 0.9;
		} else {
			gboolean _tmp24_ = FALSE;
			_tmp24_ = submarine_name_parser_node_check_pattern (self, "\\dx\\d\\d", 4, SUBMARINE_DATA_TYPE_SEASON_CHAPTER);
			if (_tmp24_) {
				const gchar* _tmp25_ = NULL;
				gchar* _tmp26_ = NULL;
				gchar* _tmp27_ = NULL;
				gint _tmp28_ = 0;
				const gchar* _tmp29_ = NULL;
				gchar* _tmp30_ = NULL;
				gchar* _tmp31_ = NULL;
				gint _tmp32_ = 0;
				gdouble _tmp33_ = 0.0;
				_tmp25_ = self->priv->text;
				_tmp26_ = string_substring (_tmp25_, (glong) 0, (glong) 1);
				_tmp27_ = _tmp26_;
				_tmp28_ = atoi (_tmp27_);
				self->season = _tmp28_;
				_g_free0 (_tmp27_);
				_tmp29_ = self->priv->text;
				_tmp30_ = string_substring (_tmp29_, (glong) 2, (glong) 2);
				_tmp31_ = _tmp30_;
				_tmp32_ = atoi (_tmp31_);
				self->chapter = _tmp32_;
				_g_free0 (_tmp31_);
				_tmp33_ = self->confidence;
				self->confidence = _tmp33_ * 0.9;
			}
		}
	}
	_tmp34_ = submarine_name_parser_node_check_pattern (self, "\\(\\d\\d\\d\\d\\)", 6, SUBMARINE_DATA_TYPE_YEAR);
	if (_tmp34_) {
		const gchar* _tmp35_ = NULL;
		gchar* _tmp36_ = NULL;
		gchar* _tmp37_ = NULL;
		gint _tmp38_ = 0;
		_tmp35_ = self->priv->text;
		_tmp36_ = string_substring (_tmp35_, (glong) 1, (glong) 4);
		_tmp37_ = _tmp36_;
		_tmp38_ = atoi (_tmp37_);
		self->year = _tmp38_;
		_g_free0 (_tmp37_);
	} else {
		gboolean _tmp39_ = FALSE;
		_tmp39_ = submarine_name_parser_node_check_pattern (self, "\\d\\d\\d\\d", 4, SUBMARINE_DATA_TYPE_YEAR);
		if (_tmp39_) {
			const gchar* _tmp40_ = NULL;
			gchar* _tmp41_ = NULL;
			gchar* _tmp42_ = NULL;
			gint _tmp43_ = 0;
			_tmp40_ = self->priv->text;
			_tmp41_ = string_substring (_tmp40_, (glong) 0, (glong) 4);
			_tmp42_ = _tmp41_;
			_tmp43_ = atoi (_tmp42_);
			self->year = _tmp43_;
			_g_free0 (_tmp42_);
		}
	}
	_tmp45_ = submarine_name_parser_node_check_pattern (self, "720p", 4, SUBMARINE_DATA_TYPE_RESOLUTION);
	if (_tmp45_) {
		_tmp44_ = TRUE;
	} else {
		gboolean _tmp46_ = FALSE;
		_tmp46_ = submarine_name_parser_node_check_pattern (self, "1080i", 4, SUBMARINE_DATA_TYPE_RESOLUTION);
		_tmp44_ = _tmp46_;
	}
	if (_tmp44_) {
		self->resolution = SUBMARINE_RESOLUTION_HDREADY;
	} else {
		gboolean _tmp47_ = FALSE;
		_tmp47_ = submarine_name_parser_node_check_pattern (self, "1080p", 4, SUBMARINE_DATA_TYPE_RESOLUTION);
		if (_tmp47_) {
			self->resolution = SUBMARINE_RESOLUTION_FULLHD;
		}
	}
	_tmp48_ = submarine_name_parser_node_check_pattern (self, "x264", 4, SUBMARINE_DATA_TYPE_CODEC);
	if (_tmp48_) {
		self->codec = SUBMARINE_CODEC_X264;
	} else {
		gboolean _tmp49_ = FALSE;
		_tmp49_ = submarine_name_parser_node_check_pattern (self, "divx", 4, SUBMARINE_DATA_TYPE_CODEC);
		if (_tmp49_) {
			self->codec = SUBMARINE_CODEC_DIVX;
		} else {
			gboolean _tmp50_ = FALSE;
			_tmp50_ = submarine_name_parser_node_check_pattern (self, "xvid", 4, SUBMARINE_DATA_TYPE_CODEC);
			if (_tmp50_) {
				self->codec = SUBMARINE_CODEC_XVID;
			} else {
				gboolean _tmp51_ = FALSE;
				_tmp51_ = submarine_name_parser_node_check_pattern (self, "mpeg", 4, SUBMARINE_DATA_TYPE_CODEC);
				if (_tmp51_) {
					gdouble _tmp52_ = 0.0;
					self->codec = SUBMARINE_CODEC_MPEG;
					_tmp52_ = self->confidence;
					self->confidence = _tmp52_ * 0.75;
				}
			}
		}
	}
	_tmp53_ = submarine_name_parser_node_check_pattern (self, "bdrip", 5, SUBMARINE_DATA_TYPE_SOURCE);
	if (_tmp53_) {
		self->source = SUBMARINE_SOURCE_BDRIP;
	} else {
		gboolean _tmp54_ = FALSE;
		_tmp54_ = submarine_name_parser_node_check_pattern (self, "dvdrip", 6, SUBMARINE_DATA_TYPE_SOURCE);
		if (_tmp54_) {
			self->source = SUBMARINE_SOURCE_DVDRIP;
		} else {
			gboolean _tmp55_ = FALSE;
			_tmp55_ = submarine_name_parser_node_check_pattern (self, "hdtv", 4, SUBMARINE_DATA_TYPE_SOURCE);
			if (_tmp55_) {
				self->source = SUBMARINE_SOURCE_HDTV;
			}
		}
	}
	return self;
}


SubmarineNameParserNode* submarine_name_parser_node_new (const gchar* txt, SubmarineNameParserNode* thenext, gint c_level) {
	return submarine_name_parser_node_construct (SUBMARINE_TYPE_NAME_PARSER_NODE, txt, thenext, c_level);
}


static gboolean submarine_name_parser_node_check_pattern (SubmarineNameParserNode* self, const gchar* pattern, gint length, SubmarineDataType type) {
	gboolean result = FALSE;
	GMatchInfo* match_info = NULL;
	GRegex* i_year = NULL;
	const gchar* _tmp0_ = NULL;
	GRegex* _tmp1_ = NULL;
	GRegex* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GMatchInfo* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pattern != NULL, FALSE);
	_tmp0_ = pattern;
	_tmp1_ = g_regex_new (_tmp0_, G_REGEX_CASELESS, 0, &_inner_error_);
	i_year = _tmp1_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_match_info_free0 (match_info);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp2_ = i_year;
	_tmp3_ = self->priv->text;
	_tmp5_ = g_regex_match (_tmp2_, _tmp3_, 0, &_tmp4_);
	_g_match_info_free0 (match_info);
	match_info = _tmp4_;
	if (_tmp5_) {
		gint s_pos = 0;
		gint e_pos = 0;
		GMatchInfo* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		gboolean _tmp9_ = FALSE;
		gint _tmp10_ = 0;
		_tmp6_ = match_info;
		g_match_info_fetch_pos (_tmp6_, 0, &_tmp7_, &_tmp8_);
		s_pos = _tmp7_;
		e_pos = _tmp8_;
		_tmp10_ = s_pos;
		if (_tmp10_ == 0) {
			const gchar* _tmp11_ = NULL;
			gint _tmp12_ = 0;
			gint _tmp13_ = 0;
			gint _tmp14_ = 0;
			_tmp11_ = self->priv->text;
			_tmp12_ = strlen (_tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = length;
			_tmp9_ = _tmp13_ == _tmp14_;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			gint _tmp15_ = 0;
			SubmarineDataType _tmp16_ = 0;
			_tmp15_ = self->level;
			self->confidence = 1.0 / _tmp15_;
			_tmp16_ = type;
			self->type = _tmp16_;
			result = TRUE;
			_g_regex_unref0 (i_year);
			_g_match_info_free0 (match_info);
			return result;
		} else {
			gint _tmp17_ = 0;
			const gchar* _tmp18_ = NULL;
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			SubmarineNameParserNode* c2 = NULL;
			const gchar* _tmp31_ = NULL;
			gint _tmp32_ = 0;
			gint _tmp33_ = 0;
			gint _tmp34_ = 0;
			gchar* _tmp35_ = NULL;
			gchar* _tmp36_ = NULL;
			SubmarineNameParserNode* _tmp37_ = NULL;
			gint _tmp38_ = 0;
			SubmarineNameParserNode* _tmp39_ = NULL;
			SubmarineNameParserNode* _tmp40_ = NULL;
			SubmarineNameParserNode* _tmp41_ = NULL;
			SubmarineNameParserNode* _tmp42_ = NULL;
			gint _tmp43_ = 0;
			_tmp17_ = e_pos;
			_tmp18_ = self->priv->text;
			_tmp19_ = strlen (_tmp18_);
			_tmp20_ = _tmp19_;
			if (_tmp17_ < (_tmp20_ - 1)) {
				SubmarineNameParserNode* c1 = NULL;
				const gchar* _tmp21_ = NULL;
				gint _tmp22_ = 0;
				gchar* _tmp23_ = NULL;
				gchar* _tmp24_ = NULL;
				SubmarineNameParserNode* _tmp25_ = NULL;
				gint _tmp26_ = 0;
				SubmarineNameParserNode* _tmp27_ = NULL;
				SubmarineNameParserNode* _tmp28_ = NULL;
				SubmarineNameParserNode* _tmp29_ = NULL;
				SubmarineNameParserNode* _tmp30_ = NULL;
				_tmp21_ = self->priv->text;
				_tmp22_ = e_pos;
				_tmp23_ = string_substring (_tmp21_, (glong) _tmp22_, (glong) (-1));
				_tmp24_ = _tmp23_;
				_tmp25_ = self->child;
				_tmp26_ = self->level;
				_tmp27_ = submarine_name_parser_node_new (_tmp24_, _tmp25_, _tmp26_ + 1);
				_tmp28_ = _tmp27_;
				_g_free0 (_tmp24_);
				c1 = _tmp28_;
				_tmp29_ = c1;
				_tmp30_ = _submarine_name_parser_node_ref0 (_tmp29_);
				_submarine_name_parser_node_unref0 (self->child);
				self->child = _tmp30_;
				_submarine_name_parser_node_unref0 (c1);
			}
			_tmp31_ = self->priv->text;
			_tmp32_ = s_pos;
			_tmp33_ = e_pos;
			_tmp34_ = s_pos;
			_tmp35_ = string_substring (_tmp31_, (glong) _tmp32_, (glong) (_tmp33_ - _tmp34_));
			_tmp36_ = _tmp35_;
			_tmp37_ = self->child;
			_tmp38_ = self->level;
			_tmp39_ = submarine_name_parser_node_new (_tmp36_, _tmp37_, _tmp38_ + 1);
			_tmp40_ = _tmp39_;
			_g_free0 (_tmp36_);
			c2 = _tmp40_;
			_tmp41_ = c2;
			_tmp42_ = _submarine_name_parser_node_ref0 (_tmp41_);
			_submarine_name_parser_node_unref0 (self->child);
			self->child = _tmp42_;
			_tmp43_ = s_pos;
			if (_tmp43_ > 0) {
				SubmarineNameParserNode* c3 = NULL;
				const gchar* _tmp44_ = NULL;
				gint _tmp45_ = 0;
				gchar* _tmp46_ = NULL;
				gchar* _tmp47_ = NULL;
				SubmarineNameParserNode* _tmp48_ = NULL;
				gint _tmp49_ = 0;
				SubmarineNameParserNode* _tmp50_ = NULL;
				SubmarineNameParserNode* _tmp51_ = NULL;
				SubmarineNameParserNode* _tmp52_ = NULL;
				SubmarineNameParserNode* _tmp53_ = NULL;
				_tmp44_ = self->priv->text;
				_tmp45_ = s_pos;
				_tmp46_ = string_substring (_tmp44_, (glong) 0, (glong) _tmp45_);
				_tmp47_ = _tmp46_;
				_tmp48_ = self->child;
				_tmp49_ = self->level;
				_tmp50_ = submarine_name_parser_node_new (_tmp47_, _tmp48_, _tmp49_ + 1);
				_tmp51_ = _tmp50_;
				_g_free0 (_tmp47_);
				c3 = _tmp51_;
				_tmp52_ = c3;
				_tmp53_ = _submarine_name_parser_node_ref0 (_tmp52_);
				_submarine_name_parser_node_unref0 (self->child);
				self->child = _tmp53_;
				_submarine_name_parser_node_unref0 (c3);
			}
			_submarine_name_parser_node_unref0 (c2);
		}
	}
	result = FALSE;
	_g_regex_unref0 (i_year);
	_g_match_info_free0 (match_info);
	return result;
}


static gint string_index_of_char (const gchar* self, gunichar c, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	gunichar _tmp1_ = 0U;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = c;
	_tmp2_ = g_utf8_strchr (((gchar*) self) + _tmp0_, (gssize) (-1), _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static void submarine_name_parser_node_split (SubmarineNameParserNode* self, gunichar character, gunichar* c1, gunichar* c2) {
	gint pos = 0;
	const gchar* _tmp0_ = NULL;
	gunichar _tmp1_ = 0U;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->text;
	_tmp1_ = character;
	_tmp2_ = string_index_of_char (_tmp0_, _tmp1_, 0);
	pos = _tmp2_;
	_tmp3_ = pos;
	if (_tmp3_ == 0) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp4_ = self->priv->text;
		_tmp5_ = string_substring (_tmp4_, (glong) 1, (glong) (-1));
		_g_free0 (self->priv->text);
		self->priv->text = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		_tmp6_ = pos;
		if (_tmp6_ > 0) {
			gint l = 0;
			const gchar* _tmp7_ = NULL;
			gint _tmp8_ = 0;
			gint _tmp9_ = 0;
			gint _tmp10_ = 0;
			gint _tmp11_ = 0;
			_tmp7_ = self->priv->text;
			_tmp8_ = strlen (_tmp7_);
			_tmp9_ = _tmp8_;
			l = _tmp9_ - 1;
			_tmp10_ = pos;
			_tmp11_ = l;
			if (_tmp10_ == _tmp11_) {
				const gchar* _tmp12_ = NULL;
				gint _tmp13_ = 0;
				gchar* _tmp14_ = NULL;
				_tmp12_ = self->priv->text;
				_tmp13_ = l;
				_tmp14_ = string_substring (_tmp12_, (glong) 0, (glong) _tmp13_);
				_g_free0 (self->priv->text);
				self->priv->text = _tmp14_;
			} else {
				gchar* t1 = NULL;
				const gchar* _tmp15_ = NULL;
				gint _tmp16_ = 0;
				gchar* _tmp17_ = NULL;
				gunichar* _tmp18_ = NULL;
				gchar* t2 = NULL;
				const gchar* _tmp22_ = NULL;
				gint _tmp23_ = 0;
				gchar* _tmp24_ = NULL;
				gunichar* _tmp25_ = NULL;
				SubmarineNameParserNode* newchild = NULL;
				const gchar* _tmp29_ = NULL;
				SubmarineNameParserNode* _tmp30_ = NULL;
				gint _tmp31_ = 0;
				SubmarineNameParserNode* _tmp32_ = NULL;
				const gchar* _tmp33_ = NULL;
				gchar* _tmp34_ = NULL;
				SubmarineNameParserNode* _tmp35_ = NULL;
				SubmarineNameParserNode* _tmp36_ = NULL;
				_tmp15_ = self->priv->text;
				_tmp16_ = pos;
				_tmp17_ = string_substring (_tmp15_, (glong) 0, (glong) _tmp16_);
				t1 = _tmp17_;
				_tmp18_ = c2;
				if (_tmp18_ != NULL) {
					const gchar* _tmp19_ = NULL;
					gunichar* _tmp20_ = NULL;
					gchar* _tmp21_ = NULL;
					_tmp19_ = t1;
					_tmp20_ = c2;
					_tmp21_ = g_strconcat (_tmp19_, (const gchar*) _tmp20_, NULL);
					_g_free0 (t1);
					t1 = _tmp21_;
				}
				_tmp22_ = self->priv->text;
				_tmp23_ = pos;
				_tmp24_ = string_substring (_tmp22_, (glong) (_tmp23_ + 1), (glong) (-1));
				t2 = _tmp24_;
				_tmp25_ = c1;
				if (_tmp25_ != NULL) {
					const gchar* _tmp26_ = NULL;
					gunichar* _tmp27_ = NULL;
					gchar* _tmp28_ = NULL;
					_tmp26_ = t2;
					_tmp27_ = c1;
					_tmp28_ = g_strconcat (_tmp26_, (const gchar*) _tmp27_, NULL);
					_g_free0 (t2);
					t2 = _tmp28_;
				}
				_tmp29_ = t2;
				_tmp30_ = self->next;
				_tmp31_ = self->level;
				_tmp32_ = submarine_name_parser_node_new (_tmp29_, _tmp30_, _tmp31_);
				newchild = _tmp32_;
				_tmp33_ = t1;
				_tmp34_ = g_strdup (_tmp33_);
				_g_free0 (self->priv->text);
				self->priv->text = _tmp34_;
				_tmp35_ = newchild;
				_tmp36_ = _submarine_name_parser_node_ref0 (_tmp35_);
				_submarine_name_parser_node_unref0 (self->next);
				self->next = _tmp36_;
				_submarine_name_parser_node_unref0 (newchild);
				_g_free0 (t2);
				_g_free0 (t1);
			}
		}
	}
}


void submarine_name_parser_node_print_content (SubmarineNameParserNode* self) {
	FILE* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gdouble _tmp4_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = stdout;
	_tmp1_ = self->priv->text;
	_tmp2_ = submarine_name_parser_node_return_type (self);
	_tmp3_ = _tmp2_;
	_tmp4_ = self->confidence;
	fprintf (_tmp0_, "%s (%s %f) ", _tmp1_, _tmp3_, _tmp4_);
	_g_free0 (_tmp3_);
}


void submarine_name_parser_node_reset_iterator (SubmarineNameParserNode* self) {
	SubmarineNameParserNode* _tmp0_ = NULL;
	SubmarineNameParserNode* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_submarine_name_parser_node_unref0 (self->iterator);
	self->iterator = NULL;
	_tmp0_ = self->child;
	if (_tmp0_ != NULL) {
		SubmarineNameParserNode* _tmp1_ = NULL;
		_tmp1_ = self->child;
		submarine_name_parser_node_reset_iterator (_tmp1_);
	}
	_tmp2_ = self->next;
	if (_tmp2_ != NULL) {
		SubmarineNameParserNode* _tmp3_ = NULL;
		_tmp3_ = self->next;
		submarine_name_parser_node_reset_iterator (_tmp3_);
	}
}


SubmarineNameParserNode* submarine_name_parser_node_get_next_iterator (SubmarineNameParserNode* self) {
	SubmarineNameParserNode* result = NULL;
	SubmarineNameParserNode* tmp = NULL;
	SubmarineNameParserNode* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->child;
	if (_tmp0_ == NULL) {
		SubmarineNameParserNode* _tmp1_ = NULL;
		_tmp1_ = self->iterator;
		if (_tmp1_ == NULL) {
			SubmarineNameParserNode* _tmp2_ = NULL;
			SubmarineNameParserNode* _tmp3_ = NULL;
			_tmp2_ = _submarine_name_parser_node_ref0 (self);
			_submarine_name_parser_node_unref0 (self->iterator);
			self->iterator = _tmp2_;
			_tmp3_ = _submarine_name_parser_node_ref0 (self);
			result = _tmp3_;
			_submarine_name_parser_node_unref0 (tmp);
			return result;
		} else {
			_submarine_name_parser_node_unref0 (self->iterator);
			self->iterator = NULL;
			result = NULL;
			_submarine_name_parser_node_unref0 (tmp);
			return result;
		}
	} else {
		SubmarineNameParserNode* _tmp4_ = NULL;
		_tmp4_ = self->iterator;
		if (_tmp4_ == NULL) {
			SubmarineNameParserNode* _tmp5_ = NULL;
			SubmarineNameParserNode* _tmp6_ = NULL;
			_tmp5_ = self->child;
			_tmp6_ = _submarine_name_parser_node_ref0 (_tmp5_);
			_submarine_name_parser_node_unref0 (self->iterator);
			self->iterator = _tmp6_;
		}
		{
			gboolean _tmp7_ = FALSE;
			_tmp7_ = TRUE;
			while (TRUE) {
				SubmarineNameParserNode* _tmp9_ = NULL;
				SubmarineNameParserNode* _tmp10_ = NULL;
				SubmarineNameParserNode* _tmp11_ = NULL;
				SubmarineNameParserNode* _tmp12_ = NULL;
				SubmarineNameParserNode* _tmp13_ = NULL;
				SubmarineNameParserNode* _tmp14_ = NULL;
				if (!_tmp7_) {
					SubmarineNameParserNode* _tmp8_ = NULL;
					_tmp8_ = self->iterator;
					if (!(_tmp8_ != NULL)) {
						break;
					}
				}
				_tmp7_ = FALSE;
				_tmp9_ = self->iterator;
				_tmp10_ = submarine_name_parser_node_get_next_iterator (_tmp9_);
				_submarine_name_parser_node_unref0 (tmp);
				tmp = _tmp10_;
				_tmp11_ = tmp;
				if (_tmp11_ != NULL) {
					result = tmp;
					return result;
				}
				_tmp12_ = self->iterator;
				_tmp13_ = _tmp12_->next;
				_tmp14_ = _submarine_name_parser_node_ref0 (_tmp13_);
				_submarine_name_parser_node_unref0 (self->iterator);
				self->iterator = _tmp14_;
			}
		}
		result = NULL;
		_submarine_name_parser_node_unref0 (tmp);
		return result;
	}
	_submarine_name_parser_node_unref0 (tmp);
}


static void submarine_value_name_parser_node_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void submarine_value_name_parser_node_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		submarine_name_parser_node_unref (value->data[0].v_pointer);
	}
}


static void submarine_value_name_parser_node_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = submarine_name_parser_node_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer submarine_value_name_parser_node_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* submarine_value_name_parser_node_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SubmarineNameParserNode* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = submarine_name_parser_node_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* submarine_value_name_parser_node_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SubmarineNameParserNode** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = submarine_name_parser_node_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* submarine_param_spec_name_parser_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	SubmarineParamSpecNameParserNode* spec;
	g_return_val_if_fail (g_type_is_a (object_type, SUBMARINE_TYPE_NAME_PARSER_NODE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer submarine_value_get_name_parser_node (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SUBMARINE_TYPE_NAME_PARSER_NODE), NULL);
	return value->data[0].v_pointer;
}


void submarine_value_set_name_parser_node (GValue* value, gpointer v_object) {
	SubmarineNameParserNode* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SUBMARINE_TYPE_NAME_PARSER_NODE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SUBMARINE_TYPE_NAME_PARSER_NODE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		submarine_name_parser_node_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		submarine_name_parser_node_unref (old);
	}
}


void submarine_value_take_name_parser_node (GValue* value, gpointer v_object) {
	SubmarineNameParserNode* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SUBMARINE_TYPE_NAME_PARSER_NODE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SUBMARINE_TYPE_NAME_PARSER_NODE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		submarine_name_parser_node_unref (old);
	}
}


static void submarine_name_parser_node_class_init (SubmarineNameParserNodeClass * klass) {
	submarine_name_parser_node_parent_class = g_type_class_peek_parent (klass);
	((SubmarineNameParserNodeClass *) klass)->finalize = submarine_name_parser_node_finalize;
	g_type_class_add_private (klass, sizeof (SubmarineNameParserNodePrivate));
}


static void submarine_name_parser_node_instance_init (SubmarineNameParserNode * self) {
	self->priv = SUBMARINE_NAME_PARSER_NODE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void submarine_name_parser_node_finalize (SubmarineNameParserNode* obj) {
	SubmarineNameParserNode * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_NAME_PARSER_NODE, SubmarineNameParserNode);
	g_signal_handlers_destroy (self);
	_g_free0 (self->priv->text);
	_submarine_name_parser_node_unref0 (self->next);
	_submarine_name_parser_node_unref0 (self->child);
	_submarine_name_parser_node_unref0 (self->iterator);
}


GType submarine_name_parser_node_get_type (void) {
	static volatile gsize submarine_name_parser_node_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_name_parser_node_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { submarine_value_name_parser_node_init, submarine_value_name_parser_node_free_value, submarine_value_name_parser_node_copy_value, submarine_value_name_parser_node_peek_pointer, "p", submarine_value_name_parser_node_collect_value, "p", submarine_value_name_parser_node_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineNameParserNodeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_name_parser_node_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineNameParserNode), 0, (GInstanceInitFunc) submarine_name_parser_node_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType submarine_name_parser_node_type_id;
		submarine_name_parser_node_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SubmarineNameParserNode", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&submarine_name_parser_node_type_id__volatile, submarine_name_parser_node_type_id);
	}
	return submarine_name_parser_node_type_id__volatile;
}


gpointer submarine_name_parser_node_ref (gpointer instance) {
	SubmarineNameParserNode* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void submarine_name_parser_node_unref (gpointer instance) {
	SubmarineNameParserNode* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SUBMARINE_NAME_PARSER_NODE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void submarine_name_parser_reset_iterator (SubmarineNameParser* self) {
	SubmarineNameParserNode* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_submarine_name_parser_node_unref0 (self->priv->iterator);
	self->priv->iterator = NULL;
	_tmp0_ = self->priv->node;
	if (_tmp0_ != NULL) {
		SubmarineNameParserNode* _tmp1_ = NULL;
		_tmp1_ = self->priv->node;
		submarine_name_parser_node_reset_iterator (_tmp1_);
	}
}


static SubmarineNameParserNode* submarine_name_parser_get_next_iterator (SubmarineNameParser* self) {
	SubmarineNameParserNode* result = NULL;
	SubmarineNameParserNode* tmp = NULL;
	SubmarineNameParserNode* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->node;
	if (_tmp0_ == NULL) {
		result = NULL;
		_submarine_name_parser_node_unref0 (tmp);
		return result;
	} else {
		SubmarineNameParserNode* _tmp1_ = NULL;
		_tmp1_ = self->priv->iterator;
		if (_tmp1_ == NULL) {
			SubmarineNameParserNode* _tmp2_ = NULL;
			SubmarineNameParserNode* _tmp3_ = NULL;
			_tmp2_ = self->priv->node;
			_tmp3_ = _submarine_name_parser_node_ref0 (_tmp2_);
			_submarine_name_parser_node_unref0 (self->priv->iterator);
			self->priv->iterator = _tmp3_;
		}
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				SubmarineNameParserNode* _tmp6_ = NULL;
				SubmarineNameParserNode* _tmp7_ = NULL;
				SubmarineNameParserNode* _tmp8_ = NULL;
				SubmarineNameParserNode* _tmp9_ = NULL;
				SubmarineNameParserNode* _tmp10_ = NULL;
				SubmarineNameParserNode* _tmp11_ = NULL;
				if (!_tmp4_) {
					SubmarineNameParserNode* _tmp5_ = NULL;
					_tmp5_ = self->priv->iterator;
					if (!(_tmp5_ != NULL)) {
						break;
					}
				}
				_tmp4_ = FALSE;
				_tmp6_ = self->priv->iterator;
				_tmp7_ = submarine_name_parser_node_get_next_iterator (_tmp6_);
				_submarine_name_parser_node_unref0 (tmp);
				tmp = _tmp7_;
				_tmp8_ = tmp;
				if (_tmp8_ != NULL) {
					result = tmp;
					return result;
				}
				_tmp9_ = self->priv->iterator;
				_tmp10_ = _tmp9_->next;
				_tmp11_ = _submarine_name_parser_node_ref0 (_tmp10_);
				_submarine_name_parser_node_unref0 (self->priv->iterator);
				self->priv->iterator = _tmp11_;
			}
		}
		result = NULL;
		_submarine_name_parser_node_unref0 (tmp);
		return result;
	}
	_submarine_name_parser_node_unref0 (tmp);
}


static gint string_last_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


SubmarineNameParser* submarine_name_parser_construct (GType object_type, GFile* file) {
	SubmarineNameParser* self = NULL;
	gchar* tmp = NULL;
	GFile* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gint pos = 0;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gchar* filename = NULL;
	const gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	SubmarineNameParserNode* _tmp8_ = NULL;
	SubmarineNameParserNode* element1 = NULL;
	SubmarineNameParserNode* element2 = NULL;
	SubmarineNameParserNode* tree = NULL;
	SubmarineNameParserNode* last = NULL;
	gchar* _tmp92_ = NULL;
	gdouble year_confidence = 0.0;
	gdouble season_confidence = 0.0;
	gdouble resolution_confidence = 0.0;
	gdouble codec_confidence = 0.0;
	gdouble source_confidence = 0.0;
	gboolean doing_title = FALSE;
	g_return_val_if_fail (file != NULL, NULL);
	self = (SubmarineNameParser*) g_type_create_instance (object_type);
	_tmp0_ = file;
	_tmp1_ = g_file_get_basename (_tmp0_);
	tmp = _tmp1_;
	_tmp2_ = tmp;
	_tmp3_ = string_last_index_of (_tmp2_, ".", 0);
	pos = _tmp3_;
	_tmp4_ = tmp;
	_tmp5_ = pos;
	_tmp6_ = string_substring (_tmp4_, (glong) 0, (glong) _tmp5_);
	filename = _tmp6_;
	_tmp7_ = filename;
	_tmp8_ = submarine_name_parser_node_new (_tmp7_, NULL, 2);
	_submarine_name_parser_node_unref0 (self->priv->node);
	self->priv->node = _tmp8_;
	tree = NULL;
	last = NULL;
	submarine_name_parser_reset_iterator (self);
	while (TRUE) {
		SubmarineNameParserNode* _tmp9_ = NULL;
		SubmarineNameParserNode* _tmp10_ = NULL;
		SubmarineNameParserNode* _tmp11_ = NULL;
		SubmarineNameParserNode* _tmp12_ = NULL;
		SubmarineNameParserNode* _tmp13_ = NULL;
		SubmarineNameParserNode* _tmp16_ = NULL;
		SubmarineNameParserNode* _tmp20_ = NULL;
		SubmarineNameParserNode* _tmp21_ = NULL;
		SubmarineNameParserNode* _tmp22_ = NULL;
		_tmp9_ = submarine_name_parser_get_next_iterator (self);
		_submarine_name_parser_node_unref0 (element1);
		element1 = _tmp9_;
		_tmp10_ = element1;
		if (_tmp10_ == NULL) {
			break;
		}
		_tmp11_ = element1;
		_tmp12_ = submarine_name_parser_node_new_new_copy (_tmp11_);
		_submarine_name_parser_node_unref0 (element2);
		element2 = _tmp12_;
		_tmp13_ = tree;
		if (_tmp13_ == NULL) {
			SubmarineNameParserNode* _tmp14_ = NULL;
			SubmarineNameParserNode* _tmp15_ = NULL;
			_tmp14_ = element2;
			_tmp15_ = _submarine_name_parser_node_ref0 (_tmp14_);
			_submarine_name_parser_node_unref0 (tree);
			tree = _tmp15_;
		}
		_tmp16_ = last;
		if (_tmp16_ != NULL) {
			SubmarineNameParserNode* _tmp17_ = NULL;
			SubmarineNameParserNode* _tmp18_ = NULL;
			SubmarineNameParserNode* _tmp19_ = NULL;
			_tmp17_ = last;
			_tmp18_ = element2;
			_tmp19_ = _submarine_name_parser_node_ref0 (_tmp18_);
			_submarine_name_parser_node_unref0 (_tmp17_->next);
			_tmp17_->next = _tmp19_;
		}
		_tmp20_ = element2;
		_tmp21_ = last;
		_tmp20_->prev = _tmp21_;
		_tmp22_ = element2;
		last = _tmp22_;
	}
	{
		SubmarineNameParserNode* _tmp23_ = NULL;
		SubmarineNameParserNode* _tmp24_ = NULL;
		gboolean _tmp25_ = FALSE;
		_tmp23_ = tree;
		_tmp24_ = _submarine_name_parser_node_ref0 (_tmp23_);
		_submarine_name_parser_node_unref0 (element1);
		element1 = _tmp24_;
		_tmp25_ = TRUE;
		while (TRUE) {
			SubmarineNameParserNode* _tmp29_ = NULL;
			if (!_tmp25_) {
				SubmarineNameParserNode* _tmp26_ = NULL;
				SubmarineNameParserNode* _tmp27_ = NULL;
				SubmarineNameParserNode* _tmp28_ = NULL;
				_tmp26_ = element1;
				_tmp27_ = _tmp26_->next;
				_tmp28_ = _submarine_name_parser_node_ref0 (_tmp27_);
				_submarine_name_parser_node_unref0 (element1);
				element1 = _tmp28_;
			}
			_tmp25_ = FALSE;
			_tmp29_ = element1;
			if (!(_tmp29_ != NULL)) {
				break;
			}
			{
				SubmarineNameParserNode* _tmp30_ = NULL;
				SubmarineNameParserNode* _tmp31_ = NULL;
				SubmarineNameParserNode* _tmp32_ = NULL;
				gboolean _tmp33_ = FALSE;
				_tmp30_ = element1;
				_tmp31_ = _tmp30_->next;
				_tmp32_ = _submarine_name_parser_node_ref0 (_tmp31_);
				_submarine_name_parser_node_unref0 (element2);
				element2 = _tmp32_;
				_tmp33_ = TRUE;
				while (TRUE) {
					SubmarineNameParserNode* _tmp37_ = NULL;
					gboolean _tmp38_ = FALSE;
					SubmarineNameParserNode* _tmp39_ = NULL;
					SubmarineDataType _tmp40_ = 0;
					if (!_tmp33_) {
						SubmarineNameParserNode* _tmp34_ = NULL;
						SubmarineNameParserNode* _tmp35_ = NULL;
						SubmarineNameParserNode* _tmp36_ = NULL;
						_tmp34_ = element2;
						_tmp35_ = _tmp34_->next;
						_tmp36_ = _submarine_name_parser_node_ref0 (_tmp35_);
						_submarine_name_parser_node_unref0 (element2);
						element2 = _tmp36_;
					}
					_tmp33_ = FALSE;
					_tmp37_ = element2;
					if (!(_tmp37_ != NULL)) {
						break;
					}
					_tmp39_ = element1;
					_tmp40_ = _tmp39_->type;
					if (_tmp40_ != SUBMARINE_DATA_TYPE_UNKNOWN) {
						SubmarineNameParserNode* _tmp41_ = NULL;
						SubmarineDataType _tmp42_ = 0;
						SubmarineNameParserNode* _tmp43_ = NULL;
						SubmarineDataType _tmp44_ = 0;
						_tmp41_ = element1;
						_tmp42_ = _tmp41_->type;
						_tmp43_ = element2;
						_tmp44_ = _tmp43_->type;
						_tmp38_ = _tmp42_ == _tmp44_;
					} else {
						_tmp38_ = FALSE;
					}
					if (_tmp38_) {
						gboolean are_equal = FALSE;
						SubmarineNameParserNode* _tmp45_ = NULL;
						SubmarineDataType _tmp46_ = 0;
						gboolean _tmp72_ = FALSE;
						are_equal = FALSE;
						_tmp45_ = element1;
						_tmp46_ = _tmp45_->type;
						switch (_tmp46_) {
							case SUBMARINE_DATA_TYPE_YEAR:
							{
								SubmarineNameParserNode* _tmp47_ = NULL;
								gint _tmp48_ = 0;
								SubmarineNameParserNode* _tmp49_ = NULL;
								gint _tmp50_ = 0;
								_tmp47_ = element1;
								_tmp48_ = _tmp47_->year;
								_tmp49_ = element2;
								_tmp50_ = _tmp49_->year;
								if (_tmp48_ == _tmp50_) {
									are_equal = TRUE;
								}
								break;
							}
							case SUBMARINE_DATA_TYPE_SEASON_CHAPTER:
							{
								gboolean _tmp51_ = FALSE;
								SubmarineNameParserNode* _tmp52_ = NULL;
								gint _tmp53_ = 0;
								SubmarineNameParserNode* _tmp54_ = NULL;
								gint _tmp55_ = 0;
								_tmp52_ = element1;
								_tmp53_ = _tmp52_->season;
								_tmp54_ = element2;
								_tmp55_ = _tmp54_->season;
								if (_tmp53_ == _tmp55_) {
									SubmarineNameParserNode* _tmp56_ = NULL;
									gint _tmp57_ = 0;
									SubmarineNameParserNode* _tmp58_ = NULL;
									gint _tmp59_ = 0;
									_tmp56_ = element1;
									_tmp57_ = _tmp56_->chapter;
									_tmp58_ = element2;
									_tmp59_ = _tmp58_->chapter;
									_tmp51_ = _tmp57_ == _tmp59_;
								} else {
									_tmp51_ = FALSE;
								}
								if (_tmp51_) {
									are_equal = TRUE;
								}
								break;
							}
							case SUBMARINE_DATA_TYPE_CODEC:
							{
								SubmarineNameParserNode* _tmp60_ = NULL;
								SubmarineCodec _tmp61_ = 0;
								SubmarineNameParserNode* _tmp62_ = NULL;
								SubmarineCodec _tmp63_ = 0;
								_tmp60_ = element1;
								_tmp61_ = _tmp60_->codec;
								_tmp62_ = element2;
								_tmp63_ = _tmp62_->codec;
								if (_tmp61_ == _tmp63_) {
									are_equal = TRUE;
								}
								break;
							}
							case SUBMARINE_DATA_TYPE_RESOLUTION:
							{
								SubmarineNameParserNode* _tmp64_ = NULL;
								SubmarineResolution _tmp65_ = 0;
								SubmarineNameParserNode* _tmp66_ = NULL;
								SubmarineResolution _tmp67_ = 0;
								_tmp64_ = element1;
								_tmp65_ = _tmp64_->resolution;
								_tmp66_ = element2;
								_tmp67_ = _tmp66_->resolution;
								if (_tmp65_ == _tmp67_) {
									are_equal = TRUE;
								}
								break;
							}
							case SUBMARINE_DATA_TYPE_SOURCE:
							{
								SubmarineNameParserNode* _tmp68_ = NULL;
								SubmarineSource _tmp69_ = 0;
								SubmarineNameParserNode* _tmp70_ = NULL;
								SubmarineSource _tmp71_ = 0;
								_tmp68_ = element1;
								_tmp69_ = _tmp68_->source;
								_tmp70_ = element2;
								_tmp71_ = _tmp70_->source;
								if (_tmp69_ == _tmp71_) {
									are_equal = TRUE;
								}
								break;
							}
							default:
							{
								break;
							}
						}
						_tmp72_ = are_equal;
						if (_tmp72_ == TRUE) {
							SubmarineNameParserNode* _tmp73_ = NULL;
							SubmarineNameParserNode* _tmp74_ = NULL;
							gdouble _tmp75_ = 0.0;
							SubmarineNameParserNode* _tmp76_ = NULL;
							gdouble _tmp77_ = 0.0;
							SubmarineNameParserNode* _tmp78_ = NULL;
							gdouble _tmp79_ = 0.0;
							SubmarineNameParserNode* _tmp80_ = NULL;
							gdouble _tmp81_ = 0.0;
							SubmarineNameParserNode* _tmp82_ = NULL;
							SubmarineNameParserNode* _tmp83_ = NULL;
							SubmarineNameParserNode* _tmp86_ = NULL;
							SubmarineNameParserNode* _tmp87_ = NULL;
							SubmarineNameParserNode* _tmp88_ = NULL;
							SubmarineNameParserNode* _tmp89_ = NULL;
							SubmarineNameParserNode* _tmp90_ = NULL;
							SubmarineNameParserNode* _tmp91_ = NULL;
							_tmp73_ = element1;
							_tmp74_ = element1;
							_tmp75_ = _tmp74_->confidence;
							_tmp76_ = element2;
							_tmp77_ = _tmp76_->confidence;
							_tmp78_ = element1;
							_tmp79_ = _tmp78_->confidence;
							_tmp80_ = element2;
							_tmp81_ = _tmp80_->confidence;
							_tmp73_->confidence = (_tmp75_ + _tmp77_) - (_tmp79_ * _tmp81_);
							_tmp82_ = last;
							_tmp83_ = element2;
							if (_tmp82_ == _tmp83_) {
								SubmarineNameParserNode* _tmp84_ = NULL;
								SubmarineNameParserNode* _tmp85_ = NULL;
								_tmp84_ = element2;
								_tmp85_ = _tmp84_->prev;
								last = _tmp85_;
							}
							_tmp86_ = element2;
							_tmp87_ = _tmp86_->prev;
							_tmp88_ = element2;
							_tmp89_ = _tmp88_->next;
							_tmp90_ = _submarine_name_parser_node_ref0 (_tmp89_);
							_submarine_name_parser_node_unref0 (_tmp87_->next);
							_tmp87_->next = _tmp90_;
							_tmp91_ = element2;
							_tmp91_->prev = NULL;
						}
					}
				}
			}
		}
	}
	_tmp92_ = g_strdup ("");
	_g_free0 (self->title);
	self->title = _tmp92_;
	self->year = -1;
	self->season = -1;
	self->chapter = -1;
	self->resolution = SUBMARINE_RESOLUTION_UNKNOWN;
	self->codec = SUBMARINE_CODEC_UNKNOWN;
	self->source = SUBMARINE_SOURCE_UNKNOWN;
	year_confidence = 0.0;
	season_confidence = 0.0;
	resolution_confidence = 0.0;
	codec_confidence = 0.0;
	source_confidence = 0.0;
	doing_title = TRUE;
	{
		SubmarineNameParserNode* _tmp93_ = NULL;
		SubmarineNameParserNode* _tmp94_ = NULL;
		gboolean _tmp95_ = FALSE;
		_tmp93_ = tree;
		_tmp94_ = _submarine_name_parser_node_ref0 (_tmp93_);
		_submarine_name_parser_node_unref0 (element1);
		element1 = _tmp94_;
		_tmp95_ = TRUE;
		while (TRUE) {
			SubmarineNameParserNode* _tmp99_ = NULL;
			SubmarineNameParserNode* _tmp100_ = NULL;
			SubmarineDataType _tmp101_ = 0;
			if (!_tmp95_) {
				SubmarineNameParserNode* _tmp96_ = NULL;
				SubmarineNameParserNode* _tmp97_ = NULL;
				SubmarineNameParserNode* _tmp98_ = NULL;
				_tmp96_ = element1;
				_tmp97_ = _tmp96_->next;
				_tmp98_ = _submarine_name_parser_node_ref0 (_tmp97_);
				_submarine_name_parser_node_unref0 (element1);
				element1 = _tmp98_;
			}
			_tmp95_ = FALSE;
			_tmp99_ = element1;
			if (!(_tmp99_ != NULL)) {
				break;
			}
			_tmp100_ = element1;
			_tmp101_ = _tmp100_->type;
			switch (_tmp101_) {
				case SUBMARINE_DATA_TYPE_YEAR:
				{
					SubmarineNameParserNode* _tmp102_ = NULL;
					gdouble _tmp103_ = 0.0;
					gdouble _tmp104_ = 0.0;
					doing_title = FALSE;
					_tmp102_ = element1;
					_tmp103_ = _tmp102_->confidence;
					_tmp104_ = year_confidence;
					if (_tmp103_ > _tmp104_) {
						SubmarineNameParserNode* _tmp105_ = NULL;
						gdouble _tmp106_ = 0.0;
						SubmarineNameParserNode* _tmp107_ = NULL;
						gint _tmp108_ = 0;
						_tmp105_ = element1;
						_tmp106_ = _tmp105_->confidence;
						year_confidence = _tmp106_;
						_tmp107_ = element1;
						_tmp108_ = _tmp107_->year;
						self->year = _tmp108_;
					}
					break;
				}
				case SUBMARINE_DATA_TYPE_SEASON_CHAPTER:
				{
					SubmarineNameParserNode* _tmp109_ = NULL;
					gdouble _tmp110_ = 0.0;
					gdouble _tmp111_ = 0.0;
					doing_title = FALSE;
					_tmp109_ = element1;
					_tmp110_ = _tmp109_->confidence;
					_tmp111_ = season_confidence;
					if (_tmp110_ > _tmp111_) {
						SubmarineNameParserNode* _tmp112_ = NULL;
						gdouble _tmp113_ = 0.0;
						SubmarineNameParserNode* _tmp114_ = NULL;
						gint _tmp115_ = 0;
						SubmarineNameParserNode* _tmp116_ = NULL;
						gint _tmp117_ = 0;
						_tmp112_ = element1;
						_tmp113_ = _tmp112_->confidence;
						season_confidence = _tmp113_;
						_tmp114_ = element1;
						_tmp115_ = _tmp114_->season;
						self->season = _tmp115_;
						_tmp116_ = element1;
						_tmp117_ = _tmp116_->chapter;
						self->chapter = _tmp117_;
					}
					break;
				}
				case SUBMARINE_DATA_TYPE_CODEC:
				{
					SubmarineNameParserNode* _tmp118_ = NULL;
					gdouble _tmp119_ = 0.0;
					gdouble _tmp120_ = 0.0;
					doing_title = FALSE;
					_tmp118_ = element1;
					_tmp119_ = _tmp118_->confidence;
					_tmp120_ = codec_confidence;
					if (_tmp119_ > _tmp120_) {
						SubmarineNameParserNode* _tmp121_ = NULL;
						gdouble _tmp122_ = 0.0;
						SubmarineNameParserNode* _tmp123_ = NULL;
						SubmarineCodec _tmp124_ = 0;
						_tmp121_ = element1;
						_tmp122_ = _tmp121_->confidence;
						codec_confidence = _tmp122_;
						_tmp123_ = element1;
						_tmp124_ = _tmp123_->codec;
						self->codec = _tmp124_;
					}
					break;
				}
				case SUBMARINE_DATA_TYPE_RESOLUTION:
				{
					SubmarineNameParserNode* _tmp125_ = NULL;
					gdouble _tmp126_ = 0.0;
					gdouble _tmp127_ = 0.0;
					doing_title = FALSE;
					_tmp125_ = element1;
					_tmp126_ = _tmp125_->confidence;
					_tmp127_ = resolution_confidence;
					if (_tmp126_ > _tmp127_) {
						SubmarineNameParserNode* _tmp128_ = NULL;
						gdouble _tmp129_ = 0.0;
						SubmarineNameParserNode* _tmp130_ = NULL;
						SubmarineResolution _tmp131_ = 0;
						_tmp128_ = element1;
						_tmp129_ = _tmp128_->confidence;
						resolution_confidence = _tmp129_;
						_tmp130_ = element1;
						_tmp131_ = _tmp130_->resolution;
						self->resolution = _tmp131_;
					}
					break;
				}
				case SUBMARINE_DATA_TYPE_SOURCE:
				{
					SubmarineNameParserNode* _tmp132_ = NULL;
					gdouble _tmp133_ = 0.0;
					gdouble _tmp134_ = 0.0;
					doing_title = FALSE;
					_tmp132_ = element1;
					_tmp133_ = _tmp132_->confidence;
					_tmp134_ = source_confidence;
					if (_tmp133_ > _tmp134_) {
						SubmarineNameParserNode* _tmp135_ = NULL;
						gdouble _tmp136_ = 0.0;
						SubmarineNameParserNode* _tmp137_ = NULL;
						SubmarineSource _tmp138_ = 0;
						_tmp135_ = element1;
						_tmp136_ = _tmp135_->confidence;
						source_confidence = _tmp136_;
						_tmp137_ = element1;
						_tmp138_ = _tmp137_->source;
						self->source = _tmp138_;
					}
					break;
				}
				case SUBMARINE_DATA_TYPE_UNKNOWN:
				{
					gboolean _tmp139_ = FALSE;
					_tmp139_ = doing_title;
					if (_tmp139_) {
						SubmarineNameParserNode* _tmp140_ = NULL;
						gchar* _tmp141_ = NULL;
						gchar* _tmp142_ = NULL;
						gint _tmp143_ = 0;
						gint _tmp144_ = 0;
						gboolean _tmp145_ = FALSE;
						_tmp140_ = element1;
						_tmp141_ = submarine_name_parser_node_get_inner_text (_tmp140_);
						_tmp142_ = _tmp141_;
						_tmp143_ = strlen (_tmp142_);
						_tmp144_ = _tmp143_;
						_tmp145_ = _tmp144_ > 0;
						_g_free0 (_tmp142_);
						if (_tmp145_) {
							const gchar* _tmp146_ = NULL;
							const gchar* _tmp149_ = NULL;
							SubmarineNameParserNode* _tmp150_ = NULL;
							gchar* _tmp151_ = NULL;
							gchar* _tmp152_ = NULL;
							gchar* _tmp153_ = NULL;
							_tmp146_ = self->title;
							if (g_strcmp0 (_tmp146_, "") != 0) {
								const gchar* _tmp147_ = NULL;
								gchar* _tmp148_ = NULL;
								_tmp147_ = self->title;
								_tmp148_ = g_strconcat (_tmp147_, " ", NULL);
								_g_free0 (self->title);
								self->title = _tmp148_;
							}
							_tmp149_ = self->title;
							_tmp150_ = element1;
							_tmp151_ = submarine_name_parser_node_get_inner_text (_tmp150_);
							_tmp152_ = _tmp151_;
							_tmp153_ = g_strconcat (_tmp149_, _tmp152_, NULL);
							_g_free0 (self->title);
							self->title = _tmp153_;
							_g_free0 (_tmp152_);
						}
					}
					break;
				}
				default:
				{
					break;
				}
			}
		}
	}
	_submarine_name_parser_node_unref0 (tree);
	_submarine_name_parser_node_unref0 (element2);
	_submarine_name_parser_node_unref0 (element1);
	_g_free0 (filename);
	_g_free0 (tmp);
	return self;
}


SubmarineNameParser* submarine_name_parser_new (GFile* file) {
	return submarine_name_parser_construct (SUBMARINE_TYPE_NAME_PARSER, file);
}


static void submarine_value_name_parser_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void submarine_value_name_parser_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		submarine_name_parser_unref (value->data[0].v_pointer);
	}
}


static void submarine_value_name_parser_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = submarine_name_parser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer submarine_value_name_parser_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* submarine_value_name_parser_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SubmarineNameParser* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = submarine_name_parser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* submarine_value_name_parser_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SubmarineNameParser** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = submarine_name_parser_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* submarine_param_spec_name_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	SubmarineParamSpecNameParser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, SUBMARINE_TYPE_NAME_PARSER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer submarine_value_get_name_parser (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SUBMARINE_TYPE_NAME_PARSER), NULL);
	return value->data[0].v_pointer;
}


void submarine_value_set_name_parser (GValue* value, gpointer v_object) {
	SubmarineNameParser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SUBMARINE_TYPE_NAME_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SUBMARINE_TYPE_NAME_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		submarine_name_parser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		submarine_name_parser_unref (old);
	}
}


void submarine_value_take_name_parser (GValue* value, gpointer v_object) {
	SubmarineNameParser* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SUBMARINE_TYPE_NAME_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SUBMARINE_TYPE_NAME_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		submarine_name_parser_unref (old);
	}
}


static void submarine_name_parser_class_init (SubmarineNameParserClass * klass) {
	submarine_name_parser_parent_class = g_type_class_peek_parent (klass);
	((SubmarineNameParserClass *) klass)->finalize = submarine_name_parser_finalize;
	g_type_class_add_private (klass, sizeof (SubmarineNameParserPrivate));
}


static void submarine_name_parser_instance_init (SubmarineNameParser * self) {
	self->priv = SUBMARINE_NAME_PARSER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void submarine_name_parser_finalize (SubmarineNameParser* obj) {
	SubmarineNameParser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParser);
	g_signal_handlers_destroy (self);
	_g_free0 (self->title);
	_submarine_name_parser_node_unref0 (self->priv->node);
	_submarine_name_parser_node_unref0 (self->priv->iterator);
}


GType submarine_name_parser_get_type (void) {
	static volatile gsize submarine_name_parser_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_name_parser_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { submarine_value_name_parser_init, submarine_value_name_parser_free_value, submarine_value_name_parser_copy_value, submarine_value_name_parser_peek_pointer, "p", submarine_value_name_parser_collect_value, "p", submarine_value_name_parser_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineNameParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_name_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineNameParser), 0, (GInstanceInitFunc) submarine_name_parser_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType submarine_name_parser_type_id;
		submarine_name_parser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SubmarineNameParser", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&submarine_name_parser_type_id__volatile, submarine_name_parser_type_id);
	}
	return submarine_name_parser_type_id__volatile;
}


gpointer submarine_name_parser_ref (gpointer instance) {
	SubmarineNameParser* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void submarine_name_parser_unref (gpointer instance) {
	SubmarineNameParser* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SUBMARINE_NAME_PARSER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



