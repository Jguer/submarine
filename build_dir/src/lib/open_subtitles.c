/* open_subtitles.c generated by valac 0.28.0, the Vala compiler
 * generated from open_subtitles.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <libsoup/soup.h>
#include <float.h>
#include <math.h>
#include <stdio.h>


#define SUBMARINE_TYPE_SUBTITLE_SERVER (submarine_subtitle_server_get_type ())
#define SUBMARINE_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer))
#define SUBMARINE_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))
#define SUBMARINE_IS_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_IS_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_SUBTITLE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))

typedef struct _SubmarineSubtitleServer SubmarineSubtitleServer;
typedef struct _SubmarineSubtitleServerClass SubmarineSubtitleServerClass;
typedef struct _SubmarineSubtitleServerPrivate SubmarineSubtitleServerPrivate;

#define SUBMARINE_TYPE_SUBTITLE (submarine_subtitle_get_type ())
#define SUBMARINE_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitle))
#define SUBMARINE_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))
#define SUBMARINE_IS_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_IS_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_SUBTITLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))

typedef struct _SubmarineSubtitle SubmarineSubtitle;
typedef struct _SubmarineSubtitleClass SubmarineSubtitleClass;

#define SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER (submarine_open_subtitles_server_get_type ())
#define SUBMARINE_OPEN_SUBTITLES_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER, SubmarineOpenSubtitlesServer))
#define SUBMARINE_OPEN_SUBTITLES_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER, SubmarineOpenSubtitlesServerClass))
#define SUBMARINE_IS_OPEN_SUBTITLES_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER))
#define SUBMARINE_IS_OPEN_SUBTITLES_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER))
#define SUBMARINE_OPEN_SUBTITLES_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER, SubmarineOpenSubtitlesServerClass))

typedef struct _SubmarineOpenSubtitlesServer SubmarineOpenSubtitlesServer;
typedef struct _SubmarineOpenSubtitlesServerClass SubmarineOpenSubtitlesServerClass;
typedef struct _SubmarineOpenSubtitlesServerPrivate SubmarineOpenSubtitlesServerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define SUBMARINE_TYPE_LANGUAGE_INFO (submarine_language_info_get_type ())
typedef struct _SubmarineLanguageInfo SubmarineLanguageInfo;
#define _submarine_language_info_free0(var) ((var == NULL) ? NULL : (var = (submarine_language_info_free (var), NULL)))
typedef struct _Block1Data Block1Data;
#define __vala_GValue_free0(var) ((var == NULL) ? NULL : (var = (_vala_GValue_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_value_array_free0(var) ((var == NULL) ? NULL : (var = (g_value_array_free (var), NULL)))

#define SUBMARINE_TYPE_SERVER_INFO (submarine_server_info_get_type ())
typedef struct _SubmarineServerInfo SubmarineServerInfo;
#define _submarine_subtitle_unref0(var) ((var == NULL) ? NULL : (var = (submarine_subtitle_unref (var), NULL)))
typedef struct _Block2Data Block2Data;

struct _SubmarineSubtitleServer {
	GObject parent_instance;
	SubmarineSubtitleServerPrivate * priv;
};

struct _SubmarineSubtitleServerClass {
	GObjectClass parent_class;
	gboolean (*connect) (SubmarineSubtitleServer* self);
	void (*disconnect) (SubmarineSubtitleServer* self);
	GeeSet* (*search) (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
	GeeMultiMap* (*search_multiple) (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
	SubmarineSubtitle* (*download) (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
	GeeSet* (*download_multiple) (SubmarineSubtitleServer* self, GeeCollection* subtitles);
};

struct _SubmarineOpenSubtitlesServer {
	SubmarineSubtitleServer parent_instance;
	SubmarineOpenSubtitlesServerPrivate * priv;
};

struct _SubmarineOpenSubtitlesServerClass {
	SubmarineSubtitleServerClass parent_class;
};

struct _SubmarineOpenSubtitlesServerPrivate {
	SoupSessionSync* session;
	gchar* session_token;
	GeeHashSet* supported_languages;
};

struct _SubmarineLanguageInfo {
	gchar* _long_code;
	gchar* _long_code_alt;
	gchar* _short_code;
	gchar* _name;
};

struct _Block1Data {
	int _ref_count_;
	SubmarineOpenSubtitlesServer* self;
	GeeHashMultiMap* subtitles_found_map;
	GeeHashMap* hash_file;
};

typedef GValue* (*SubmarineSubtitleServerBatchRequestMethod) (GeeList* request_batch, void* user_data);
typedef gint (*SubmarineSubtitleServerBatchResponseMethod) (GValue* response, void* user_data);
struct _SubmarineServerInfo {
	gchar* _name;
	gchar* _address;
	gchar* _code;
};

struct _Block2Data {
	int _ref_count_;
	SubmarineOpenSubtitlesServer* self;
	GeeHashSet* subtitles_downloaded;
	GeeHashMap* id_map;
};


static gpointer submarine_open_subtitles_server_parent_class = NULL;

GType submarine_subtitle_server_get_type (void) G_GNUC_CONST;
gpointer submarine_subtitle_ref (gpointer instance);
void submarine_subtitle_unref (gpointer instance);
GParamSpec* submarine_param_spec_subtitle (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_subtitle (GValue* value, gpointer v_object);
void submarine_value_take_subtitle (GValue* value, gpointer v_object);
gpointer submarine_value_get_subtitle (const GValue* value);
GType submarine_subtitle_get_type (void) G_GNUC_CONST;
GType submarine_open_subtitles_server_get_type (void) G_GNUC_CONST;
#define SUBMARINE_OPEN_SUBTITLES_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER, SubmarineOpenSubtitlesServerPrivate))
enum  {
	SUBMARINE_OPEN_SUBTITLES_SERVER_DUMMY_PROPERTY
};
#define SUBMARINE_OPEN_SUBTITLES_SERVER_XMLRPC_URI "http://api.opensubtitles.org/xml-rpc"
static gboolean submarine_open_subtitles_server_get_supported_languages (SubmarineOpenSubtitlesServer* self);
gboolean submarine_xmlrpc_call (SoupSession* session, SoupMessage* message, GHashTable** vhash, guint* status_code);
static gchar* submarine_open_subtitles_server_language_codes_string (SubmarineOpenSubtitlesServer* self, GeeCollection* languages);
GType submarine_language_info_get_type (void) G_GNUC_CONST;
SubmarineLanguageInfo* submarine_language_info_dup (const SubmarineLanguageInfo* self);
void submarine_language_info_free (SubmarineLanguageInfo* self);
void submarine_language_info_copy (const SubmarineLanguageInfo* self, SubmarineLanguageInfo* dest);
void submarine_language_info_destroy (SubmarineLanguageInfo* self);
SubmarineLanguageInfo* submarine_get_language_info (const gchar* language_code);
const gchar* submarine_language_info_get_long_code (SubmarineLanguageInfo* self);
const gchar* submarine_language_info_get_long_code_alt (SubmarineLanguageInfo* self);
static gchar** _vala_array_dup2 (gchar** self, int length);
static guint64 submarine_open_subtitles_server_file_size (SubmarineOpenSubtitlesServer* self, GFile* file, GError** error);
static guint64 submarine_open_subtitles_server_file_hash (SubmarineOpenSubtitlesServer* self, GFile* file, GError** error);
static gchar* submarine_open_subtitles_server_inflate_subtitle (SubmarineOpenSubtitlesServer* self, guint8* data, int data_length1, GError** error);
static guint8* _vala_array_dup3 (guint8* self, int length);
static void* _g_realloc_grealloc_func (void* data, gsize size);
static void _g_free_gdestroy_notify (void* data);
static gboolean submarine_open_subtitles_server_real_connect (SubmarineSubtitleServer* base);
static void submarine_open_subtitles_server_real_disconnect (SubmarineSubtitleServer* base);
static GeeMultiMap* submarine_open_subtitles_server_real_search_multiple (SubmarineSubtitleServer* base, GeeCollection* files, GeeCollection* languages);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static GValue* _g_value_dup (GValue* self);
static void _vala_GValue_free (GValue* self);
static void _g_free0_ (gpointer var);
static void __vala_GValue_free0_ (gpointer var);
static GValue* __lambda5_ (SubmarineOpenSubtitlesServer* self, GeeList* request_batch);
static GValue* ___lambda5__submarine_subtitle_server_batch_request_method (GeeList* request_batch, gpointer self);
static gint __lambda6_ (Block1Data* _data1_, GValue* response);
GType submarine_server_info_get_type (void) G_GNUC_CONST;
SubmarineServerInfo* submarine_server_info_dup (const SubmarineServerInfo* self);
void submarine_server_info_free (SubmarineServerInfo* self);
void submarine_server_info_copy (const SubmarineServerInfo* self, SubmarineServerInfo* dest);
void submarine_server_info_destroy (SubmarineServerInfo* self);
void submarine_subtitle_server_get_info (SubmarineSubtitleServer* self, SubmarineServerInfo* result);
SubmarineSubtitle* submarine_subtitle_new (SubmarineServerInfo* server_info, GValue* server_data);
SubmarineSubtitle* submarine_subtitle_construct (GType object_type, SubmarineServerInfo* server_info, GValue* server_data);
void submarine_subtitle_set_format (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_language (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_rating (SubmarineSubtitle* self, gdouble value);
gdouble submarine_subtitle_get_rating (SubmarineSubtitle* self);
static gint ___lambda6__submarine_subtitle_server_batch_response_method (GValue* response, gpointer self);
GeeArrayList* submarine_subtitle_server_batch_process (SubmarineSubtitleServer* self, GeeList* requests, SubmarineSubtitleServerBatchRequestMethod request_method, void* request_method_target, SubmarineSubtitleServerBatchResponseMethod response_method, void* response_method_target, gint max_request_size, gint max_response_size);
static GeeSet* submarine_open_subtitles_server_real_download_multiple (SubmarineSubtitleServer* base, GeeCollection* subtitles);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
void submarine_subtitle_get_server_data (SubmarineSubtitle* self, GValue* result);
static GValue* __lambda7_ (SubmarineOpenSubtitlesServer* self, GeeList* request_batch);
static GValue* ___lambda7__submarine_subtitle_server_batch_request_method (GeeList* request_batch, gpointer self);
static gint __lambda8_ (Block2Data* _data2_, GValue* response);
void submarine_subtitle_set_data (SubmarineSubtitle* self, const gchar* value);
static gint ___lambda8__submarine_subtitle_server_batch_response_method (GValue* response, gpointer self);
SubmarineOpenSubtitlesServer* submarine_open_subtitles_server_new (void);
SubmarineOpenSubtitlesServer* submarine_open_subtitles_server_construct (GType object_type);
SubmarineSubtitleServer* submarine_subtitle_server_construct (GType object_type);
static GObject * submarine_open_subtitles_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void submarine_server_info_init (SubmarineServerInfo *self, const gchar* name, const gchar* address, const gchar* code);
void submarine_subtitle_server_set_info (SubmarineSubtitleServer* self, SubmarineServerInfo* value);
static void submarine_open_subtitles_server_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


static gboolean submarine_open_subtitles_server_get_supported_languages (SubmarineOpenSubtitlesServer* self) {
	gboolean result = FALSE;
	GHashTable* vh = NULL;
	GeeHashSet* _tmp0_ = NULL;
	SoupMessage* message = NULL;
	const gchar* _tmp1_ = NULL;
	SoupMessage* _tmp2_ = NULL;
	SoupSessionSync* _tmp3_ = NULL;
	SoupMessage* _tmp4_ = NULL;
	GHashTable* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->supported_languages);
	self->priv->supported_languages = _tmp0_;
	_tmp1_ = self->priv->session_token;
	_tmp2_ = soup_xmlrpc_request_new (SUBMARINE_OPEN_SUBTITLES_SERVER_XMLRPC_URI, "GetSubLanguages", G_TYPE_STRING, _tmp1_, G_TYPE_INVALID);
	message = _tmp2_;
	_tmp3_ = self->priv->session;
	_tmp4_ = message;
	_tmp6_ = submarine_xmlrpc_call ((SoupSession*) _tmp3_, _tmp4_, &_tmp5_, NULL);
	_g_hash_table_unref0 (vh);
	vh = _tmp5_;
	if (_tmp6_) {
		GValueArray* va = NULL;
		GHashTable* _tmp7_ = NULL;
		gconstpointer _tmp8_ = NULL;
		GValueArray* _tmp9_ = NULL;
		_tmp7_ = vh;
		_tmp8_ = g_hash_table_lookup (_tmp7_, "data");
		va = g_value_get_boxed ((GValue*) _tmp8_);
		_tmp9_ = va;
		{
			GValueArray* vresult_collection = NULL;
			guint vresult_index = 0U;
			vresult_collection = _tmp9_;
			for (vresult_index = 0; vresult_index < vresult_collection->n_values; vresult_index = vresult_index + 1) {
				GValue _tmp10_ = {0};
				GValue vresult = {0};
				if (G_IS_VALUE (g_value_array_get_nth (vresult_collection, vresult_index))) {
					g_value_init (&_tmp10_, G_VALUE_TYPE (g_value_array_get_nth (vresult_collection, vresult_index)));
					g_value_copy (g_value_array_get_nth (vresult_collection, vresult_index), &_tmp10_);
				} else {
					_tmp10_ = *g_value_array_get_nth (vresult_collection, vresult_index);
				}
				vresult = _tmp10_;
				{
					GHashTable* _result_ = NULL;
					GValue _tmp11_ = {0};
					GHashTable* _tmp12_ = NULL;
					GeeHashSet* _tmp13_ = NULL;
					GHashTable* _tmp14_ = NULL;
					gconstpointer _tmp15_ = NULL;
					_tmp11_ = vresult;
					_tmp12_ = _g_hash_table_ref0 (g_value_get_boxed (&_tmp11_));
					_result_ = _tmp12_;
					_tmp13_ = self->priv->supported_languages;
					_tmp14_ = _result_;
					_tmp15_ = g_hash_table_lookup (_tmp14_, "SubLanguageID");
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp13_, g_value_get_string ((GValue*) _tmp15_));
					_g_hash_table_unref0 (_result_);
					G_IS_VALUE (&vresult) ? (g_value_unset (&vresult), NULL) : NULL;
				}
			}
		}
		result = TRUE;
		_g_object_unref0 (message);
		_g_hash_table_unref0 (vh);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (message);
	_g_hash_table_unref0 (vh);
	return result;
}


static gchar** _vala_array_dup2 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static gchar* _vala_g_strjoinv (const gchar* separator, gchar** str_array, int str_array_length1) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	_tmp0_ = separator;
	if (_tmp0_ == NULL) {
		separator = "";
	}
	_tmp3_ = str_array;
	_tmp3__length1 = str_array_length1;
	if (_tmp3_ != NULL) {
		_tmp2_ = TRUE;
	} else {
		gchar** _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		_tmp4_ = str_array;
		_tmp4__length1 = str_array_length1;
		_tmp2_ = _tmp4__length1 > 0;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp5_ = FALSE;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		_tmp6_ = str_array;
		_tmp6__length1 = str_array_length1;
		if (_tmp6__length1 == (-1)) {
			gchar** _tmp7_ = NULL;
			gint _tmp7__length1 = 0;
			const gchar* _tmp8_ = NULL;
			_tmp7_ = str_array;
			_tmp7__length1 = str_array_length1;
			_tmp8_ = _tmp7_[0];
			_tmp5_ = _tmp8_ != NULL;
		} else {
			_tmp5_ = FALSE;
		}
		_tmp1_ = _tmp5_;
	}
	if (_tmp1_) {
		gint i = 0;
		gsize len = 0UL;
		gint _tmp31_ = 0;
		gint _tmp33_ = 0;
		gint _tmp34_ = 0;
		gsize _tmp35_ = 0UL;
		const gchar* _tmp36_ = NULL;
		gint _tmp37_ = 0;
		gint _tmp38_ = 0;
		gint _tmp39_ = 0;
		const gchar* res = NULL;
		gsize _tmp40_ = 0UL;
		void* _tmp41_ = NULL;
		void* ptr = NULL;
		const gchar* _tmp42_ = NULL;
		gchar** _tmp43_ = NULL;
		gint _tmp43__length1 = 0;
		const gchar* _tmp44_ = NULL;
		void* _tmp45_ = NULL;
		const gchar* _tmp62_ = NULL;
		len = (gsize) 1;
		{
			gboolean _tmp9_ = FALSE;
			i = 0;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_ = FALSE;
				gboolean _tmp12_ = FALSE;
				gchar** _tmp13_ = NULL;
				gint _tmp13__length1 = 0;
				gint _tmp21_ = 0;
				gchar** _tmp22_ = NULL;
				gint _tmp22__length1 = 0;
				gint _tmp23_ = 0;
				const gchar* _tmp24_ = NULL;
				gsize _tmp30_ = 0UL;
				if (!_tmp9_) {
					gint _tmp10_ = 0;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp13_ = str_array;
				_tmp13__length1 = str_array_length1;
				if (_tmp13__length1 != (-1)) {
					gint _tmp14_ = 0;
					gchar** _tmp15_ = NULL;
					gint _tmp15__length1 = 0;
					_tmp14_ = i;
					_tmp15_ = str_array;
					_tmp15__length1 = str_array_length1;
					_tmp12_ = _tmp14_ < _tmp15__length1;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					_tmp11_ = TRUE;
				} else {
					gboolean _tmp16_ = FALSE;
					gchar** _tmp17_ = NULL;
					gint _tmp17__length1 = 0;
					_tmp17_ = str_array;
					_tmp17__length1 = str_array_length1;
					if (_tmp17__length1 == (-1)) {
						gchar** _tmp18_ = NULL;
						gint _tmp18__length1 = 0;
						gint _tmp19_ = 0;
						const gchar* _tmp20_ = NULL;
						_tmp18_ = str_array;
						_tmp18__length1 = str_array_length1;
						_tmp19_ = i;
						_tmp20_ = _tmp18_[_tmp19_];
						_tmp16_ = _tmp20_ != NULL;
					} else {
						_tmp16_ = FALSE;
					}
					_tmp11_ = _tmp16_;
				}
				if (!_tmp11_) {
					break;
				}
				_tmp22_ = str_array;
				_tmp22__length1 = str_array_length1;
				_tmp23_ = i;
				_tmp24_ = _tmp22_[_tmp23_];
				if (_tmp24_ != NULL) {
					gchar** _tmp25_ = NULL;
					gint _tmp25__length1 = 0;
					gint _tmp26_ = 0;
					const gchar* _tmp27_ = NULL;
					gint _tmp28_ = 0;
					gint _tmp29_ = 0;
					_tmp25_ = str_array;
					_tmp25__length1 = str_array_length1;
					_tmp26_ = i;
					_tmp27_ = _tmp25_[_tmp26_];
					_tmp28_ = strlen ((const gchar*) _tmp27_);
					_tmp29_ = _tmp28_;
					_tmp21_ = _tmp29_;
				} else {
					_tmp21_ = 0;
				}
				_tmp30_ = len;
				len = _tmp30_ + _tmp21_;
			}
		}
		_tmp31_ = i;
		if (_tmp31_ == 0) {
			gchar* _tmp32_ = NULL;
			_tmp32_ = g_strdup ("");
			result = _tmp32_;
			return result;
		}
		_tmp33_ = i;
		str_array_length1 = _tmp33_;
		_tmp34_ = str_array_length1;
		_tmp35_ = len;
		_tmp36_ = separator;
		_tmp37_ = strlen ((const gchar*) _tmp36_);
		_tmp38_ = _tmp37_;
		_tmp39_ = i;
		len = _tmp35_ + (_tmp38_ * (_tmp39_ - 1));
		_tmp40_ = len;
		_tmp41_ = g_malloc (_tmp40_);
		res = _tmp41_;
		_tmp42_ = res;
		_tmp43_ = str_array;
		_tmp43__length1 = str_array_length1;
		_tmp44_ = _tmp43_[0];
		_tmp45_ = g_stpcpy ((void*) _tmp42_, (const gchar*) _tmp44_);
		ptr = _tmp45_;
		{
			gboolean _tmp46_ = FALSE;
			i = 1;
			_tmp46_ = TRUE;
			while (TRUE) {
				gint _tmp48_ = 0;
				gchar** _tmp49_ = NULL;
				gint _tmp49__length1 = 0;
				void* _tmp50_ = NULL;
				const gchar* _tmp51_ = NULL;
				void* _tmp52_ = NULL;
				const gchar* _tmp53_ = NULL;
				gchar** _tmp54_ = NULL;
				gint _tmp54__length1 = 0;
				gint _tmp55_ = 0;
				const gchar* _tmp56_ = NULL;
				void* _tmp60_ = NULL;
				void* _tmp61_ = NULL;
				if (!_tmp46_) {
					gint _tmp47_ = 0;
					_tmp47_ = i;
					i = _tmp47_ + 1;
				}
				_tmp46_ = FALSE;
				_tmp48_ = i;
				_tmp49_ = str_array;
				_tmp49__length1 = str_array_length1;
				if (!(_tmp48_ < _tmp49__length1)) {
					break;
				}
				_tmp50_ = ptr;
				_tmp51_ = separator;
				_tmp52_ = g_stpcpy (_tmp50_, (const gchar*) _tmp51_);
				ptr = _tmp52_;
				_tmp54_ = str_array;
				_tmp54__length1 = str_array_length1;
				_tmp55_ = i;
				_tmp56_ = _tmp54_[_tmp55_];
				if (_tmp56_ != NULL) {
					gchar** _tmp57_ = NULL;
					gint _tmp57__length1 = 0;
					gint _tmp58_ = 0;
					const gchar* _tmp59_ = NULL;
					_tmp57_ = str_array;
					_tmp57__length1 = str_array_length1;
					_tmp58_ = i;
					_tmp59_ = _tmp57_[_tmp58_];
					_tmp53_ = (const gchar*) _tmp59_;
				} else {
					_tmp53_ = "";
				}
				_tmp60_ = ptr;
				_tmp61_ = g_stpcpy (_tmp60_, _tmp53_);
				ptr = _tmp61_;
			}
		}
		_tmp62_ = res;
		res = NULL;
		result = (gchar*) _tmp62_;
		return result;
	} else {
		gchar* _tmp63_ = NULL;
		_tmp63_ = g_strdup ("");
		result = _tmp63_;
		return result;
	}
}


static gchar* submarine_open_subtitles_server_language_codes_string (SubmarineOpenSubtitlesServer* self, GeeCollection* languages) {
	gchar* result = NULL;
	GeeHashSet* languages_set = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GeeHashSet* _tmp1_ = NULL;
	gchar** languages_array = NULL;
	GeeHashSet* _tmp32_ = NULL;
	gint _tmp33_ = 0;
	gpointer* _tmp34_ = NULL;
	gint languages_array_length1 = 0;
	gint _languages_array_size_ = 0;
	gchar** languages_array_copy = NULL;
	gchar** _tmp35_ = NULL;
	gint _tmp35__length1 = 0;
	gint languages_array_copy_length1 = 0;
	gint _languages_array_copy_size_ = 0;
	gchar* _tmp36_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	languages_set = _tmp0_;
	_tmp1_ = self->priv->supported_languages;
	if (_tmp1_ == NULL) {
		submarine_open_subtitles_server_get_supported_languages (self);
	}
	{
		GeeIterator* _language_it = NULL;
		GeeCollection* _tmp2_ = NULL;
		GeeIterator* _tmp3_ = NULL;
		_tmp2_ = languages;
		_tmp3_ = gee_iterable_iterator ((GeeIterable*) _tmp2_);
		_language_it = _tmp3_;
		while (TRUE) {
			GeeIterator* _tmp4_ = NULL;
			gboolean _tmp5_ = FALSE;
			gchar* language = NULL;
			GeeIterator* _tmp6_ = NULL;
			gpointer _tmp7_ = NULL;
			SubmarineLanguageInfo* language_info = NULL;
			const gchar* _tmp8_ = NULL;
			SubmarineLanguageInfo* _tmp9_ = NULL;
			GeeHashSet* _tmp10_ = NULL;
			SubmarineLanguageInfo* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			gboolean _tmp14_ = FALSE;
			gboolean _tmp19_ = FALSE;
			SubmarineLanguageInfo* _tmp20_ = NULL;
			const gchar* _tmp21_ = NULL;
			const gchar* _tmp22_ = NULL;
			_tmp4_ = _language_it;
			_tmp5_ = gee_iterator_next (_tmp4_);
			if (!_tmp5_) {
				break;
			}
			_tmp6_ = _language_it;
			_tmp7_ = gee_iterator_get (_tmp6_);
			language = (gchar*) _tmp7_;
			_tmp8_ = language;
			_tmp9_ = submarine_get_language_info (_tmp8_);
			language_info = _tmp9_;
			_tmp10_ = self->priv->supported_languages;
			_tmp11_ = language_info;
			_tmp12_ = submarine_language_info_get_long_code (_tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp10_, _tmp13_);
			if (_tmp14_) {
				GeeHashSet* _tmp15_ = NULL;
				SubmarineLanguageInfo* _tmp16_ = NULL;
				const gchar* _tmp17_ = NULL;
				const gchar* _tmp18_ = NULL;
				_tmp15_ = languages_set;
				_tmp16_ = language_info;
				_tmp17_ = submarine_language_info_get_long_code (_tmp16_);
				_tmp18_ = _tmp17_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp15_, _tmp18_);
			}
			_tmp20_ = language_info;
			_tmp21_ = submarine_language_info_get_long_code_alt (_tmp20_);
			_tmp22_ = _tmp21_;
			if (_tmp22_ != NULL) {
				GeeHashSet* _tmp23_ = NULL;
				SubmarineLanguageInfo* _tmp24_ = NULL;
				const gchar* _tmp25_ = NULL;
				const gchar* _tmp26_ = NULL;
				gboolean _tmp27_ = FALSE;
				_tmp23_ = self->priv->supported_languages;
				_tmp24_ = language_info;
				_tmp25_ = submarine_language_info_get_long_code_alt (_tmp24_);
				_tmp26_ = _tmp25_;
				_tmp27_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp23_, _tmp26_);
				_tmp19_ = _tmp27_;
			} else {
				_tmp19_ = FALSE;
			}
			if (_tmp19_) {
				GeeHashSet* _tmp28_ = NULL;
				SubmarineLanguageInfo* _tmp29_ = NULL;
				const gchar* _tmp30_ = NULL;
				const gchar* _tmp31_ = NULL;
				_tmp28_ = languages_set;
				_tmp29_ = language_info;
				_tmp30_ = submarine_language_info_get_long_code_alt (_tmp29_);
				_tmp31_ = _tmp30_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp28_, _tmp31_);
			}
			_submarine_language_info_free0 (language_info);
			_g_free0 (language);
		}
		_g_object_unref0 (_language_it);
	}
	_tmp32_ = languages_set;
	_tmp34_ = gee_collection_to_array ((GeeCollection*) _tmp32_, &_tmp33_);
	languages_array = _tmp34_;
	languages_array_length1 = _tmp33_;
	_languages_array_size_ = languages_array_length1;
	_tmp35_ = (languages_array != NULL) ? _vala_array_dup2 (languages_array, languages_array_length1) : ((gpointer) languages_array);
	_tmp35__length1 = languages_array_length1;
	languages_array_copy = _tmp35_;
	languages_array_copy_length1 = _tmp35__length1;
	_languages_array_copy_size_ = languages_array_copy_length1;
	_tmp36_ = _vala_g_strjoinv (",", languages_array_copy, languages_array_copy_length1);
	result = _tmp36_;
	languages_array_copy = (_vala_array_free (languages_array_copy, languages_array_copy_length1, (GDestroyNotify) g_free), NULL);
	languages_array = (_vala_array_free (languages_array, languages_array_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (languages_set);
	return result;
}


static guint64 submarine_open_subtitles_server_file_size (SubmarineOpenSubtitlesServer* self, GFile* file, GError** error) {
	guint64 result = 0ULL;
	GFileInfo* file_info = NULL;
	GFile* _tmp0_ = NULL;
	GFileInfo* _tmp1_ = NULL;
	gint64 _tmp2_ = 0LL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	g_return_val_if_fail (file != NULL, 0ULL);
	_tmp0_ = file;
	_tmp1_ = g_file_query_info (_tmp0_, "*", G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
	file_info = _tmp1_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return 0ULL;
	}
	_tmp2_ = g_file_info_get_size (file_info);
	result = (guint64) _tmp2_;
	_g_object_unref0 (file_info);
	return result;
}


static guint64 submarine_open_subtitles_server_file_hash (SubmarineOpenSubtitlesServer* self, GFile* file, GError** error) {
	guint64 result = 0ULL;
	guint64 hash = 0ULL;
	guint64 size = 0ULL;
	guint64 _tmp0_ = 0ULL;
	GFile* _tmp1_ = NULL;
	guint64 _tmp2_ = 0ULL;
	guint64 _tmp3_ = 0ULL;
	GFileInputStream* _tmp4_ = NULL;
	GFile* _tmp5_ = NULL;
	GFileInputStream* _tmp6_ = NULL;
	GDataInputStream* dis = NULL;
	GDataInputStream* _tmp7_ = NULL;
	GDataInputStream* _tmp8_ = NULL;
	GFileInputStream* _tmp16_ = NULL;
	GFile* _tmp17_ = NULL;
	GFileInputStream* _tmp18_ = NULL;
	GDataInputStream* _tmp19_ = NULL;
	GDataInputStream* _tmp20_ = NULL;
	GDataInputStream* _tmp21_ = NULL;
	guint64 _tmp22_ = 0ULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	g_return_val_if_fail (file != NULL, 0ULL);
	_tmp1_ = file;
	_tmp2_ = submarine_open_subtitles_server_file_size (self, _tmp1_, &_inner_error_);
	_tmp0_ = _tmp2_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return 0ULL;
	}
	size = _tmp0_;
	_tmp3_ = size;
	hash = _tmp3_;
	_tmp5_ = file;
	_tmp6_ = g_file_read (_tmp5_, NULL, &_inner_error_);
	_tmp4_ = _tmp6_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return 0ULL;
	}
	_tmp7_ = g_data_input_stream_new ((GInputStream*) _tmp4_);
	dis = _tmp7_;
	_tmp8_ = dis;
	g_data_input_stream_set_byte_order (_tmp8_, G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp9_ = FALSE;
			_tmp9_ = TRUE;
			while (TRUE) {
				gint _tmp11_ = 0;
				guint64 _tmp12_ = 0ULL;
				GDataInputStream* _tmp13_ = NULL;
				guint64 _tmp14_ = 0ULL;
				guint64 _tmp15_ = 0ULL;
				if (!_tmp9_) {
					gint _tmp10_ = 0;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp11_ = i;
				if (!(((gulong) _tmp11_) < (65536 / sizeof (guint64)))) {
					break;
				}
				_tmp13_ = dis;
				_tmp14_ = g_data_input_stream_read_uint64 (_tmp13_, NULL, &_inner_error_);
				_tmp12_ = _tmp14_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (dis);
					_g_object_unref0 (_tmp4_);
					return 0ULL;
				}
				_tmp15_ = hash;
				hash = _tmp15_ + _tmp12_;
			}
		}
	}
	_tmp17_ = file;
	_tmp18_ = g_file_read (_tmp17_, NULL, &_inner_error_);
	_tmp16_ = _tmp18_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp4_);
		return 0ULL;
	}
	_tmp19_ = g_data_input_stream_new ((GInputStream*) _tmp16_);
	_g_object_unref0 (dis);
	dis = _tmp19_;
	_tmp20_ = dis;
	g_data_input_stream_set_byte_order (_tmp20_, G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN);
	_tmp21_ = dis;
	_tmp22_ = size;
	g_input_stream_skip ((GInputStream*) _tmp21_, (gsize) (_tmp22_ - 65536), NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (_tmp16_);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp4_);
		return 0ULL;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp23_ = FALSE;
			_tmp23_ = TRUE;
			while (TRUE) {
				gint _tmp25_ = 0;
				guint64 _tmp26_ = 0ULL;
				GDataInputStream* _tmp27_ = NULL;
				guint64 _tmp28_ = 0ULL;
				guint64 _tmp29_ = 0ULL;
				if (!_tmp23_) {
					gint _tmp24_ = 0;
					_tmp24_ = i;
					i = _tmp24_ + 1;
				}
				_tmp23_ = FALSE;
				_tmp25_ = i;
				if (!(((gulong) _tmp25_) < (65536 / sizeof (guint64)))) {
					break;
				}
				_tmp27_ = dis;
				_tmp28_ = g_data_input_stream_read_uint64 (_tmp27_, NULL, &_inner_error_);
				_tmp26_ = _tmp28_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (_tmp16_);
					_g_object_unref0 (dis);
					_g_object_unref0 (_tmp4_);
					return 0ULL;
				}
				_tmp29_ = hash;
				hash = _tmp29_ + _tmp26_;
			}
		}
	}
	result = hash;
	_g_object_unref0 (_tmp16_);
	_g_object_unref0 (dis);
	_g_object_unref0 (_tmp4_);
	return result;
}


static guint8* _vala_array_dup3 (guint8* self, int length) {
	return g_memdup (self, length * sizeof (guint8));
}


static void* _g_realloc_grealloc_func (void* data, gsize size) {
	void* result;
	result = g_realloc (data, size);
	return result;
}


static void _g_free_gdestroy_notify (void* data) {
	g_free (data);
}


static gchar* submarine_open_subtitles_server_inflate_subtitle (SubmarineOpenSubtitlesServer* self, guint8* data, int data_length1, GError** error) {
	gchar* result = NULL;
	GMemoryInputStream* src_stream = NULL;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	GMemoryInputStream* _tmp2_ = NULL;
	GMemoryOutputStream* dst_stream = NULL;
	GMemoryOutputStream* _tmp3_ = NULL;
	GConverterOutputStream* conv_stream = NULL;
	GZlibDecompressor* _tmp4_ = NULL;
	GZlibDecompressor* _tmp5_ = NULL;
	GConverterOutputStream* _tmp6_ = NULL;
	GConverterOutputStream* _tmp7_ = NULL;
	guint8* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = data;
	_tmp0__length1 = data_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup3 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	_tmp2_ = (GMemoryInputStream*) g_memory_input_stream_new_from_data (_tmp1_, _tmp1__length1, NULL);
	src_stream = _tmp2_;
	_tmp3_ = (GMemoryOutputStream*) g_memory_output_stream_new (NULL, 0, _g_realloc_grealloc_func, _g_free_gdestroy_notify);
	dst_stream = _tmp3_;
	_tmp4_ = g_zlib_decompressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP);
	_tmp5_ = _tmp4_;
	_tmp6_ = (GConverterOutputStream*) g_converter_output_stream_new ((GOutputStream*) dst_stream, (GConverter*) _tmp5_);
	_tmp7_ = _tmp6_;
	_g_object_unref0 (_tmp5_);
	conv_stream = _tmp7_;
	g_output_stream_splice ((GOutputStream*) conv_stream, (GInputStream*) src_stream, 0, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if (_inner_error_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (conv_stream);
			_g_object_unref0 (dst_stream);
			_g_object_unref0 (src_stream);
			return NULL;
		} else {
			_g_object_unref0 (conv_stream);
			_g_object_unref0 (dst_stream);
			_g_object_unref0 (src_stream);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp8_ = g_memory_output_stream_get_data (dst_stream);
	_tmp9_ = g_strdup ((const gchar*) _tmp8_);
	result = _tmp9_;
	_g_object_unref0 (conv_stream);
	_g_object_unref0 (dst_stream);
	_g_object_unref0 (src_stream);
	return result;
}


static gboolean submarine_open_subtitles_server_real_connect (SubmarineSubtitleServer* base) {
	SubmarineOpenSubtitlesServer * self;
	gboolean result = FALSE;
	static const char username[] = "";
	static const char password[] = "";
	GHashTable* vh = NULL;
	SoupSessionSync* _tmp0_ = NULL;
	SoupMessage* message = NULL;
	SoupMessage* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	SoupSessionSync* _tmp3_ = NULL;
	SoupMessage* _tmp4_ = NULL;
	GHashTable* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	self = (SubmarineOpenSubtitlesServer*) base;
	_tmp0_ = (SoupSessionSync*) soup_session_sync_new ();
	_g_object_unref0 (self->priv->session);
	self->priv->session = _tmp0_;
	_tmp1_ = soup_xmlrpc_request_new (SUBMARINE_OPEN_SUBTITLES_SERVER_XMLRPC_URI, "LogIn", G_TYPE_STRING, username, G_TYPE_STRING, password, G_TYPE_STRING, "", G_TYPE_STRING, "submarine v0.16", G_TYPE_INVALID);
	message = _tmp1_;
	_tmp3_ = self->priv->session;
	_tmp4_ = message;
	_tmp6_ = submarine_xmlrpc_call ((SoupSession*) _tmp3_, _tmp4_, &_tmp5_, NULL);
	_g_hash_table_unref0 (vh);
	vh = _tmp5_;
	if (_tmp6_) {
		GHashTable* _tmp7_ = NULL;
		gconstpointer _tmp8_ = NULL;
		_tmp7_ = vh;
		_tmp8_ = g_hash_table_lookup (_tmp7_, "status");
		_tmp2_ = g_strcmp0 (g_value_get_string ((GValue*) _tmp8_), "200 OK") == 0;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		GHashTable* _tmp9_ = NULL;
		gconstpointer _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		_tmp9_ = vh;
		_tmp10_ = g_hash_table_lookup (_tmp9_, "token");
		_tmp11_ = g_strdup (g_value_get_string ((GValue*) _tmp10_));
		_g_free0 (self->priv->session_token);
		self->priv->session_token = _tmp11_;
		result = TRUE;
		_g_object_unref0 (message);
		_g_hash_table_unref0 (vh);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (message);
	_g_hash_table_unref0 (vh);
	return result;
}


static void submarine_open_subtitles_server_real_disconnect (SubmarineSubtitleServer* base) {
	SubmarineOpenSubtitlesServer * self;
	const gchar* _tmp0_ = NULL;
	SoupMessage* _tmp1_ = NULL;
	SoupMessage* _tmp2_ = NULL;
	self = (SubmarineOpenSubtitlesServer*) base;
	_tmp0_ = self->priv->session_token;
	_tmp1_ = soup_xmlrpc_request_new (SUBMARINE_OPEN_SUBTITLES_SERVER_XMLRPC_URI, "LogOut", G_TYPE_STRING, _tmp0_, G_TYPE_INVALID);
	_tmp2_ = _tmp1_;
	_g_object_unref0 (_tmp2_);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		SubmarineOpenSubtitlesServer* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->hash_file);
		_g_object_unref0 (_data1_->subtitles_found_map);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static GValue* _g_value_dup (GValue* self) {
	return g_boxed_copy (G_TYPE_VALUE, self);
}


static void _vala_GValue_free (GValue* self) {
	g_value_unset (self);
	g_free (self);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void __vala_GValue_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (_vala_GValue_free (var), NULL));
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer __g_value_dup0 (gpointer self) {
	return self ? _g_value_dup (self) : NULL;
}


static GValue* __lambda5_ (SubmarineOpenSubtitlesServer* self, GeeList* request_batch) {
	GValue* result = NULL;
	GValueArray* values = NULL;
	GeeList* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GValueArray* _tmp3_ = NULL;
	SoupMessage* message = NULL;
	const gchar* _tmp18_ = NULL;
	GValueArray* _tmp19_ = NULL;
	SoupMessage* _tmp20_ = NULL;
	GValue v = {0};
	gboolean _tmp21_ = FALSE;
	SoupSessionSync* _tmp22_ = NULL;
	SoupMessage* _tmp23_ = NULL;
	GHashTable* _tmp24_ = NULL;
	gboolean _tmp25_ = FALSE;
	GValue _tmp26_ = {0};
	g_return_val_if_fail (request_batch != NULL, NULL);
	_tmp0_ = request_batch;
	_tmp1_ = gee_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_value_array_new ((guint) _tmp2_);
	values = _tmp3_;
	{
		GeeList* _request_list = NULL;
		GeeList* _tmp4_ = NULL;
		GeeList* _tmp5_ = NULL;
		gint _request_size = 0;
		GeeList* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		gint _request_index = 0;
		_tmp4_ = request_batch;
		_tmp5_ = _g_object_ref0 (_tmp4_);
		_request_list = _tmp5_;
		_tmp6_ = _request_list;
		_tmp7_ = gee_collection_get_size ((GeeCollection*) _tmp6_);
		_tmp8_ = _tmp7_;
		_request_size = _tmp8_;
		_request_index = -1;
		while (TRUE) {
			gint _tmp9_ = 0;
			gint _tmp10_ = 0;
			gint _tmp11_ = 0;
			GValue* request = NULL;
			GeeList* _tmp12_ = NULL;
			gint _tmp13_ = 0;
			gpointer _tmp14_ = NULL;
			GValueArray* _tmp15_ = NULL;
			GValue* _tmp16_ = NULL;
			GValue _tmp17_ = {0};
			_tmp9_ = _request_index;
			_request_index = _tmp9_ + 1;
			_tmp10_ = _request_index;
			_tmp11_ = _request_size;
			if (!(_tmp10_ < _tmp11_)) {
				break;
			}
			_tmp12_ = _request_list;
			_tmp13_ = _request_index;
			_tmp14_ = gee_list_get (_tmp12_, _tmp13_);
			request = (GValue*) _tmp14_;
			_tmp15_ = values;
			_tmp16_ = request;
			_tmp17_ = *_tmp16_;
			g_value_array_append (_tmp15_, &_tmp17_);
			__vala_GValue_free0 (request);
		}
		_g_object_unref0 (_request_list);
	}
	_tmp18_ = self->priv->session_token;
	_tmp19_ = values;
	_tmp20_ = soup_xmlrpc_request_new (SUBMARINE_OPEN_SUBTITLES_SERVER_XMLRPC_URI, "SearchSubtitles", G_TYPE_STRING, _tmp18_, G_TYPE_VALUE_ARRAY, _tmp19_, G_TYPE_INVALID);
	message = _tmp20_;
	_tmp22_ = self->priv->session;
	_tmp23_ = message;
	_tmp25_ = submarine_xmlrpc_call ((SoupSession*) _tmp22_, _tmp23_, &_tmp24_, NULL);
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
	g_value_init (&_tmp26_, G_TYPE_HASH_TABLE);
	g_value_take_boxed (&_tmp26_, _tmp24_);
	v = _tmp26_;
	if (_tmp25_) {
		GValue _tmp27_ = {0};
		gconstpointer _tmp28_ = NULL;
		_tmp27_ = v;
		_tmp28_ = g_hash_table_lookup (g_value_get_boxed (&_tmp27_), "status");
		_tmp21_ = g_strcmp0 (g_value_get_string ((GValue*) _tmp28_), "200 OK") == 0;
	} else {
		_tmp21_ = FALSE;
	}
	if (_tmp21_) {
		GValue _tmp29_ = {0};
		GValue* _tmp30_ = NULL;
		GValue* _tmp31_ = NULL;
		_tmp29_ = v;
		_tmp30_ = __g_value_dup0 (&_tmp29_);
		_tmp31_ = _tmp30_;
		G_IS_VALUE (&_tmp29_) ? (g_value_unset (&_tmp29_), NULL) : NULL;
		result = _tmp31_;
		_g_object_unref0 (message);
		_g_value_array_free0 (values);
		return result;
	}
	result = NULL;
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
	_g_object_unref0 (message);
	_g_value_array_free0 (values);
	return result;
}


static GValue* ___lambda5__submarine_subtitle_server_batch_request_method (GeeList* request_batch, gpointer self) {
	GValue* result;
	result = __lambda5_ ((SubmarineOpenSubtitlesServer*) self, request_batch);
	return result;
}


static gdouble double_parse (const gchar* str) {
	gdouble result = 0.0;
	const gchar* _tmp0_ = NULL;
	gdouble _tmp1_ = 0.0;
	g_return_val_if_fail (str != NULL, 0.0);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtod (_tmp0_, NULL);
	result = _tmp1_;
	return result;
}


static gint __lambda6_ (Block1Data* _data1_, GValue* response) {
	SubmarineOpenSubtitlesServer* self;
	gint result = 0;
	GHashTable* vh = NULL;
	GValue _tmp0_ = {0};
	GHashTable* _tmp1_ = NULL;
	gint results = 0;
	GHashTable* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	GValue _tmp4_ = {0};
	GType _tmp5_ = 0UL;
	self = _data1_->self;
	g_return_val_if_fail (response != NULL, 0);
	_tmp0_ = *response;
	_tmp1_ = _g_hash_table_ref0 (g_value_get_boxed (&_tmp0_));
	vh = _tmp1_;
	results = 0;
	_tmp2_ = vh;
	_tmp3_ = g_hash_table_lookup (_tmp2_, "data");
	_tmp4_ = *((GValue*) _tmp3_);
	_tmp5_ = G_VALUE_TYPE (&_tmp4_);
	if (_tmp5_ != G_TYPE_BOOLEAN) {
		GValueArray* va = NULL;
		GValue _tmp6_ = {0};
		gconstpointer _tmp7_ = NULL;
		GValueArray* _tmp8_ = NULL;
		_tmp6_ = *response;
		_tmp7_ = g_hash_table_lookup (g_value_get_boxed (&_tmp6_), "data");
		va = g_value_get_boxed ((GValue*) _tmp7_);
		_tmp8_ = va;
		{
			GValueArray* vresult_collection = NULL;
			guint vresult_index = 0U;
			vresult_collection = _tmp8_;
			for (vresult_index = 0; vresult_index < vresult_collection->n_values; vresult_index = vresult_index + 1) {
				GValue _tmp9_ = {0};
				GValue vresult = {0};
				if (G_IS_VALUE (g_value_array_get_nth (vresult_collection, vresult_index))) {
					g_value_init (&_tmp9_, G_VALUE_TYPE (g_value_array_get_nth (vresult_collection, vresult_index)));
					g_value_copy (g_value_array_get_nth (vresult_collection, vresult_index), &_tmp9_);
				} else {
					_tmp9_ = *g_value_array_get_nth (vresult_collection, vresult_index);
				}
				vresult = _tmp9_;
				{
					GHashTable* _result_ = NULL;
					GValue _tmp10_ = {0};
					GHashTable* _tmp11_ = NULL;
					SubmarineSubtitle* subtitle = NULL;
					SubmarineServerInfo _tmp12_ = {0};
					SubmarineServerInfo _tmp13_ = {0};
					GHashTable* _tmp14_ = NULL;
					GValue _tmp15_ = {0};
					SubmarineSubtitle* _tmp16_ = NULL;
					SubmarineSubtitle* _tmp17_ = NULL;
					SubmarineSubtitle* _tmp18_ = NULL;
					GHashTable* _tmp19_ = NULL;
					gconstpointer _tmp20_ = NULL;
					SubmarineSubtitle* _tmp21_ = NULL;
					GHashTable* _tmp22_ = NULL;
					gconstpointer _tmp23_ = NULL;
					SubmarineSubtitle* _tmp24_ = NULL;
					GHashTable* _tmp25_ = NULL;
					gconstpointer _tmp26_ = NULL;
					gdouble _tmp27_ = 0.0;
					FILE* _tmp28_ = NULL;
					SubmarineSubtitle* _tmp29_ = NULL;
					gdouble _tmp30_ = 0.0;
					gdouble _tmp31_ = 0.0;
					GeeHashMultiMap* _tmp32_ = NULL;
					GeeHashMap* _tmp33_ = NULL;
					GHashTable* _tmp34_ = NULL;
					gconstpointer _tmp35_ = NULL;
					gpointer _tmp36_ = NULL;
					GFile* _tmp37_ = NULL;
					SubmarineSubtitle* _tmp38_ = NULL;
					gint _tmp39_ = 0;
					_tmp10_ = vresult;
					_tmp11_ = _g_hash_table_ref0 (g_value_get_boxed (&_tmp10_));
					_result_ = _tmp11_;
					submarine_subtitle_server_get_info ((SubmarineSubtitleServer*) self, &_tmp12_);
					_tmp13_ = _tmp12_;
					_tmp14_ = _result_;
					g_value_init (&_tmp15_, G_TYPE_HASH_TABLE);
					g_value_set_boxed (&_tmp15_, _tmp14_);
					_tmp16_ = submarine_subtitle_new (&_tmp13_, &_tmp15_);
					_tmp17_ = _tmp16_;
					G_IS_VALUE (&_tmp15_) ? (g_value_unset (&_tmp15_), NULL) : NULL;
					subtitle = _tmp17_;
					_tmp18_ = subtitle;
					_tmp19_ = _result_;
					_tmp20_ = g_hash_table_lookup (_tmp19_, "SubFormat");
					submarine_subtitle_set_format (_tmp18_, g_value_get_string ((GValue*) _tmp20_));
					_tmp21_ = subtitle;
					_tmp22_ = _result_;
					_tmp23_ = g_hash_table_lookup (_tmp22_, "ISO639");
					submarine_subtitle_set_language (_tmp21_, g_value_get_string ((GValue*) _tmp23_));
					_tmp24_ = subtitle;
					_tmp25_ = _result_;
					_tmp26_ = g_hash_table_lookup (_tmp25_, "SubRating");
					_tmp27_ = double_parse (g_value_get_string ((GValue*) _tmp26_));
					submarine_subtitle_set_rating (_tmp24_, _tmp27_);
					_tmp28_ = stdout;
					_tmp29_ = subtitle;
					_tmp30_ = submarine_subtitle_get_rating (_tmp29_);
					_tmp31_ = _tmp30_;
					fprintf (_tmp28_, "open subtitles rating: %f\n", _tmp31_);
					_tmp32_ = _data1_->subtitles_found_map;
					_tmp33_ = _data1_->hash_file;
					_tmp34_ = _result_;
					_tmp35_ = g_hash_table_lookup (_tmp34_, "MovieHash");
					_tmp36_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp33_, g_value_get_string ((GValue*) _tmp35_));
					_tmp37_ = (GFile*) _tmp36_;
					_tmp38_ = subtitle;
					gee_multi_map_set ((GeeMultiMap*) _tmp32_, _tmp37_, _tmp38_);
					_g_object_unref0 (_tmp37_);
					_tmp39_ = results;
					results = _tmp39_ + 1;
					_submarine_subtitle_unref0 (subtitle);
					_g_hash_table_unref0 (_result_);
					G_IS_VALUE (&vresult) ? (g_value_unset (&vresult), NULL) : NULL;
				}
			}
		}
	}
	result = results;
	_g_hash_table_unref0 (vh);
	return result;
}


static gint ___lambda6__submarine_subtitle_server_batch_response_method (GValue* response, gpointer self) {
	gint result;
	result = __lambda6_ (self, response);
	return result;
}


static GeeMultiMap* submarine_open_subtitles_server_real_search_multiple (SubmarineSubtitleServer* base, GeeCollection* files, GeeCollection* languages) {
	SubmarineOpenSubtitlesServer * self;
	GeeMultiMap* result = NULL;
	Block1Data* _data1_;
	GeeHashMultiMap* _tmp0_ = NULL;
	GeeArrayList* requests = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeHashMap* _tmp2_ = NULL;
	static const gint MAX = 500;
	static const gint HITS = 5;
	gchar* codes = NULL;
	GeeCollection* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	SubmarineSubtitleServerBatchRequestMethod request_method = NULL;
	void* request_method_target = NULL;
	GDestroyNotify request_method_target_destroy_notify = NULL;
	SubmarineSubtitleServerBatchResponseMethod response_method = NULL;
	void* response_method_target = NULL;
	GDestroyNotify response_method_target_destroy_notify = NULL;
	GeeArrayList* _tmp38_ = NULL;
	GeeArrayList* _tmp39_ = NULL;
	GeeArrayList* _tmp40_ = NULL;
	GeeHashMultiMap* _tmp41_ = NULL;
	GeeMultiMap* _tmp42_ = NULL;
	GError * _inner_error_ = NULL;
	self = (SubmarineOpenSubtitlesServer*) base;
	g_return_val_if_fail (files != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = gee_hash_multi_map_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_data1_->subtitles_found_map = _tmp0_;
	_tmp1_ = gee_array_list_new (G_TYPE_VALUE, (GBoxedCopyFunc) _g_value_dup, _vala_GValue_free, NULL, NULL, NULL);
	requests = _tmp1_;
	_tmp2_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_data1_->hash_file = _tmp2_;
	_tmp3_ = languages;
	_tmp4_ = submarine_open_subtitles_server_language_codes_string (self, _tmp3_);
	codes = _tmp4_;
	{
		GeeIterator* _file_it = NULL;
		GeeCollection* _tmp5_ = NULL;
		GeeIterator* _tmp6_ = NULL;
		_tmp5_ = files;
		_tmp6_ = gee_iterable_iterator ((GeeIterable*) _tmp5_);
		_file_it = _tmp6_;
		while (TRUE) {
			GeeIterator* _tmp7_ = NULL;
			gboolean _tmp8_ = FALSE;
			GFile* file = NULL;
			GeeIterator* _tmp9_ = NULL;
			gpointer _tmp10_ = NULL;
			_tmp7_ = _file_it;
			_tmp8_ = gee_iterator_next (_tmp7_);
			if (!_tmp8_) {
				break;
			}
			_tmp9_ = _file_it;
			_tmp10_ = gee_iterator_get (_tmp9_);
			file = (GFile*) _tmp10_;
			{
				guint64 _tmp11_ = 0ULL;
				GFile* _tmp12_ = NULL;
				guint64 _tmp13_ = 0ULL;
				gchar* hash = NULL;
				gchar* _tmp14_ = NULL;
				gdouble size = 0.0;
				GFile* _tmp15_ = NULL;
				guint64 _tmp16_ = 0ULL;
				GHashTable* request = NULL;
				GHashFunc _tmp17_ = NULL;
				GEqualFunc _tmp18_ = NULL;
				GHashTable* _tmp19_ = NULL;
				GHashTable* _tmp20_ = NULL;
				gchar* _tmp21_ = NULL;
				const gchar* _tmp22_ = NULL;
				GValue* _tmp23_ = NULL;
				GHashTable* _tmp24_ = NULL;
				gchar* _tmp25_ = NULL;
				const gchar* _tmp26_ = NULL;
				GValue* _tmp27_ = NULL;
				GHashTable* _tmp28_ = NULL;
				gchar* _tmp29_ = NULL;
				gdouble _tmp30_ = 0.0;
				GValue* _tmp31_ = NULL;
				GeeArrayList* _tmp32_ = NULL;
				GHashTable* _tmp33_ = NULL;
				GValue* _tmp34_ = NULL;
				GeeHashMap* _tmp35_ = NULL;
				const gchar* _tmp36_ = NULL;
				GFile* _tmp37_ = NULL;
				_tmp12_ = file;
				_tmp13_ = submarine_open_subtitles_server_file_hash (self, _tmp12_, &_inner_error_);
				_tmp11_ = _tmp13_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch7_g_error;
				}
				_tmp14_ = g_strdup_printf ("%016llx", _tmp11_);
				hash = _tmp14_;
				_tmp15_ = file;
				_tmp16_ = submarine_open_subtitles_server_file_size (self, _tmp15_, &_inner_error_);
				size = (gdouble) _tmp16_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_free0 (hash);
					goto __catch7_g_error;
				}
				_tmp17_ = g_str_hash;
				_tmp18_ = g_str_equal;
				_tmp19_ = g_hash_table_new_full (_tmp17_, _tmp18_, _g_free0_, __vala_GValue_free0_);
				request = _tmp19_;
				_tmp20_ = request;
				_tmp21_ = g_strdup ("sublanguageid");
				_tmp22_ = codes;
				_tmp23_ = g_new0 (GValue, 1);
				g_value_init (_tmp23_, G_TYPE_STRING);
				g_value_set_string (_tmp23_, _tmp22_);
				g_hash_table_insert (_tmp20_, _tmp21_, _tmp23_);
				_tmp24_ = request;
				_tmp25_ = g_strdup ("moviehash");
				_tmp26_ = hash;
				_tmp27_ = g_new0 (GValue, 1);
				g_value_init (_tmp27_, G_TYPE_STRING);
				g_value_set_string (_tmp27_, _tmp26_);
				g_hash_table_insert (_tmp24_, _tmp25_, _tmp27_);
				_tmp28_ = request;
				_tmp29_ = g_strdup ("moviebytesize");
				_tmp30_ = size;
				_tmp31_ = g_new0 (GValue, 1);
				g_value_init (_tmp31_, G_TYPE_DOUBLE);
				g_value_set_double (_tmp31_, _tmp30_);
				g_hash_table_insert (_tmp28_, _tmp29_, _tmp31_);
				_tmp32_ = requests;
				_tmp33_ = request;
				_tmp34_ = g_new0 (GValue, 1);
				g_value_init (_tmp34_, G_TYPE_HASH_TABLE);
				g_value_set_boxed (_tmp34_, _tmp33_);
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp32_, _tmp34_);
				__vala_GValue_free0 (_tmp34_);
				_tmp35_ = _data1_->hash_file;
				_tmp36_ = hash;
				_tmp37_ = file;
				gee_abstract_map_set ((GeeAbstractMap*) _tmp35_, _tmp36_, _tmp37_);
				_g_hash_table_unref0 (request);
				_g_free0 (hash);
			}
			goto __finally7;
			__catch7_g_error:
			{
				GError* e = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				_g_error_free0 (e);
			}
			__finally7:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file);
				_g_object_unref0 (_file_it);
				_g_free0 (codes);
				_g_object_unref0 (requests);
				block1_data_unref (_data1_);
				_data1_ = NULL;
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
			_g_object_unref0 (file);
		}
		_g_object_unref0 (_file_it);
	}
	request_method = ___lambda5__submarine_subtitle_server_batch_request_method;
	request_method_target = g_object_ref (self);
	request_method_target_destroy_notify = g_object_unref;
	response_method = ___lambda6__submarine_subtitle_server_batch_response_method;
	response_method_target = block1_data_ref (_data1_);
	response_method_target_destroy_notify = block1_data_unref;
	_tmp38_ = requests;
	_tmp39_ = submarine_subtitle_server_batch_process ((SubmarineSubtitleServer*) self, (GeeList*) _tmp38_, request_method, request_method_target, response_method, response_method_target, MAX / HITS, MAX);
	_tmp40_ = _tmp39_;
	_g_object_unref0 (_tmp40_);
	_tmp41_ = _data1_->subtitles_found_map;
	_tmp42_ = _g_object_ref0 ((GeeMultiMap*) _tmp41_);
	result = _tmp42_;
	(response_method_target_destroy_notify == NULL) ? NULL : (response_method_target_destroy_notify (response_method_target), NULL);
	response_method = NULL;
	response_method_target = NULL;
	response_method_target_destroy_notify = NULL;
	(request_method_target_destroy_notify == NULL) ? NULL : (request_method_target_destroy_notify (request_method_target), NULL);
	request_method = NULL;
	request_method_target = NULL;
	request_method_target_destroy_notify = NULL;
	_g_free0 (codes);
	_g_object_unref0 (requests);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		SubmarineOpenSubtitlesServer* self;
		self = _data2_->self;
		_g_object_unref0 (_data2_->id_map);
		_g_object_unref0 (_data2_->subtitles_downloaded);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static GValue* __lambda7_ (SubmarineOpenSubtitlesServer* self, GeeList* request_batch) {
	GValue* result = NULL;
	GValueArray* values = NULL;
	GeeList* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GValueArray* _tmp3_ = NULL;
	SoupMessage* message = NULL;
	const gchar* _tmp18_ = NULL;
	GValueArray* _tmp19_ = NULL;
	SoupMessage* _tmp20_ = NULL;
	GValue v = {0};
	gboolean _tmp21_ = FALSE;
	SoupSessionSync* _tmp22_ = NULL;
	SoupMessage* _tmp23_ = NULL;
	GHashTable* _tmp24_ = NULL;
	gboolean _tmp25_ = FALSE;
	GValue _tmp26_ = {0};
	g_return_val_if_fail (request_batch != NULL, NULL);
	_tmp0_ = request_batch;
	_tmp1_ = gee_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_value_array_new ((guint) _tmp2_);
	values = _tmp3_;
	{
		GeeList* _request_list = NULL;
		GeeList* _tmp4_ = NULL;
		GeeList* _tmp5_ = NULL;
		gint _request_size = 0;
		GeeList* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		gint _request_index = 0;
		_tmp4_ = request_batch;
		_tmp5_ = _g_object_ref0 (_tmp4_);
		_request_list = _tmp5_;
		_tmp6_ = _request_list;
		_tmp7_ = gee_collection_get_size ((GeeCollection*) _tmp6_);
		_tmp8_ = _tmp7_;
		_request_size = _tmp8_;
		_request_index = -1;
		while (TRUE) {
			gint _tmp9_ = 0;
			gint _tmp10_ = 0;
			gint _tmp11_ = 0;
			GValue* request = NULL;
			GeeList* _tmp12_ = NULL;
			gint _tmp13_ = 0;
			gpointer _tmp14_ = NULL;
			GValueArray* _tmp15_ = NULL;
			GValue* _tmp16_ = NULL;
			GValue _tmp17_ = {0};
			_tmp9_ = _request_index;
			_request_index = _tmp9_ + 1;
			_tmp10_ = _request_index;
			_tmp11_ = _request_size;
			if (!(_tmp10_ < _tmp11_)) {
				break;
			}
			_tmp12_ = _request_list;
			_tmp13_ = _request_index;
			_tmp14_ = gee_list_get (_tmp12_, _tmp13_);
			request = (GValue*) _tmp14_;
			_tmp15_ = values;
			_tmp16_ = request;
			_tmp17_ = *_tmp16_;
			g_value_array_append (_tmp15_, &_tmp17_);
			__vala_GValue_free0 (request);
		}
		_g_object_unref0 (_request_list);
	}
	_tmp18_ = self->priv->session_token;
	_tmp19_ = values;
	_tmp20_ = soup_xmlrpc_request_new (SUBMARINE_OPEN_SUBTITLES_SERVER_XMLRPC_URI, "DownloadSubtitles", G_TYPE_STRING, _tmp18_, G_TYPE_VALUE_ARRAY, _tmp19_, G_TYPE_INVALID);
	message = _tmp20_;
	_tmp22_ = self->priv->session;
	_tmp23_ = message;
	_tmp25_ = submarine_xmlrpc_call ((SoupSession*) _tmp22_, _tmp23_, &_tmp24_, NULL);
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
	g_value_init (&_tmp26_, G_TYPE_HASH_TABLE);
	g_value_take_boxed (&_tmp26_, _tmp24_);
	v = _tmp26_;
	if (_tmp25_) {
		GValue _tmp27_ = {0};
		gconstpointer _tmp28_ = NULL;
		_tmp27_ = v;
		_tmp28_ = g_hash_table_lookup (g_value_get_boxed (&_tmp27_), "status");
		_tmp21_ = g_strcmp0 (g_value_get_string ((GValue*) _tmp28_), "200 OK") == 0;
	} else {
		_tmp21_ = FALSE;
	}
	if (_tmp21_) {
		GValue _tmp29_ = {0};
		GValue* _tmp30_ = NULL;
		GValue* _tmp31_ = NULL;
		_tmp29_ = v;
		_tmp30_ = __g_value_dup0 (&_tmp29_);
		_tmp31_ = _tmp30_;
		G_IS_VALUE (&_tmp29_) ? (g_value_unset (&_tmp29_), NULL) : NULL;
		result = _tmp31_;
		_g_object_unref0 (message);
		_g_value_array_free0 (values);
		return result;
	}
	result = NULL;
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
	_g_object_unref0 (message);
	_g_value_array_free0 (values);
	return result;
}


static GValue* ___lambda7__submarine_subtitle_server_batch_request_method (GeeList* request_batch, gpointer self) {
	GValue* result;
	result = __lambda7_ ((SubmarineOpenSubtitlesServer*) self, request_batch);
	return result;
}


static gint __lambda8_ (Block2Data* _data2_, GValue* response) {
	SubmarineOpenSubtitlesServer* self;
	gint result = 0;
	GHashTable* vh = NULL;
	GValue _tmp0_ = {0};
	GHashTable* _tmp1_ = NULL;
	gint results = 0;
	GHashTable* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	GValue _tmp4_ = {0};
	GType _tmp5_ = 0UL;
	GError * _inner_error_ = NULL;
	self = _data2_->self;
	g_return_val_if_fail (response != NULL, 0);
	_tmp0_ = *response;
	_tmp1_ = _g_hash_table_ref0 (g_value_get_boxed (&_tmp0_));
	vh = _tmp1_;
	results = 0;
	_tmp2_ = vh;
	_tmp3_ = g_hash_table_lookup (_tmp2_, "data");
	_tmp4_ = *((GValue*) _tmp3_);
	_tmp5_ = G_VALUE_TYPE (&_tmp4_);
	if (_tmp5_ != G_TYPE_BOOLEAN) {
		GValueArray* va = NULL;
		GValue _tmp6_ = {0};
		gconstpointer _tmp7_ = NULL;
		GValueArray* _tmp8_ = NULL;
		_tmp6_ = *response;
		_tmp7_ = g_hash_table_lookup (g_value_get_boxed (&_tmp6_), "data");
		va = g_value_get_boxed ((GValue*) _tmp7_);
		_tmp8_ = va;
		{
			GValueArray* vresult_collection = NULL;
			guint vresult_index = 0U;
			vresult_collection = _tmp8_;
			for (vresult_index = 0; vresult_index < vresult_collection->n_values; vresult_index = vresult_index + 1) {
				GValue _tmp9_ = {0};
				GValue vresult = {0};
				if (G_IS_VALUE (g_value_array_get_nth (vresult_collection, vresult_index))) {
					g_value_init (&_tmp9_, G_VALUE_TYPE (g_value_array_get_nth (vresult_collection, vresult_index)));
					g_value_copy (g_value_array_get_nth (vresult_collection, vresult_index), &_tmp9_);
				} else {
					_tmp9_ = *g_value_array_get_nth (vresult_collection, vresult_index);
				}
				vresult = _tmp9_;
				{
					GHashTable* _result_ = NULL;
					GValue _tmp10_ = {0};
					GHashTable* _tmp11_ = NULL;
					gint _tmp26_ = 0;
					_tmp10_ = vresult;
					_tmp11_ = _g_hash_table_ref0 (g_value_get_boxed (&_tmp10_));
					_result_ = _tmp11_;
					{
						guchar* data = NULL;
						GHashTable* _tmp12_ = NULL;
						gconstpointer _tmp13_ = NULL;
						size_t _tmp14_;
						guchar* _tmp15_ = NULL;
						gint data_length1 = 0;
						gint _data_size_ = 0;
						SubmarineSubtitle* subtitle = NULL;
						GeeHashMap* _tmp16_ = NULL;
						GHashTable* _tmp17_ = NULL;
						gconstpointer _tmp18_ = NULL;
						gpointer _tmp19_ = NULL;
						gchar* _tmp20_ = NULL;
						guchar* _tmp21_ = NULL;
						gint _tmp21__length1 = 0;
						gchar* _tmp22_ = NULL;
						SubmarineSubtitle* _tmp23_ = NULL;
						GeeHashSet* _tmp24_ = NULL;
						SubmarineSubtitle* _tmp25_ = NULL;
						_tmp12_ = _result_;
						_tmp13_ = g_hash_table_lookup (_tmp12_, "data");
						_tmp15_ = g_base64_decode (g_value_get_string ((GValue*) _tmp13_), &_tmp14_);
						data = _tmp15_;
						data_length1 = _tmp14_;
						_data_size_ = data_length1;
						_tmp16_ = _data2_->id_map;
						_tmp17_ = _result_;
						_tmp18_ = g_hash_table_lookup (_tmp17_, "idsubtitlefile");
						_tmp19_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp16_, g_value_get_string ((GValue*) _tmp18_));
						subtitle = (SubmarineSubtitle*) _tmp19_;
						_tmp21_ = data;
						_tmp21__length1 = data_length1;
						_tmp22_ = submarine_open_subtitles_server_inflate_subtitle (self, _tmp21_, _tmp21__length1, &_inner_error_);
						_tmp20_ = _tmp22_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							_submarine_subtitle_unref0 (subtitle);
							data = (g_free (data), NULL);
							goto __catch8_g_error;
						}
						_tmp23_ = subtitle;
						submarine_subtitle_set_data (_tmp23_, _tmp20_);
						_tmp24_ = _data2_->subtitles_downloaded;
						_tmp25_ = subtitle;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp24_, _tmp25_);
						_g_free0 (_tmp20_);
						_submarine_subtitle_unref0 (subtitle);
						data = (g_free (data), NULL);
					}
					goto __finally8;
					__catch8_g_error:
					{
						GError* e = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_g_error_free0 (e);
					}
					__finally8:
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_hash_table_unref0 (_result_);
						G_IS_VALUE (&vresult) ? (g_value_unset (&vresult), NULL) : NULL;
						_g_hash_table_unref0 (vh);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return 0;
					}
					_tmp26_ = results;
					results = _tmp26_ + 1;
					_g_hash_table_unref0 (_result_);
					G_IS_VALUE (&vresult) ? (g_value_unset (&vresult), NULL) : NULL;
				}
			}
		}
	}
	result = results;
	_g_hash_table_unref0 (vh);
	return result;
}


static gint ___lambda8__submarine_subtitle_server_batch_response_method (GValue* response, gpointer self) {
	gint result;
	result = __lambda8_ (self, response);
	return result;
}


static GeeSet* submarine_open_subtitles_server_real_download_multiple (SubmarineSubtitleServer* base, GeeCollection* subtitles) {
	SubmarineOpenSubtitlesServer * self;
	GeeSet* result = NULL;
	Block2Data* _data2_;
	GeeHashSet* _tmp0_ = NULL;
	GeeArrayList* requests = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeHashMap* _tmp2_ = NULL;
	static const gint MAX = 500;
	SubmarineSubtitleServerBatchRequestMethod request_method = NULL;
	void* request_method_target = NULL;
	GDestroyNotify request_method_target_destroy_notify = NULL;
	SubmarineSubtitleServerBatchResponseMethod response_method = NULL;
	void* response_method_target = NULL;
	GDestroyNotify response_method_target_destroy_notify = NULL;
	GeeArrayList* _tmp21_ = NULL;
	GeeArrayList* _tmp22_ = NULL;
	GeeArrayList* _tmp23_ = NULL;
	GeeHashSet* _tmp24_ = NULL;
	GeeSet* _tmp25_ = NULL;
	self = (SubmarineOpenSubtitlesServer*) base;
	g_return_val_if_fail (subtitles != NULL, NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	_data2_->subtitles_downloaded = _tmp0_;
	_tmp1_ = gee_array_list_new (G_TYPE_VALUE, (GBoxedCopyFunc) _g_value_dup, _vala_GValue_free, NULL, NULL, NULL);
	requests = _tmp1_;
	_tmp2_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_data2_->id_map = _tmp2_;
	{
		GeeIterator* _subtitle_it = NULL;
		GeeCollection* _tmp3_ = NULL;
		GeeIterator* _tmp4_ = NULL;
		_tmp3_ = subtitles;
		_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
		_subtitle_it = _tmp4_;
		while (TRUE) {
			GeeIterator* _tmp5_ = NULL;
			gboolean _tmp6_ = FALSE;
			SubmarineSubtitle* subtitle = NULL;
			GeeIterator* _tmp7_ = NULL;
			gpointer _tmp8_ = NULL;
			GHashTable* server_data = NULL;
			SubmarineSubtitle* _tmp9_ = NULL;
			GValue _tmp10_ = {0};
			GValue _tmp11_ = {0};
			GHashTable* _tmp12_ = NULL;
			GValue* id = NULL;
			GHashTable* _tmp13_ = NULL;
			gconstpointer _tmp14_ = NULL;
			GValue* _tmp15_ = NULL;
			GeeArrayList* _tmp16_ = NULL;
			GValue* _tmp17_ = NULL;
			GeeHashMap* _tmp18_ = NULL;
			GValue* _tmp19_ = NULL;
			SubmarineSubtitle* _tmp20_ = NULL;
			_tmp5_ = _subtitle_it;
			_tmp6_ = gee_iterator_next (_tmp5_);
			if (!_tmp6_) {
				break;
			}
			_tmp7_ = _subtitle_it;
			_tmp8_ = gee_iterator_get (_tmp7_);
			subtitle = (SubmarineSubtitle*) _tmp8_;
			_tmp9_ = subtitle;
			submarine_subtitle_get_server_data (_tmp9_, &_tmp10_);
			_tmp11_ = _tmp10_;
			_tmp12_ = _g_hash_table_ref0 (g_value_get_boxed (&_tmp11_));
			server_data = _tmp12_;
			_tmp13_ = server_data;
			_tmp14_ = g_hash_table_lookup (_tmp13_, "IDSubtitleFile");
			_tmp15_ = __g_value_dup0 ((GValue*) _tmp14_);
			id = _tmp15_;
			_tmp16_ = requests;
			_tmp17_ = id;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp16_, _tmp17_);
			_tmp18_ = _data2_->id_map;
			_tmp19_ = id;
			_tmp20_ = subtitle;
			gee_abstract_map_set ((GeeAbstractMap*) _tmp18_, g_value_get_string (_tmp19_), _tmp20_);
			__vala_GValue_free0 (id);
			_g_hash_table_unref0 (server_data);
			_submarine_subtitle_unref0 (subtitle);
		}
		_g_object_unref0 (_subtitle_it);
	}
	request_method = ___lambda7__submarine_subtitle_server_batch_request_method;
	request_method_target = g_object_ref (self);
	request_method_target_destroy_notify = g_object_unref;
	response_method = ___lambda8__submarine_subtitle_server_batch_response_method;
	response_method_target = block2_data_ref (_data2_);
	response_method_target_destroy_notify = block2_data_unref;
	_tmp21_ = requests;
	_tmp22_ = submarine_subtitle_server_batch_process ((SubmarineSubtitleServer*) self, (GeeList*) _tmp21_, request_method, request_method_target, response_method, response_method_target, MAX, 0);
	_tmp23_ = _tmp22_;
	_g_object_unref0 (_tmp23_);
	_tmp24_ = _data2_->subtitles_downloaded;
	_tmp25_ = _g_object_ref0 ((GeeSet*) _tmp24_);
	result = _tmp25_;
	(response_method_target_destroy_notify == NULL) ? NULL : (response_method_target_destroy_notify (response_method_target), NULL);
	response_method = NULL;
	response_method_target = NULL;
	response_method_target_destroy_notify = NULL;
	(request_method_target_destroy_notify == NULL) ? NULL : (request_method_target_destroy_notify (request_method_target), NULL);
	request_method = NULL;
	request_method_target = NULL;
	request_method_target_destroy_notify = NULL;
	_g_object_unref0 (requests);
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return result;
}


SubmarineOpenSubtitlesServer* submarine_open_subtitles_server_construct (GType object_type) {
	SubmarineOpenSubtitlesServer * self = NULL;
	self = (SubmarineOpenSubtitlesServer*) submarine_subtitle_server_construct (object_type);
	return self;
}


SubmarineOpenSubtitlesServer* submarine_open_subtitles_server_new (void) {
	return submarine_open_subtitles_server_construct (SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER);
}


static GObject * submarine_open_subtitles_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SubmarineOpenSubtitlesServer * self;
	SubmarineServerInfo _tmp0_ = {0};
	SubmarineServerInfo _tmp1_ = {0};
	parent_class = G_OBJECT_CLASS (submarine_open_subtitles_server_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER, SubmarineOpenSubtitlesServer);
	submarine_server_info_init (&_tmp0_, "OpenSubtitles", "http://www.opensubtitles.org", "os");
	_tmp1_ = _tmp0_;
	submarine_subtitle_server_set_info ((SubmarineSubtitleServer*) self, &_tmp1_);
	submarine_server_info_destroy (&_tmp1_);
	return obj;
}


static void submarine_open_subtitles_server_class_init (SubmarineOpenSubtitlesServerClass * klass) {
	submarine_open_subtitles_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SubmarineOpenSubtitlesServerPrivate));
	((SubmarineSubtitleServerClass *) klass)->connect = submarine_open_subtitles_server_real_connect;
	((SubmarineSubtitleServerClass *) klass)->disconnect = submarine_open_subtitles_server_real_disconnect;
	((SubmarineSubtitleServerClass *) klass)->search_multiple = submarine_open_subtitles_server_real_search_multiple;
	((SubmarineSubtitleServerClass *) klass)->download_multiple = submarine_open_subtitles_server_real_download_multiple;
	G_OBJECT_CLASS (klass)->constructor = submarine_open_subtitles_server_constructor;
	G_OBJECT_CLASS (klass)->finalize = submarine_open_subtitles_server_finalize;
}


static void submarine_open_subtitles_server_instance_init (SubmarineOpenSubtitlesServer * self) {
	self->priv = SUBMARINE_OPEN_SUBTITLES_SERVER_GET_PRIVATE (self);
}


static void submarine_open_subtitles_server_finalize (GObject* obj) {
	SubmarineOpenSubtitlesServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER, SubmarineOpenSubtitlesServer);
	_g_object_unref0 (self->priv->session);
	_g_free0 (self->priv->session_token);
	_g_object_unref0 (self->priv->supported_languages);
	G_OBJECT_CLASS (submarine_open_subtitles_server_parent_class)->finalize (obj);
}


GType submarine_open_subtitles_server_get_type (void) {
	static volatile gsize submarine_open_subtitles_server_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_open_subtitles_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineOpenSubtitlesServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_open_subtitles_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineOpenSubtitlesServer), 0, (GInstanceInitFunc) submarine_open_subtitles_server_instance_init, NULL };
		GType submarine_open_subtitles_server_type_id;
		submarine_open_subtitles_server_type_id = g_type_register_static (SUBMARINE_TYPE_SUBTITLE_SERVER, "SubmarineOpenSubtitlesServer", &g_define_type_info, 0);
		g_once_init_leave (&submarine_open_subtitles_server_type_id__volatile, submarine_open_subtitles_server_type_id);
	}
	return submarine_open_subtitles_server_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



