/* podnapisi.c generated by valac 0.28.0, the Vala compiler
 * generated from podnapisi.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <libsoup/soup.h>
#include <archive.h>
#include <archive_entry.h>
#include <sys/stat.h>
#include <float.h>
#include <math.h>
#include <stdio.h>


#define SUBMARINE_TYPE_SUBTITLE_SERVER (submarine_subtitle_server_get_type ())
#define SUBMARINE_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer))
#define SUBMARINE_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))
#define SUBMARINE_IS_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_IS_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_SUBTITLE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))

typedef struct _SubmarineSubtitleServer SubmarineSubtitleServer;
typedef struct _SubmarineSubtitleServerClass SubmarineSubtitleServerClass;
typedef struct _SubmarineSubtitleServerPrivate SubmarineSubtitleServerPrivate;

#define SUBMARINE_TYPE_SUBTITLE (submarine_subtitle_get_type ())
#define SUBMARINE_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitle))
#define SUBMARINE_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))
#define SUBMARINE_IS_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_IS_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_SUBTITLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))

typedef struct _SubmarineSubtitle SubmarineSubtitle;
typedef struct _SubmarineSubtitleClass SubmarineSubtitleClass;

#define SUBMARINE_TYPE_PODNAPISI_SERVER (submarine_podnapisi_server_get_type ())
#define SUBMARINE_PODNAPISI_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_PODNAPISI_SERVER, SubmarinePodnapisiServer))
#define SUBMARINE_PODNAPISI_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_PODNAPISI_SERVER, SubmarinePodnapisiServerClass))
#define SUBMARINE_IS_PODNAPISI_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_PODNAPISI_SERVER))
#define SUBMARINE_IS_PODNAPISI_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_PODNAPISI_SERVER))
#define SUBMARINE_PODNAPISI_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_PODNAPISI_SERVER, SubmarinePodnapisiServerClass))

typedef struct _SubmarinePodnapisiServer SubmarinePodnapisiServer;
typedef struct _SubmarinePodnapisiServerClass SubmarinePodnapisiServerClass;
typedef struct _SubmarinePodnapisiServerPrivate SubmarinePodnapisiServerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define SUBMARINE_TYPE_LANGUAGE_INFO (submarine_language_info_get_type ())
typedef struct _SubmarineLanguageInfo SubmarineLanguageInfo;
#define _submarine_language_info_free0(var) ((var == NULL) ? NULL : (var = (submarine_language_info_free (var), NULL)))
#define _g_value_array_free0(var) ((var == NULL) ? NULL : (var = (g_value_array_free (var), NULL)))
#define _archive_read_finish0(var) ((var == NULL) ? NULL : (var = (archive_read_finish (var), NULL)))
typedef struct _Block3Data Block3Data;
#define __vala_GValue_free0(var) ((var == NULL) ? NULL : (var = (_vala_GValue_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define SUBMARINE_TYPE_SERVER_INFO (submarine_server_info_get_type ())
typedef struct _SubmarineServerInfo SubmarineServerInfo;
#define _submarine_subtitle_unref0(var) ((var == NULL) ? NULL : (var = (submarine_subtitle_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

struct _SubmarineSubtitleServer {
	GObject parent_instance;
	SubmarineSubtitleServerPrivate * priv;
};

struct _SubmarineSubtitleServerClass {
	GObjectClass parent_class;
	gboolean (*connect) (SubmarineSubtitleServer* self);
	void (*disconnect) (SubmarineSubtitleServer* self);
	GeeSet* (*search) (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
	GeeMultiMap* (*search_multiple) (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
	SubmarineSubtitle* (*download) (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
	GeeSet* (*download_multiple) (SubmarineSubtitleServer* self, GeeCollection* subtitles);
};

struct _SubmarinePodnapisiServer {
	SubmarineSubtitleServer parent_instance;
	SubmarinePodnapisiServerPrivate * priv;
};

struct _SubmarinePodnapisiServerClass {
	SubmarineSubtitleServerClass parent_class;
};

struct _SubmarinePodnapisiServerPrivate {
	SoupSessionSync* session;
	gchar* session_token;
	GeeHashSet* supported_languages;
	GeeHashMap* language_ids;
	GeeHashSet* selected_languages;
};

struct _SubmarineLanguageInfo {
	gchar* _long_code;
	gchar* _long_code_alt;
	gchar* _short_code;
	gchar* _name;
};

struct _Block3Data {
	int _ref_count_;
	SubmarinePodnapisiServer* self;
	GeeHashMultiMap* subtitles_found_map;
	GeeHashMap* hash_file;
};

typedef GValue* (*SubmarineSubtitleServerBatchRequestMethod) (GeeList* request_batch, void* user_data);
typedef gint (*SubmarineSubtitleServerBatchResponseMethod) (GValue* response, void* user_data);
struct _SubmarineServerInfo {
	gchar* _name;
	gchar* _address;
	gchar* _code;
};


static gpointer submarine_podnapisi_server_parent_class = NULL;

GType submarine_subtitle_server_get_type (void) G_GNUC_CONST;
gpointer submarine_subtitle_ref (gpointer instance);
void submarine_subtitle_unref (gpointer instance);
GParamSpec* submarine_param_spec_subtitle (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_subtitle (GValue* value, gpointer v_object);
void submarine_value_take_subtitle (GValue* value, gpointer v_object);
gpointer submarine_value_get_subtitle (const GValue* value);
GType submarine_subtitle_get_type (void) G_GNUC_CONST;
GType submarine_podnapisi_server_get_type (void) G_GNUC_CONST;
#define SUBMARINE_PODNAPISI_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_PODNAPISI_SERVER, SubmarinePodnapisiServerPrivate))
enum  {
	SUBMARINE_PODNAPISI_SERVER_DUMMY_PROPERTY
};
#define SUBMARINE_PODNAPISI_SERVER_XMLRPC_URI "http://ssp.podnapisi.net:8000/RPC2"
#define SUBMARINE_PODNAPISI_SERVER_DOWNLOAD_URI "http://www.podnapisi.net/static/podnapisi/"
static gboolean submarine_podnapisi_server_get_supported_languages (SubmarinePodnapisiServer* self);
gboolean submarine_xmlrpc_call (SoupSession* session, SoupMessage* message, GHashTable** vhash, guint* status_code);
static gboolean submarine_podnapisi_server_filter_languages (SubmarinePodnapisiServer* self, GeeCollection* languages);
GType submarine_language_info_get_type (void) G_GNUC_CONST;
SubmarineLanguageInfo* submarine_language_info_dup (const SubmarineLanguageInfo* self);
void submarine_language_info_free (SubmarineLanguageInfo* self);
void submarine_language_info_copy (const SubmarineLanguageInfo* self, SubmarineLanguageInfo* dest);
void submarine_language_info_destroy (SubmarineLanguageInfo* self);
SubmarineLanguageInfo* submarine_get_language_info (const gchar* language_code);
const gchar* submarine_language_info_get_short_code (SubmarineLanguageInfo* self);
static guint64 submarine_podnapisi_server_file_size (SubmarinePodnapisiServer* self, GFile* file, GError** error);
static guint64 submarine_podnapisi_server_file_hash (SubmarinePodnapisiServer* self, GFile* file, GError** error);
static gboolean submarine_podnapisi_server_inflate_subtitle (SubmarinePodnapisiServer* self, guint8* data, int data_length1, gchar** format, gchar** inflated_data);
static gboolean submarine_podnapisi_server_real_connect (SubmarineSubtitleServer* base);
static void submarine_podnapisi_server_real_disconnect (SubmarineSubtitleServer* base);
static GeeMultiMap* submarine_podnapisi_server_real_search_multiple (SubmarineSubtitleServer* base, GeeCollection* files, GeeCollection* languages);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static GValue* _g_value_dup (GValue* self);
static void _vala_GValue_free (GValue* self);
static GValue* ___lambda9_ (SubmarinePodnapisiServer* self, GeeList* request_batch);
static GValue* ____lambda9__submarine_subtitle_server_batch_request_method (GeeList* request_batch, gpointer self);
static gint ___lambda10_ (Block3Data* _data3_, GValue* response);
GType submarine_server_info_get_type (void) G_GNUC_CONST;
SubmarineServerInfo* submarine_server_info_dup (const SubmarineServerInfo* self);
void submarine_server_info_free (SubmarineServerInfo* self);
void submarine_server_info_copy (const SubmarineServerInfo* self, SubmarineServerInfo* dest);
void submarine_server_info_destroy (SubmarineServerInfo* self);
void submarine_subtitle_server_get_info (SubmarineSubtitleServer* self, SubmarineServerInfo* result);
SubmarineSubtitle* submarine_subtitle_new (SubmarineServerInfo* server_info, GValue* server_data);
SubmarineSubtitle* submarine_subtitle_construct (GType object_type, SubmarineServerInfo* server_info, GValue* server_data);
void submarine_subtitle_set_format (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_language (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_rating (SubmarineSubtitle* self, gdouble value);
gdouble submarine_subtitle_get_rating (SubmarineSubtitle* self);
static gint ____lambda10__submarine_subtitle_server_batch_response_method (GValue* response, gpointer self);
GeeArrayList* submarine_subtitle_server_batch_process (SubmarineSubtitleServer* self, GeeList* requests, SubmarineSubtitleServerBatchRequestMethod request_method, void* request_method_target, SubmarineSubtitleServerBatchResponseMethod response_method, void* response_method_target, gint max_request_size, gint max_response_size);
static SubmarineSubtitle* submarine_podnapisi_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle);
void submarine_subtitle_get_server_data (SubmarineSubtitle* self, GValue* result);
void submarine_subtitle_set_data (SubmarineSubtitle* self, const gchar* value);
SubmarinePodnapisiServer* submarine_podnapisi_server_new (void);
SubmarinePodnapisiServer* submarine_podnapisi_server_construct (GType object_type);
SubmarineSubtitleServer* submarine_subtitle_server_construct (GType object_type);
static GObject * submarine_podnapisi_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void submarine_server_info_init (SubmarineServerInfo *self, const gchar* name, const gchar* address, const gchar* code);
void submarine_subtitle_server_set_info (SubmarineSubtitleServer* self, SubmarineServerInfo* value);
static void submarine_podnapisi_server_finalize (GObject* obj);


static gboolean submarine_podnapisi_server_get_supported_languages (SubmarinePodnapisiServer* self) {
	gboolean result = FALSE;
	GHashTable* vh = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GeeHashMap* _tmp1_ = NULL;
	SoupMessage* message = NULL;
	const gchar* _tmp2_ = NULL;
	SoupMessage* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	SoupSessionSync* _tmp5_ = NULL;
	SoupMessage* _tmp6_ = NULL;
	GHashTable* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->supported_languages);
	self->priv->supported_languages = _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_INT, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->language_ids);
	self->priv->language_ids = _tmp1_;
	_tmp2_ = self->priv->session_token;
	_tmp3_ = soup_xmlrpc_request_new (SUBMARINE_PODNAPISI_SERVER_XMLRPC_URI, "supportedLanguages", G_TYPE_STRING, _tmp2_, G_TYPE_INVALID);
	message = _tmp3_;
	_tmp5_ = self->priv->session;
	_tmp6_ = message;
	_tmp8_ = submarine_xmlrpc_call ((SoupSession*) _tmp5_, _tmp6_, &_tmp7_, NULL);
	_g_hash_table_unref0 (vh);
	vh = _tmp7_;
	if (_tmp8_) {
		GHashTable* _tmp9_ = NULL;
		gconstpointer _tmp10_ = NULL;
		_tmp9_ = vh;
		_tmp10_ = g_hash_table_lookup (_tmp9_, "status");
		_tmp4_ = g_value_get_int ((GValue*) _tmp10_) == 200;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		GValueArray* va = NULL;
		GHashTable* _tmp11_ = NULL;
		gconstpointer _tmp12_ = NULL;
		GValueArray* _tmp13_ = NULL;
		_tmp11_ = vh;
		_tmp12_ = g_hash_table_lookup (_tmp11_, "languages");
		va = g_value_get_boxed ((GValue*) _tmp12_);
		_tmp13_ = va;
		{
			GValueArray* vresult_collection = NULL;
			guint vresult_index = 0U;
			vresult_collection = _tmp13_;
			for (vresult_index = 0; vresult_index < vresult_collection->n_values; vresult_index = vresult_index + 1) {
				GValue _tmp14_ = {0};
				GValue vresult = {0};
				if (G_IS_VALUE (g_value_array_get_nth (vresult_collection, vresult_index))) {
					g_value_init (&_tmp14_, G_VALUE_TYPE (g_value_array_get_nth (vresult_collection, vresult_index)));
					g_value_copy (g_value_array_get_nth (vresult_collection, vresult_index), &_tmp14_);
				} else {
					_tmp14_ = *g_value_array_get_nth (vresult_collection, vresult_index);
				}
				vresult = _tmp14_;
				{
					GValueArray* _result_ = NULL;
					GValue _tmp15_ = {0};
					GeeHashSet* _tmp16_ = NULL;
					GValueArray* _tmp17_ = NULL;
					GValue* _tmp18_ = NULL;
					GeeHashMap* _tmp19_ = NULL;
					GValueArray* _tmp20_ = NULL;
					GValue* _tmp21_ = NULL;
					GValueArray* _tmp22_ = NULL;
					GValue* _tmp23_ = NULL;
					_tmp15_ = vresult;
					_result_ = g_value_get_boxed (&_tmp15_);
					_tmp16_ = self->priv->supported_languages;
					_tmp17_ = _result_;
					_tmp18_ = g_value_array_get_nth (_tmp17_, (guint) 1);
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp16_, g_value_get_string (_tmp18_));
					_tmp19_ = self->priv->language_ids;
					_tmp20_ = _result_;
					_tmp21_ = g_value_array_get_nth (_tmp20_, (guint) 1);
					_tmp22_ = _result_;
					_tmp23_ = g_value_array_get_nth (_tmp22_, (guint) 0);
					gee_abstract_map_set ((GeeAbstractMap*) _tmp19_, g_value_get_string (_tmp21_), (gpointer) ((gintptr) g_value_get_int (_tmp23_)));
					G_IS_VALUE (&vresult) ? (g_value_unset (&vresult), NULL) : NULL;
				}
			}
		}
		result = TRUE;
		_g_object_unref0 (message);
		_g_hash_table_unref0 (vh);
		return result;
	}
	result = FALSE;
	_g_object_unref0 (message);
	_g_hash_table_unref0 (vh);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean submarine_podnapisi_server_filter_languages (SubmarinePodnapisiServer* self, GeeCollection* languages) {
	gboolean result = FALSE;
	GHashTable* vh = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GeeHashSet* languages_set = NULL;
	GeeHashSet* _tmp1_ = NULL;
	GeeHashSet* _tmp23_ = NULL;
	gboolean _tmp24_ = FALSE;
	gboolean _tmp25_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (languages != NULL, FALSE);
	_tmp0_ = self->priv->supported_languages;
	if (_tmp0_ == NULL) {
		submarine_podnapisi_server_get_supported_languages (self);
	}
	_tmp1_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	languages_set = _tmp1_;
	{
		GeeIterator* _language_it = NULL;
		GeeCollection* _tmp2_ = NULL;
		GeeIterator* _tmp3_ = NULL;
		_tmp2_ = languages;
		_tmp3_ = gee_iterable_iterator ((GeeIterable*) _tmp2_);
		_language_it = _tmp3_;
		while (TRUE) {
			GeeIterator* _tmp4_ = NULL;
			gboolean _tmp5_ = FALSE;
			gchar* language = NULL;
			GeeIterator* _tmp6_ = NULL;
			gpointer _tmp7_ = NULL;
			SubmarineLanguageInfo* language_info = NULL;
			const gchar* _tmp8_ = NULL;
			SubmarineLanguageInfo* _tmp9_ = NULL;
			gboolean _tmp10_ = FALSE;
			SubmarineLanguageInfo* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			_tmp4_ = _language_it;
			_tmp5_ = gee_iterator_next (_tmp4_);
			if (!_tmp5_) {
				break;
			}
			_tmp6_ = _language_it;
			_tmp7_ = gee_iterator_get (_tmp6_);
			language = (gchar*) _tmp7_;
			_tmp8_ = language;
			_tmp9_ = submarine_get_language_info (_tmp8_);
			language_info = _tmp9_;
			_tmp11_ = language_info;
			_tmp12_ = submarine_language_info_get_short_code (_tmp11_);
			_tmp13_ = _tmp12_;
			if (_tmp13_ != NULL) {
				GeeHashSet* _tmp14_ = NULL;
				SubmarineLanguageInfo* _tmp15_ = NULL;
				const gchar* _tmp16_ = NULL;
				const gchar* _tmp17_ = NULL;
				gboolean _tmp18_ = FALSE;
				_tmp14_ = self->priv->supported_languages;
				_tmp15_ = language_info;
				_tmp16_ = submarine_language_info_get_short_code (_tmp15_);
				_tmp17_ = _tmp16_;
				_tmp18_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp14_, _tmp17_);
				_tmp10_ = _tmp18_;
			} else {
				_tmp10_ = FALSE;
			}
			if (_tmp10_) {
				GeeHashSet* _tmp19_ = NULL;
				SubmarineLanguageInfo* _tmp20_ = NULL;
				const gchar* _tmp21_ = NULL;
				const gchar* _tmp22_ = NULL;
				_tmp19_ = languages_set;
				_tmp20_ = language_info;
				_tmp21_ = submarine_language_info_get_short_code (_tmp20_);
				_tmp22_ = _tmp21_;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp19_, _tmp22_);
			}
			_submarine_language_info_free0 (language_info);
			_g_free0 (language);
		}
		_g_object_unref0 (_language_it);
	}
	_tmp23_ = languages_set;
	_tmp24_ = gee_collection_get_is_empty ((GeeCollection*) _tmp23_);
	_tmp25_ = _tmp24_;
	if (!_tmp25_) {
		gboolean update = FALSE;
		gboolean _tmp26_ = FALSE;
		GeeHashSet* _tmp27_ = NULL;
		gboolean _tmp43_ = FALSE;
		update = FALSE;
		_tmp27_ = self->priv->selected_languages;
		if (_tmp27_ == NULL) {
			_tmp26_ = TRUE;
		} else {
			GeeHashSet* _tmp28_ = NULL;
			gint _tmp29_ = 0;
			gint _tmp30_ = 0;
			GeeHashSet* _tmp31_ = NULL;
			gint _tmp32_ = 0;
			gint _tmp33_ = 0;
			_tmp28_ = languages_set;
			_tmp29_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp28_);
			_tmp30_ = _tmp29_;
			_tmp31_ = self->priv->selected_languages;
			_tmp32_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp31_);
			_tmp33_ = _tmp32_;
			_tmp26_ = _tmp30_ != _tmp33_;
		}
		if (_tmp26_) {
			update = TRUE;
		} else {
			{
				GeeIterator* _language_it = NULL;
				GeeHashSet* _tmp34_ = NULL;
				GeeIterator* _tmp35_ = NULL;
				_tmp34_ = languages_set;
				_tmp35_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp34_);
				_language_it = _tmp35_;
				while (TRUE) {
					GeeIterator* _tmp36_ = NULL;
					gboolean _tmp37_ = FALSE;
					gchar* language = NULL;
					GeeIterator* _tmp38_ = NULL;
					gpointer _tmp39_ = NULL;
					GeeHashSet* _tmp40_ = NULL;
					const gchar* _tmp41_ = NULL;
					gboolean _tmp42_ = FALSE;
					_tmp36_ = _language_it;
					_tmp37_ = gee_iterator_next (_tmp36_);
					if (!_tmp37_) {
						break;
					}
					_tmp38_ = _language_it;
					_tmp39_ = gee_iterator_get (_tmp38_);
					language = (gchar*) _tmp39_;
					_tmp40_ = self->priv->selected_languages;
					_tmp41_ = language;
					_tmp42_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp40_, _tmp41_);
					if (!_tmp42_) {
						update = TRUE;
						_g_free0 (language);
						break;
					}
					_g_free0 (language);
				}
				_g_object_unref0 (_language_it);
			}
		}
		_tmp43_ = update;
		if (_tmp43_) {
			GValueArray* languages_array = NULL;
			GValueArray* _tmp44_ = NULL;
			SoupMessage* message = NULL;
			const gchar* _tmp56_ = NULL;
			GValueArray* _tmp57_ = NULL;
			SoupMessage* _tmp58_ = NULL;
			gboolean _tmp59_ = FALSE;
			SoupSessionSync* _tmp60_ = NULL;
			SoupMessage* _tmp61_ = NULL;
			GHashTable* _tmp62_ = NULL;
			gboolean _tmp63_ = FALSE;
			_tmp44_ = g_value_array_new ((guint) 0);
			languages_array = _tmp44_;
			{
				GeeIterator* _language_it = NULL;
				GeeHashSet* _tmp45_ = NULL;
				GeeIterator* _tmp46_ = NULL;
				_tmp45_ = languages_set;
				_tmp46_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp45_);
				_language_it = _tmp46_;
				while (TRUE) {
					GeeIterator* _tmp47_ = NULL;
					gboolean _tmp48_ = FALSE;
					gchar* language = NULL;
					GeeIterator* _tmp49_ = NULL;
					gpointer _tmp50_ = NULL;
					GValueArray* _tmp51_ = NULL;
					GeeHashMap* _tmp52_ = NULL;
					const gchar* _tmp53_ = NULL;
					gpointer _tmp54_ = NULL;
					GValue _tmp55_ = {0};
					_tmp47_ = _language_it;
					_tmp48_ = gee_iterator_next (_tmp47_);
					if (!_tmp48_) {
						break;
					}
					_tmp49_ = _language_it;
					_tmp50_ = gee_iterator_get (_tmp49_);
					language = (gchar*) _tmp50_;
					_tmp51_ = languages_array;
					_tmp52_ = self->priv->language_ids;
					_tmp53_ = language;
					_tmp54_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp52_, _tmp53_);
					g_value_init (&_tmp55_, G_TYPE_INT);
					g_value_set_int (&_tmp55_, (gint) ((gintptr) _tmp54_));
					g_value_array_append (_tmp51_, &_tmp55_);
					G_IS_VALUE (&_tmp55_) ? (g_value_unset (&_tmp55_), NULL) : NULL;
					_g_free0 (language);
				}
				_g_object_unref0 (_language_it);
			}
			_tmp56_ = self->priv->session_token;
			_tmp57_ = languages_array;
			_tmp58_ = soup_xmlrpc_request_new (SUBMARINE_PODNAPISI_SERVER_XMLRPC_URI, "setFilters", G_TYPE_STRING, _tmp56_, G_TYPE_BOOLEAN, TRUE, G_TYPE_VALUE_ARRAY, _tmp57_, G_TYPE_BOOLEAN, FALSE, G_TYPE_INVALID);
			message = _tmp58_;
			_tmp60_ = self->priv->session;
			_tmp61_ = message;
			_tmp63_ = submarine_xmlrpc_call ((SoupSession*) _tmp60_, _tmp61_, &_tmp62_, NULL);
			_g_hash_table_unref0 (vh);
			vh = _tmp62_;
			if (_tmp63_) {
				GHashTable* _tmp64_ = NULL;
				gconstpointer _tmp65_ = NULL;
				_tmp64_ = vh;
				_tmp65_ = g_hash_table_lookup (_tmp64_, "status");
				_tmp59_ = g_value_get_int ((GValue*) _tmp65_) == 200;
			} else {
				_tmp59_ = FALSE;
			}
			if (_tmp59_) {
				GeeHashSet* _tmp66_ = NULL;
				GeeHashSet* _tmp67_ = NULL;
				_tmp66_ = languages_set;
				_tmp67_ = _g_object_ref0 (_tmp66_);
				_g_object_unref0 (self->priv->selected_languages);
				self->priv->selected_languages = _tmp67_;
				result = TRUE;
				_g_object_unref0 (message);
				_g_value_array_free0 (languages_array);
				_g_object_unref0 (languages_set);
				_g_hash_table_unref0 (vh);
				return result;
			}
			_g_object_unref0 (message);
			_g_value_array_free0 (languages_array);
		} else {
			result = TRUE;
			_g_object_unref0 (languages_set);
			_g_hash_table_unref0 (vh);
			return result;
		}
	}
	result = FALSE;
	_g_object_unref0 (languages_set);
	_g_hash_table_unref0 (vh);
	return result;
}


static guint64 submarine_podnapisi_server_file_size (SubmarinePodnapisiServer* self, GFile* file, GError** error) {
	guint64 result = 0ULL;
	GFileInfo* file_info = NULL;
	GFile* _tmp0_ = NULL;
	GFileInfo* _tmp1_ = NULL;
	gint64 _tmp2_ = 0LL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	g_return_val_if_fail (file != NULL, 0ULL);
	_tmp0_ = file;
	_tmp1_ = g_file_query_info (_tmp0_, "*", G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
	file_info = _tmp1_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return 0ULL;
	}
	_tmp2_ = g_file_info_get_size (file_info);
	result = (guint64) _tmp2_;
	_g_object_unref0 (file_info);
	return result;
}


static guint64 submarine_podnapisi_server_file_hash (SubmarinePodnapisiServer* self, GFile* file, GError** error) {
	guint64 result = 0ULL;
	guint64 hash = 0ULL;
	guint64 size = 0ULL;
	guint64 _tmp0_ = 0ULL;
	GFile* _tmp1_ = NULL;
	guint64 _tmp2_ = 0ULL;
	guint64 _tmp3_ = 0ULL;
	GFileInputStream* _tmp4_ = NULL;
	GFile* _tmp5_ = NULL;
	GFileInputStream* _tmp6_ = NULL;
	GDataInputStream* dis = NULL;
	GDataInputStream* _tmp7_ = NULL;
	GDataInputStream* _tmp8_ = NULL;
	GFileInputStream* _tmp16_ = NULL;
	GFile* _tmp17_ = NULL;
	GFileInputStream* _tmp18_ = NULL;
	GDataInputStream* _tmp19_ = NULL;
	GDataInputStream* _tmp20_ = NULL;
	GDataInputStream* _tmp21_ = NULL;
	guint64 _tmp22_ = 0ULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	g_return_val_if_fail (file != NULL, 0ULL);
	_tmp1_ = file;
	_tmp2_ = submarine_podnapisi_server_file_size (self, _tmp1_, &_inner_error_);
	_tmp0_ = _tmp2_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return 0ULL;
	}
	size = _tmp0_;
	_tmp3_ = size;
	hash = _tmp3_;
	_tmp5_ = file;
	_tmp6_ = g_file_read (_tmp5_, NULL, &_inner_error_);
	_tmp4_ = _tmp6_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return 0ULL;
	}
	_tmp7_ = g_data_input_stream_new ((GInputStream*) _tmp4_);
	dis = _tmp7_;
	_tmp8_ = dis;
	g_data_input_stream_set_byte_order (_tmp8_, G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp9_ = FALSE;
			_tmp9_ = TRUE;
			while (TRUE) {
				gint _tmp11_ = 0;
				guint64 _tmp12_ = 0ULL;
				GDataInputStream* _tmp13_ = NULL;
				guint64 _tmp14_ = 0ULL;
				guint64 _tmp15_ = 0ULL;
				if (!_tmp9_) {
					gint _tmp10_ = 0;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp11_ = i;
				if (!(((gulong) _tmp11_) < (65536 / sizeof (guint64)))) {
					break;
				}
				_tmp13_ = dis;
				_tmp14_ = g_data_input_stream_read_uint64 (_tmp13_, NULL, &_inner_error_);
				_tmp12_ = _tmp14_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (dis);
					_g_object_unref0 (_tmp4_);
					return 0ULL;
				}
				_tmp15_ = hash;
				hash = _tmp15_ + _tmp12_;
			}
		}
	}
	_tmp17_ = file;
	_tmp18_ = g_file_read (_tmp17_, NULL, &_inner_error_);
	_tmp16_ = _tmp18_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp4_);
		return 0ULL;
	}
	_tmp19_ = g_data_input_stream_new ((GInputStream*) _tmp16_);
	_g_object_unref0 (dis);
	dis = _tmp19_;
	_tmp20_ = dis;
	g_data_input_stream_set_byte_order (_tmp20_, G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN);
	_tmp21_ = dis;
	_tmp22_ = size;
	g_input_stream_skip ((GInputStream*) _tmp21_, (gsize) (_tmp22_ - 65536), NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (_tmp16_);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp4_);
		return 0ULL;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp23_ = FALSE;
			_tmp23_ = TRUE;
			while (TRUE) {
				gint _tmp25_ = 0;
				guint64 _tmp26_ = 0ULL;
				GDataInputStream* _tmp27_ = NULL;
				guint64 _tmp28_ = 0ULL;
				guint64 _tmp29_ = 0ULL;
				if (!_tmp23_) {
					gint _tmp24_ = 0;
					_tmp24_ = i;
					i = _tmp24_ + 1;
				}
				_tmp23_ = FALSE;
				_tmp25_ = i;
				if (!(((gulong) _tmp25_) < (65536 / sizeof (guint64)))) {
					break;
				}
				_tmp27_ = dis;
				_tmp28_ = g_data_input_stream_read_uint64 (_tmp27_, NULL, &_inner_error_);
				_tmp26_ = _tmp28_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					g_propagate_error (error, _inner_error_);
					_g_object_unref0 (_tmp16_);
					_g_object_unref0 (dis);
					_g_object_unref0 (_tmp4_);
					return 0ULL;
				}
				_tmp29_ = hash;
				hash = _tmp29_ + _tmp26_;
			}
		}
	}
	result = hash;
	_g_object_unref0 (_tmp16_);
	_g_object_unref0 (dis);
	_g_object_unref0 (_tmp4_);
	return result;
}


static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res = NULL;
	gint res_length1 = 0;
	gint _res_size_ = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	guint8* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res_length1;
	_tmp3_ = res;
	_tmp3__length1 = res_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


static gint string_last_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gboolean submarine_podnapisi_server_inflate_subtitle (SubmarinePodnapisiServer* self, guint8* data, int data_length1, gchar** format, gchar** inflated_data) {
	gchar* _vala_format = NULL;
	gchar* _vala_inflated_data = NULL;
	gboolean result = FALSE;
	struct archive* archive = NULL;
	struct archive* _tmp0_ = NULL;
	struct archive* _tmp1_ = NULL;
	struct archive* _tmp2_ = NULL;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	guint8* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	int _tmp5_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = archive_read_new ();
	archive = _tmp0_;
	_tmp1_ = archive;
	archive_read_support_format_zip (_tmp1_);
	_tmp2_ = archive;
	_tmp3_ = data;
	_tmp3__length1 = data_length1;
	_tmp4_ = data;
	_tmp4__length1 = data_length1;
	_tmp5_ = archive_read_open_memory (_tmp2_, _tmp3_, (gsize) _tmp4__length1);
	if (_tmp5_ == ARCHIVE_OK) {
		struct archive_entry* e = NULL;
		while (TRUE) {
			struct archive* _tmp6_ = NULL;
			struct archive_entry* _tmp7_ = NULL;
			int _tmp8_ = 0;
			struct archive_entry* _tmp9_ = NULL;
			mode_t _tmp10_ = {0};
			gboolean _tmp11_ = FALSE;
			_tmp6_ = archive;
			_tmp8_ = archive_read_next_header (_tmp6_, &_tmp7_);
			e = _tmp7_;
			if (!(_tmp8_ == ARCHIVE_OK)) {
				break;
			}
			_tmp9_ = e;
			_tmp10_ = archive_entry_mode (_tmp9_);
			_tmp11_ = S_ISDIR (_tmp10_);
			if (!_tmp11_) {
				struct archive_entry* _tmp12_ = NULL;
				gint64 _tmp13_ = 0LL;
				gchar* _tmp14_ = NULL;
				struct archive* _tmp15_ = NULL;
				const gchar* _tmp16_ = NULL;
				guint8* _tmp17_ = NULL;
				gint _tmp17__length1 = 0;
				guint8* _tmp18_ = NULL;
				gint _tmp18__length1 = 0;
				const gchar* _tmp19_ = NULL;
				guint8* _tmp20_ = NULL;
				gint _tmp20__length1 = 0;
				guint8* _tmp21_ = NULL;
				gint _tmp21__length1 = 0;
				struct archive_entry* _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				struct archive_entry* _tmp24_ = NULL;
				const gchar* _tmp25_ = NULL;
				gint _tmp26_ = 0;
				gchar* _tmp27_ = NULL;
				_tmp12_ = e;
				_tmp13_ = archive_entry_size (_tmp12_);
				_tmp14_ = g_strnfill ((gsize) _tmp13_, ' ');
				_g_free0 (_vala_inflated_data);
				_vala_inflated_data = _tmp14_;
				_tmp15_ = archive;
				_tmp16_ = _vala_inflated_data;
				_tmp17_ = string_get_data (_tmp16_, &_tmp17__length1);
				_tmp18_ = _tmp17_;
				_tmp18__length1 = _tmp17__length1;
				_tmp19_ = _vala_inflated_data;
				_tmp20_ = string_get_data (_tmp19_, &_tmp20__length1);
				_tmp21_ = _tmp20_;
				_tmp21__length1 = _tmp20__length1;
				archive_read_data (_tmp15_, _tmp18_, (gsize) _tmp21__length1);
				_tmp22_ = e;
				_tmp23_ = archive_entry_pathname (_tmp22_);
				_tmp24_ = e;
				_tmp25_ = archive_entry_pathname (_tmp24_);
				_tmp26_ = string_last_index_of (_tmp25_, ".", 0);
				_tmp27_ = string_substring (_tmp23_, (glong) (_tmp26_ + 1), (glong) (-1));
				_g_free0 (_vala_format);
				_vala_format = _tmp27_;
				result = TRUE;
				_archive_read_finish0 (archive);
				if (format) {
					*format = _vala_format;
				} else {
					_g_free0 (_vala_format);
				}
				if (inflated_data) {
					*inflated_data = _vala_inflated_data;
				} else {
					_g_free0 (_vala_inflated_data);
				}
				return result;
			}
		}
	}
	result = FALSE;
	_archive_read_finish0 (archive);
	if (format) {
		*format = _vala_format;
	} else {
		_g_free0 (_vala_format);
	}
	if (inflated_data) {
		*inflated_data = _vala_inflated_data;
	} else {
		_g_free0 (_vala_inflated_data);
	}
	return result;
}


static gboolean submarine_podnapisi_server_real_connect (SubmarineSubtitleServer* base) {
	SubmarinePodnapisiServer * self;
	gboolean result = FALSE;
	static const char username[] = "submarine";
	static const char password[] = "password";
	GHashTable* vh = NULL;
	SoupSessionSync* _tmp0_ = NULL;
	SoupMessage* message = NULL;
	SoupMessage* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	SoupSessionSync* _tmp3_ = NULL;
	SoupMessage* _tmp4_ = NULL;
	GHashTable* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	self = (SubmarinePodnapisiServer*) base;
	_tmp0_ = (SoupSessionSync*) soup_session_sync_new ();
	_g_object_unref0 (self->priv->session);
	self->priv->session = _tmp0_;
	_tmp1_ = soup_xmlrpc_request_new (SUBMARINE_PODNAPISI_SERVER_XMLRPC_URI, "initiate", G_TYPE_STRING, "submarine", G_TYPE_INVALID);
	message = _tmp1_;
	_tmp3_ = self->priv->session;
	_tmp4_ = message;
	_tmp6_ = submarine_xmlrpc_call ((SoupSession*) _tmp3_, _tmp4_, &_tmp5_, NULL);
	_g_hash_table_unref0 (vh);
	vh = _tmp5_;
	if (_tmp6_) {
		GHashTable* _tmp7_ = NULL;
		gconstpointer _tmp8_ = NULL;
		_tmp7_ = vh;
		_tmp8_ = g_hash_table_lookup (_tmp7_, "status");
		_tmp2_ = g_value_get_int ((GValue*) _tmp8_) == 200;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		gchar* nonce = NULL;
		GHashTable* _tmp9_ = NULL;
		gconstpointer _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		GHashTable* _tmp12_ = NULL;
		gconstpointer _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		gchar* formatted_password = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_ = NULL;
		const gchar* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		SoupMessage* _tmp24_ = NULL;
		gboolean _tmp25_ = FALSE;
		SoupSessionSync* _tmp26_ = NULL;
		SoupMessage* _tmp27_ = NULL;
		GHashTable* _tmp28_ = NULL;
		gboolean _tmp29_ = FALSE;
		_tmp9_ = vh;
		_tmp10_ = g_hash_table_lookup (_tmp9_, "nonce");
		_tmp11_ = g_strdup (g_value_get_string ((GValue*) _tmp10_));
		nonce = _tmp11_;
		_tmp12_ = vh;
		_tmp13_ = g_hash_table_lookup (_tmp12_, "session");
		_tmp14_ = g_strdup (g_value_get_string ((GValue*) _tmp13_));
		_g_free0 (self->priv->session_token);
		self->priv->session_token = _tmp14_;
		_tmp15_ = g_compute_checksum_for_string (G_CHECKSUM_MD5, password, (gsize) (-1));
		_tmp16_ = _tmp15_;
		_tmp17_ = nonce;
		_tmp18_ = g_strconcat (_tmp16_, _tmp17_, NULL);
		_tmp19_ = _tmp18_;
		_tmp20_ = g_compute_checksum_for_string (G_CHECKSUM_SHA256, _tmp19_, (gsize) (-1));
		_tmp21_ = _tmp20_;
		_g_free0 (_tmp19_);
		_g_free0 (_tmp16_);
		formatted_password = _tmp21_;
		_tmp22_ = self->priv->session_token;
		_tmp23_ = formatted_password;
		_tmp24_ = soup_xmlrpc_request_new (SUBMARINE_PODNAPISI_SERVER_XMLRPC_URI, "authenticate", G_TYPE_STRING, _tmp22_, G_TYPE_STRING, username, G_TYPE_STRING, _tmp23_, G_TYPE_INVALID);
		_g_object_unref0 (message);
		message = _tmp24_;
		_tmp26_ = self->priv->session;
		_tmp27_ = message;
		_tmp29_ = submarine_xmlrpc_call ((SoupSession*) _tmp26_, _tmp27_, &_tmp28_, NULL);
		_g_hash_table_unref0 (vh);
		vh = _tmp28_;
		if (_tmp29_) {
			GHashTable* _tmp30_ = NULL;
			gconstpointer _tmp31_ = NULL;
			_tmp30_ = vh;
			_tmp31_ = g_hash_table_lookup (_tmp30_, "status");
			_tmp25_ = g_value_get_int ((GValue*) _tmp31_) == 200;
		} else {
			_tmp25_ = FALSE;
		}
		if (_tmp25_) {
			result = TRUE;
			_g_free0 (formatted_password);
			_g_free0 (nonce);
			_g_object_unref0 (message);
			_g_hash_table_unref0 (vh);
			return result;
		}
		_g_free0 (formatted_password);
		_g_free0 (nonce);
	}
	result = FALSE;
	_g_object_unref0 (message);
	_g_hash_table_unref0 (vh);
	return result;
}


static void submarine_podnapisi_server_real_disconnect (SubmarineSubtitleServer* base) {
	SubmarinePodnapisiServer * self;
	self = (SubmarinePodnapisiServer*) base;
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		SubmarinePodnapisiServer* self;
		self = _data3_->self;
		_g_object_unref0 (_data3_->hash_file);
		_g_object_unref0 (_data3_->subtitles_found_map);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static GValue* _g_value_dup (GValue* self) {
	return g_boxed_copy (G_TYPE_VALUE, self);
}


static void _vala_GValue_free (GValue* self) {
	g_value_unset (self);
	g_free (self);
}


static gpointer __g_value_dup0 (gpointer self) {
	return self ? _g_value_dup (self) : NULL;
}


static GValue* ___lambda9_ (SubmarinePodnapisiServer* self, GeeList* request_batch) {
	GValue* result = NULL;
	GValueArray* values = NULL;
	GeeList* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GValueArray* _tmp3_ = NULL;
	SoupMessage* message = NULL;
	const gchar* _tmp18_ = NULL;
	GValueArray* _tmp19_ = NULL;
	SoupMessage* _tmp20_ = NULL;
	GValue v = {0};
	gboolean _tmp21_ = FALSE;
	SoupSessionSync* _tmp22_ = NULL;
	SoupMessage* _tmp23_ = NULL;
	GHashTable* _tmp24_ = NULL;
	gboolean _tmp25_ = FALSE;
	GValue _tmp26_ = {0};
	g_return_val_if_fail (request_batch != NULL, NULL);
	_tmp0_ = request_batch;
	_tmp1_ = gee_collection_get_size ((GeeCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_value_array_new ((guint) _tmp2_);
	values = _tmp3_;
	{
		GeeList* _request_list = NULL;
		GeeList* _tmp4_ = NULL;
		GeeList* _tmp5_ = NULL;
		gint _request_size = 0;
		GeeList* _tmp6_ = NULL;
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		gint _request_index = 0;
		_tmp4_ = request_batch;
		_tmp5_ = _g_object_ref0 (_tmp4_);
		_request_list = _tmp5_;
		_tmp6_ = _request_list;
		_tmp7_ = gee_collection_get_size ((GeeCollection*) _tmp6_);
		_tmp8_ = _tmp7_;
		_request_size = _tmp8_;
		_request_index = -1;
		while (TRUE) {
			gint _tmp9_ = 0;
			gint _tmp10_ = 0;
			gint _tmp11_ = 0;
			GValue* request = NULL;
			GeeList* _tmp12_ = NULL;
			gint _tmp13_ = 0;
			gpointer _tmp14_ = NULL;
			GValueArray* _tmp15_ = NULL;
			GValue* _tmp16_ = NULL;
			GValue _tmp17_ = {0};
			_tmp9_ = _request_index;
			_request_index = _tmp9_ + 1;
			_tmp10_ = _request_index;
			_tmp11_ = _request_size;
			if (!(_tmp10_ < _tmp11_)) {
				break;
			}
			_tmp12_ = _request_list;
			_tmp13_ = _request_index;
			_tmp14_ = gee_list_get (_tmp12_, _tmp13_);
			request = (GValue*) _tmp14_;
			_tmp15_ = values;
			_tmp16_ = request;
			_tmp17_ = *_tmp16_;
			g_value_array_append (_tmp15_, &_tmp17_);
			__vala_GValue_free0 (request);
		}
		_g_object_unref0 (_request_list);
	}
	_tmp18_ = self->priv->session_token;
	_tmp19_ = values;
	_tmp20_ = soup_xmlrpc_request_new (SUBMARINE_PODNAPISI_SERVER_XMLRPC_URI, "search", G_TYPE_STRING, _tmp18_, G_TYPE_VALUE_ARRAY, _tmp19_, G_TYPE_INVALID);
	message = _tmp20_;
	_tmp22_ = self->priv->session;
	_tmp23_ = message;
	_tmp25_ = submarine_xmlrpc_call ((SoupSession*) _tmp22_, _tmp23_, &_tmp24_, NULL);
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
	g_value_init (&_tmp26_, G_TYPE_HASH_TABLE);
	g_value_take_boxed (&_tmp26_, _tmp24_);
	v = _tmp26_;
	if (_tmp25_) {
		GValue _tmp27_ = {0};
		gconstpointer _tmp28_ = NULL;
		_tmp27_ = v;
		_tmp28_ = g_hash_table_lookup (g_value_get_boxed (&_tmp27_), "status");
		_tmp21_ = g_value_get_int ((GValue*) _tmp28_) == 200;
	} else {
		_tmp21_ = FALSE;
	}
	if (_tmp21_) {
		GValue _tmp29_ = {0};
		GValue* _tmp30_ = NULL;
		GValue* _tmp31_ = NULL;
		_tmp29_ = v;
		_tmp30_ = __g_value_dup0 (&_tmp29_);
		_tmp31_ = _tmp30_;
		G_IS_VALUE (&_tmp29_) ? (g_value_unset (&_tmp29_), NULL) : NULL;
		result = _tmp31_;
		_g_object_unref0 (message);
		_g_value_array_free0 (values);
		return result;
	}
	result = NULL;
	G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
	_g_object_unref0 (message);
	_g_value_array_free0 (values);
	return result;
}


static GValue* ____lambda9__submarine_subtitle_server_batch_request_method (GeeList* request_batch, gpointer self) {
	GValue* result;
	result = ___lambda9_ ((SubmarinePodnapisiServer*) self, request_batch);
	return result;
}


static gpointer _g_hash_table_ref0 (gpointer self) {
	return self ? g_hash_table_ref (self) : NULL;
}


static gint ___lambda10_ (Block3Data* _data3_, GValue* response) {
	SubmarinePodnapisiServer* self;
	gint result = 0;
	GHashTable* vh = NULL;
	GValue _tmp0_ = {0};
	GHashTable* _tmp1_ = NULL;
	gint results = 0;
	GHashTable* _tmp2_ = NULL;
	gconstpointer _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	self = _data3_->self;
	g_return_val_if_fail (response != NULL, 0);
	_tmp0_ = *response;
	_tmp1_ = _g_hash_table_ref0 (g_value_get_boxed (&_tmp0_));
	vh = _tmp1_;
	results = 0;
	_tmp2_ = vh;
	_tmp3_ = g_hash_table_lookup (_tmp2_, "results");
	_tmp4_ = g_hash_table_size (g_value_get_boxed ((GValue*) _tmp3_));
	if (((gint) _tmp4_) > 0) {
		GHashTable* _tmp5_ = NULL;
		gconstpointer _tmp6_ = NULL;
		GList* _tmp7_ = NULL;
		_tmp5_ = vh;
		_tmp6_ = g_hash_table_lookup (_tmp5_, "results");
		_tmp7_ = g_hash_table_get_keys (g_value_get_boxed ((GValue*) _tmp6_));
		{
			GList* hash_collection = NULL;
			GList* hash_it = NULL;
			hash_collection = _tmp7_;
			for (hash_it = hash_collection; hash_it != NULL; hash_it = hash_it->next) {
				gchar* _tmp8_ = NULL;
				gchar* hash = NULL;
				_tmp8_ = g_strdup ((const gchar*) hash_it->data);
				hash = _tmp8_;
				{
					GValueArray* va = NULL;
					GHashTable* _tmp9_ = NULL;
					gconstpointer _tmp10_ = NULL;
					const gchar* _tmp11_ = NULL;
					gconstpointer _tmp12_ = NULL;
					gconstpointer _tmp13_ = NULL;
					GValueArray* _tmp14_ = NULL;
					_tmp9_ = vh;
					_tmp10_ = g_hash_table_lookup (_tmp9_, "results");
					_tmp11_ = hash;
					_tmp12_ = g_hash_table_lookup (g_value_get_boxed ((GValue*) _tmp10_), _tmp11_);
					_tmp13_ = g_hash_table_lookup (g_value_get_boxed ((GValue*) _tmp12_), "subtitles");
					va = g_value_get_boxed ((GValue*) _tmp13_);
					_tmp14_ = va;
					{
						GValueArray* vresult_collection = NULL;
						guint vresult_index = 0U;
						vresult_collection = _tmp14_;
						for (vresult_index = 0; vresult_index < vresult_collection->n_values; vresult_index = vresult_index + 1) {
							GValue _tmp15_ = {0};
							GValue vresult = {0};
							if (G_IS_VALUE (g_value_array_get_nth (vresult_collection, vresult_index))) {
								g_value_init (&_tmp15_, G_VALUE_TYPE (g_value_array_get_nth (vresult_collection, vresult_index)));
								g_value_copy (g_value_array_get_nth (vresult_collection, vresult_index), &_tmp15_);
							} else {
								_tmp15_ = *g_value_array_get_nth (vresult_collection, vresult_index);
							}
							vresult = _tmp15_;
							{
								GHashTable* _result_ = NULL;
								GValue _tmp16_ = {0};
								GHashTable* _tmp17_ = NULL;
								SubmarineSubtitle* subtitle = NULL;
								SubmarineServerInfo _tmp18_ = {0};
								SubmarineServerInfo _tmp19_ = {0};
								GHashTable* _tmp20_ = NULL;
								GValue _tmp21_ = {0};
								SubmarineSubtitle* _tmp22_ = NULL;
								SubmarineSubtitle* _tmp23_ = NULL;
								SubmarineSubtitle* _tmp24_ = NULL;
								SubmarineSubtitle* _tmp25_ = NULL;
								GHashTable* _tmp26_ = NULL;
								gconstpointer _tmp27_ = NULL;
								SubmarineSubtitle* _tmp28_ = NULL;
								GHashTable* _tmp29_ = NULL;
								gconstpointer _tmp30_ = NULL;
								FILE* _tmp31_ = NULL;
								SubmarineSubtitle* _tmp32_ = NULL;
								gdouble _tmp33_ = 0.0;
								gdouble _tmp34_ = 0.0;
								GeeHashMultiMap* _tmp35_ = NULL;
								GeeHashMap* _tmp36_ = NULL;
								const gchar* _tmp37_ = NULL;
								gpointer _tmp38_ = NULL;
								GFile* _tmp39_ = NULL;
								SubmarineSubtitle* _tmp40_ = NULL;
								gint _tmp41_ = 0;
								_tmp16_ = vresult;
								_tmp17_ = _g_hash_table_ref0 (g_value_get_boxed (&_tmp16_));
								_result_ = _tmp17_;
								submarine_subtitle_server_get_info ((SubmarineSubtitleServer*) self, &_tmp18_);
								_tmp19_ = _tmp18_;
								_tmp20_ = _result_;
								g_value_init (&_tmp21_, G_TYPE_HASH_TABLE);
								g_value_set_boxed (&_tmp21_, _tmp20_);
								_tmp22_ = submarine_subtitle_new (&_tmp19_, &_tmp21_);
								_tmp23_ = _tmp22_;
								G_IS_VALUE (&_tmp21_) ? (g_value_unset (&_tmp21_), NULL) : NULL;
								subtitle = _tmp23_;
								_tmp24_ = subtitle;
								submarine_subtitle_set_format (_tmp24_, "");
								_tmp25_ = subtitle;
								_tmp26_ = _result_;
								_tmp27_ = g_hash_table_lookup (_tmp26_, "lang");
								submarine_subtitle_set_language (_tmp25_, g_value_get_string ((GValue*) _tmp27_));
								_tmp28_ = subtitle;
								_tmp29_ = _result_;
								_tmp30_ = g_hash_table_lookup (_tmp29_, "rating");
								submarine_subtitle_set_rating (_tmp28_, (gdouble) (g_value_get_int ((GValue*) _tmp30_) * 2));
								_tmp31_ = stdout;
								_tmp32_ = subtitle;
								_tmp33_ = submarine_subtitle_get_rating (_tmp32_);
								_tmp34_ = _tmp33_;
								fprintf (_tmp31_, "podnapisi rating: %f\n", _tmp34_);
								_tmp35_ = _data3_->subtitles_found_map;
								_tmp36_ = _data3_->hash_file;
								_tmp37_ = hash;
								_tmp38_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp36_, _tmp37_);
								_tmp39_ = (GFile*) _tmp38_;
								_tmp40_ = subtitle;
								gee_multi_map_set ((GeeMultiMap*) _tmp35_, _tmp39_, _tmp40_);
								_g_object_unref0 (_tmp39_);
								_tmp41_ = results;
								results = _tmp41_ + 1;
								_submarine_subtitle_unref0 (subtitle);
								_g_hash_table_unref0 (_result_);
								G_IS_VALUE (&vresult) ? (g_value_unset (&vresult), NULL) : NULL;
							}
						}
					}
					_g_free0 (hash);
				}
			}
			_g_list_free0 (hash_collection);
		}
	}
	result = results;
	_g_hash_table_unref0 (vh);
	return result;
}


static gint ____lambda10__submarine_subtitle_server_batch_response_method (GValue* response, gpointer self) {
	gint result;
	result = ___lambda10_ (self, response);
	return result;
}


static GeeMultiMap* submarine_podnapisi_server_real_search_multiple (SubmarineSubtitleServer* base, GeeCollection* files, GeeCollection* languages) {
	SubmarinePodnapisiServer * self;
	GeeMultiMap* result = NULL;
	Block3Data* _data3_;
	GeeHashMultiMap* _tmp0_ = NULL;
	GeeArrayList* requests = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeHashMap* _tmp2_ = NULL;
	static const gint MAX = 500;
	static const gint HITS = 5;
	GeeCollection* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	GeeHashMultiMap* _tmp26_ = NULL;
	GeeMultiMap* _tmp27_ = NULL;
	GError * _inner_error_ = NULL;
	self = (SubmarinePodnapisiServer*) base;
	g_return_val_if_fail (files != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->self = g_object_ref (self);
	_tmp0_ = gee_hash_multi_map_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_data3_->subtitles_found_map = _tmp0_;
	_tmp1_ = gee_array_list_new (G_TYPE_VALUE, (GBoxedCopyFunc) _g_value_dup, _vala_GValue_free, NULL, NULL, NULL);
	requests = _tmp1_;
	_tmp2_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_data3_->hash_file = _tmp2_;
	_tmp3_ = languages;
	_tmp4_ = submarine_podnapisi_server_filter_languages (self, _tmp3_);
	if (_tmp4_) {
		SubmarineSubtitleServerBatchRequestMethod request_method = NULL;
		void* request_method_target = NULL;
		GDestroyNotify request_method_target_destroy_notify = NULL;
		SubmarineSubtitleServerBatchResponseMethod response_method = NULL;
		void* response_method_target = NULL;
		GDestroyNotify response_method_target_destroy_notify = NULL;
		GeeArrayList* _tmp21_ = NULL;
		SubmarineSubtitleServerBatchRequestMethod _tmp22_ = NULL;
		void* _tmp22__target = NULL;
		SubmarineSubtitleServerBatchResponseMethod _tmp23_ = NULL;
		void* _tmp23__target = NULL;
		GeeArrayList* _tmp24_ = NULL;
		GeeArrayList* _tmp25_ = NULL;
		{
			GeeIterator* _file_it = NULL;
			GeeCollection* _tmp5_ = NULL;
			GeeIterator* _tmp6_ = NULL;
			_tmp5_ = files;
			_tmp6_ = gee_iterable_iterator ((GeeIterable*) _tmp5_);
			_file_it = _tmp6_;
			while (TRUE) {
				GeeIterator* _tmp7_ = NULL;
				gboolean _tmp8_ = FALSE;
				GFile* file = NULL;
				GeeIterator* _tmp9_ = NULL;
				gpointer _tmp10_ = NULL;
				_tmp7_ = _file_it;
				_tmp8_ = gee_iterator_next (_tmp7_);
				if (!_tmp8_) {
					break;
				}
				_tmp9_ = _file_it;
				_tmp10_ = gee_iterator_get (_tmp9_);
				file = (GFile*) _tmp10_;
				{
					guint64 _tmp11_ = 0ULL;
					GFile* _tmp12_ = NULL;
					guint64 _tmp13_ = 0ULL;
					gchar* hash = NULL;
					gchar* _tmp14_ = NULL;
					GeeArrayList* _tmp15_ = NULL;
					const gchar* _tmp16_ = NULL;
					GValue* _tmp17_ = NULL;
					GeeHashMap* _tmp18_ = NULL;
					const gchar* _tmp19_ = NULL;
					GFile* _tmp20_ = NULL;
					_tmp12_ = file;
					_tmp13_ = submarine_podnapisi_server_file_hash (self, _tmp12_, &_inner_error_);
					_tmp11_ = _tmp13_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch9_g_error;
					}
					_tmp14_ = g_strdup_printf ("%016llx", _tmp11_);
					hash = _tmp14_;
					_tmp15_ = requests;
					_tmp16_ = hash;
					_tmp17_ = g_new0 (GValue, 1);
					g_value_init (_tmp17_, G_TYPE_STRING);
					g_value_set_string (_tmp17_, _tmp16_);
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp15_, _tmp17_);
					__vala_GValue_free0 (_tmp17_);
					_tmp18_ = _data3_->hash_file;
					_tmp19_ = hash;
					_tmp20_ = file;
					gee_abstract_map_set ((GeeAbstractMap*) _tmp18_, _tmp19_, _tmp20_);
					_g_free0 (hash);
				}
				goto __finally9;
				__catch9_g_error:
				{
					GError* e = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					_g_error_free0 (e);
				}
				__finally9:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (file);
					_g_object_unref0 (_file_it);
					_g_object_unref0 (requests);
					block3_data_unref (_data3_);
					_data3_ = NULL;
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				_g_object_unref0 (file);
			}
			_g_object_unref0 (_file_it);
		}
		request_method = ____lambda9__submarine_subtitle_server_batch_request_method;
		request_method_target = g_object_ref (self);
		request_method_target_destroy_notify = g_object_unref;
		response_method = ____lambda10__submarine_subtitle_server_batch_response_method;
		response_method_target = block3_data_ref (_data3_);
		response_method_target_destroy_notify = block3_data_unref;
		_tmp21_ = requests;
		_tmp22_ = request_method;
		_tmp22__target = request_method_target;
		_tmp23_ = response_method;
		_tmp23__target = response_method_target;
		_tmp24_ = submarine_subtitle_server_batch_process ((SubmarineSubtitleServer*) self, (GeeList*) _tmp21_, _tmp22_, _tmp22__target, _tmp23_, _tmp23__target, MAX / HITS, MAX);
		_tmp25_ = _tmp24_;
		_g_object_unref0 (_tmp25_);
		(response_method_target_destroy_notify == NULL) ? NULL : (response_method_target_destroy_notify (response_method_target), NULL);
		response_method = NULL;
		response_method_target = NULL;
		response_method_target_destroy_notify = NULL;
		(request_method_target_destroy_notify == NULL) ? NULL : (request_method_target_destroy_notify (request_method_target), NULL);
		request_method = NULL;
		request_method_target = NULL;
		request_method_target_destroy_notify = NULL;
	}
	_tmp26_ = _data3_->subtitles_found_map;
	_tmp27_ = _g_object_ref0 ((GeeMultiMap*) _tmp26_);
	result = _tmp27_;
	_g_object_unref0 (requests);
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return result;
}


static gpointer _submarine_subtitle_ref0 (gpointer self) {
	return self ? submarine_subtitle_ref (self) : NULL;
}


static SubmarineSubtitle* submarine_podnapisi_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle) {
	SubmarinePodnapisiServer * self;
	SubmarineSubtitle* result = NULL;
	GValueArray* requests = NULL;
	GValueArray* _tmp0_ = NULL;
	GHashTable* vh = NULL;
	GHashTable* server_data = NULL;
	SubmarineSubtitle* _tmp1_ = NULL;
	GValue _tmp2_ = {0};
	GValue _tmp3_ = {0};
	GHashTable* _tmp4_ = NULL;
	GValueArray* _tmp5_ = NULL;
	GHashTable* _tmp6_ = NULL;
	gconstpointer _tmp7_ = NULL;
	GValue _tmp8_ = {0};
	SoupMessage* message = NULL;
	const gchar* _tmp9_ = NULL;
	GValueArray* _tmp10_ = NULL;
	SoupMessage* _tmp11_ = NULL;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	SoupSessionSync* _tmp14_ = NULL;
	SoupMessage* _tmp15_ = NULL;
	GHashTable* _tmp16_ = NULL;
	gboolean _tmp17_ = FALSE;
	self = (SubmarinePodnapisiServer*) base;
	g_return_val_if_fail (subtitle != NULL, NULL);
	_tmp0_ = g_value_array_new ((guint) 0);
	requests = _tmp0_;
	_tmp1_ = subtitle;
	submarine_subtitle_get_server_data (_tmp1_, &_tmp2_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _g_hash_table_ref0 (g_value_get_boxed (&_tmp3_));
	server_data = _tmp4_;
	_tmp5_ = requests;
	_tmp6_ = server_data;
	_tmp7_ = g_hash_table_lookup (_tmp6_, "id");
	_tmp8_ = *((GValue*) _tmp7_);
	g_value_array_append (_tmp5_, &_tmp8_);
	_tmp9_ = self->priv->session_token;
	_tmp10_ = requests;
	_tmp11_ = soup_xmlrpc_request_new (SUBMARINE_PODNAPISI_SERVER_XMLRPC_URI, "download", G_TYPE_STRING, _tmp9_, G_TYPE_VALUE_ARRAY, _tmp10_, G_TYPE_INVALID);
	message = _tmp11_;
	_tmp14_ = self->priv->session;
	_tmp15_ = message;
	_tmp17_ = submarine_xmlrpc_call ((SoupSession*) _tmp14_, _tmp15_, &_tmp16_, NULL);
	_g_hash_table_unref0 (vh);
	vh = _tmp16_;
	if (_tmp17_) {
		GHashTable* _tmp18_ = NULL;
		gconstpointer _tmp19_ = NULL;
		_tmp18_ = vh;
		_tmp19_ = g_hash_table_lookup (_tmp18_, "status");
		_tmp13_ = g_value_get_int ((GValue*) _tmp19_) == 200;
	} else {
		_tmp13_ = FALSE;
	}
	if (_tmp13_) {
		GHashTable* _tmp20_ = NULL;
		gconstpointer _tmp21_ = NULL;
		GValue* _tmp22_ = NULL;
		_tmp20_ = vh;
		_tmp21_ = g_hash_table_lookup (_tmp20_, "names");
		_tmp22_ = g_value_array_get_nth (g_value_get_boxed ((GValue*) _tmp21_), (guint) 0);
		_tmp12_ = _tmp22_ != NULL;
	} else {
		_tmp12_ = FALSE;
	}
	if (_tmp12_) {
		GHashTable* _result_ = NULL;
		GHashTable* _tmp23_ = NULL;
		gconstpointer _tmp24_ = NULL;
		GValue* _tmp25_ = NULL;
		GHashTable* _tmp26_ = NULL;
		GHashTable* _tmp27_ = NULL;
		gconstpointer _tmp28_ = NULL;
		gchar* _tmp29_ = NULL;
		gchar* _tmp30_ = NULL;
		SoupMessage* _tmp31_ = NULL;
		SoupSessionSync* _tmp32_ = NULL;
		SoupMessage* _tmp33_ = NULL;
		guint _tmp34_ = 0U;
		_tmp23_ = vh;
		_tmp24_ = g_hash_table_lookup (_tmp23_, "names");
		_tmp25_ = g_value_array_get_nth (g_value_get_boxed ((GValue*) _tmp24_), (guint) 0);
		_tmp26_ = _g_hash_table_ref0 (g_value_get_boxed (_tmp25_));
		_result_ = _tmp26_;
		_tmp27_ = _result_;
		_tmp28_ = g_hash_table_lookup (_tmp27_, "filename");
		_tmp29_ = g_strconcat (SUBMARINE_PODNAPISI_SERVER_DOWNLOAD_URI, g_value_get_string ((GValue*) _tmp28_), NULL);
		_tmp30_ = _tmp29_;
		_tmp31_ = soup_message_new ("GET", _tmp30_);
		_g_object_unref0 (message);
		message = _tmp31_;
		_g_free0 (_tmp30_);
		_tmp32_ = self->priv->session;
		_tmp33_ = message;
		_tmp34_ = soup_session_send_message ((SoupSession*) _tmp32_, _tmp33_);
		if (_tmp34_ == ((guint) 200)) {
			gchar* data = NULL;
			gchar* format = NULL;
			SoupMessage* _tmp35_ = NULL;
			SoupMessageBody* _tmp36_ = NULL;
			guint8* _tmp37_ = NULL;
			gint _tmp37__length1 = 0;
			gchar* _tmp38_ = NULL;
			gchar* _tmp39_ = NULL;
			gboolean _tmp40_ = FALSE;
			_tmp35_ = message;
			_tmp36_ = _tmp35_->response_body;
			_tmp37_ = _tmp36_->data;
			_tmp37__length1 = (gint) _tmp36_->length;
			_tmp40_ = submarine_podnapisi_server_inflate_subtitle (self, _tmp37_, _tmp37__length1, &_tmp38_, &_tmp39_);
			_g_free0 (format);
			format = _tmp38_;
			_g_free0 (data);
			data = _tmp39_;
			if (_tmp40_) {
				SubmarineSubtitle* _tmp41_ = NULL;
				const gchar* _tmp42_ = NULL;
				SubmarineSubtitle* _tmp43_ = NULL;
				const gchar* _tmp44_ = NULL;
				SubmarineSubtitle* _tmp45_ = NULL;
				SubmarineSubtitle* _tmp46_ = NULL;
				_tmp41_ = subtitle;
				_tmp42_ = format;
				submarine_subtitle_set_format (_tmp41_, _tmp42_);
				_tmp43_ = subtitle;
				_tmp44_ = data;
				submarine_subtitle_set_data (_tmp43_, _tmp44_);
				_tmp45_ = subtitle;
				_tmp46_ = _submarine_subtitle_ref0 (_tmp45_);
				result = _tmp46_;
				_g_free0 (format);
				_g_free0 (data);
				_g_hash_table_unref0 (_result_);
				_g_object_unref0 (message);
				_g_hash_table_unref0 (server_data);
				_g_hash_table_unref0 (vh);
				_g_value_array_free0 (requests);
				return result;
			}
			_g_free0 (format);
			_g_free0 (data);
		}
		_g_hash_table_unref0 (_result_);
	}
	result = NULL;
	_g_object_unref0 (message);
	_g_hash_table_unref0 (server_data);
	_g_hash_table_unref0 (vh);
	_g_value_array_free0 (requests);
	return result;
}


SubmarinePodnapisiServer* submarine_podnapisi_server_construct (GType object_type) {
	SubmarinePodnapisiServer * self = NULL;
	self = (SubmarinePodnapisiServer*) submarine_subtitle_server_construct (object_type);
	return self;
}


SubmarinePodnapisiServer* submarine_podnapisi_server_new (void) {
	return submarine_podnapisi_server_construct (SUBMARINE_TYPE_PODNAPISI_SERVER);
}


static GObject * submarine_podnapisi_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SubmarinePodnapisiServer * self;
	SubmarineServerInfo _tmp0_ = {0};
	SubmarineServerInfo _tmp1_ = {0};
	parent_class = G_OBJECT_CLASS (submarine_podnapisi_server_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_PODNAPISI_SERVER, SubmarinePodnapisiServer);
	submarine_server_info_init (&_tmp0_, "Podnapisi", "http://www.podnapisi.net/", "pn");
	_tmp1_ = _tmp0_;
	submarine_subtitle_server_set_info ((SubmarineSubtitleServer*) self, &_tmp1_);
	submarine_server_info_destroy (&_tmp1_);
	return obj;
}


static void submarine_podnapisi_server_class_init (SubmarinePodnapisiServerClass * klass) {
	submarine_podnapisi_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SubmarinePodnapisiServerPrivate));
	((SubmarineSubtitleServerClass *) klass)->connect = submarine_podnapisi_server_real_connect;
	((SubmarineSubtitleServerClass *) klass)->disconnect = submarine_podnapisi_server_real_disconnect;
	((SubmarineSubtitleServerClass *) klass)->search_multiple = submarine_podnapisi_server_real_search_multiple;
	((SubmarineSubtitleServerClass *) klass)->download = submarine_podnapisi_server_real_download;
	G_OBJECT_CLASS (klass)->constructor = submarine_podnapisi_server_constructor;
	G_OBJECT_CLASS (klass)->finalize = submarine_podnapisi_server_finalize;
}


static void submarine_podnapisi_server_instance_init (SubmarinePodnapisiServer * self) {
	self->priv = SUBMARINE_PODNAPISI_SERVER_GET_PRIVATE (self);
}


static void submarine_podnapisi_server_finalize (GObject* obj) {
	SubmarinePodnapisiServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_PODNAPISI_SERVER, SubmarinePodnapisiServer);
	_g_object_unref0 (self->priv->session);
	_g_free0 (self->priv->session_token);
	_g_object_unref0 (self->priv->supported_languages);
	_g_object_unref0 (self->priv->language_ids);
	_g_object_unref0 (self->priv->selected_languages);
	G_OBJECT_CLASS (submarine_podnapisi_server_parent_class)->finalize (obj);
}


GType submarine_podnapisi_server_get_type (void) {
	static volatile gsize submarine_podnapisi_server_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_podnapisi_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubmarinePodnapisiServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_podnapisi_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarinePodnapisiServer), 0, (GInstanceInitFunc) submarine_podnapisi_server_instance_init, NULL };
		GType submarine_podnapisi_server_type_id;
		submarine_podnapisi_server_type_id = g_type_register_static (SUBMARINE_TYPE_SUBTITLE_SERVER, "SubmarinePodnapisiServer", &g_define_type_info, 0);
		g_once_init_leave (&submarine_podnapisi_server_type_id__volatile, submarine_podnapisi_server_type_id);
	}
	return submarine_podnapisi_server_type_id__volatile;
}



