/* server.c generated by valac 0.28.0, the Vala compiler
 * generated from server.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gee.h>


#define SUBMARINE_TYPE_SERVER_INFO (submarine_server_info_get_type ())
typedef struct _SubmarineServerInfo SubmarineServerInfo;
#define _g_free0(var) (var = (g_free (var), NULL))

#define SUBMARINE_TYPE_SUBTITLE_SERVER (submarine_subtitle_server_get_type ())
#define SUBMARINE_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer))
#define SUBMARINE_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))
#define SUBMARINE_IS_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_IS_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_SUBTITLE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))

typedef struct _SubmarineSubtitleServer SubmarineSubtitleServer;
typedef struct _SubmarineSubtitleServerClass SubmarineSubtitleServerClass;
typedef struct _SubmarineSubtitleServerPrivate SubmarineSubtitleServerPrivate;

#define SUBMARINE_TYPE_SUBTITLE (submarine_subtitle_get_type ())
#define SUBMARINE_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitle))
#define SUBMARINE_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))
#define SUBMARINE_IS_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_IS_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_SUBTITLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))

typedef struct _SubmarineSubtitle SubmarineSubtitle;
typedef struct _SubmarineSubtitleClass SubmarineSubtitleClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _submarine_subtitle_unref0(var) ((var == NULL) ? NULL : (var = (submarine_subtitle_unref (var), NULL)))
#define __vala_GValue_free0(var) ((var == NULL) ? NULL : (var = (_vala_GValue_free (var), NULL)))

#define SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER (submarine_open_subtitles_server_get_type ())
#define SUBMARINE_OPEN_SUBTITLES_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER, SubmarineOpenSubtitlesServer))
#define SUBMARINE_OPEN_SUBTITLES_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER, SubmarineOpenSubtitlesServerClass))
#define SUBMARINE_IS_OPEN_SUBTITLES_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER))
#define SUBMARINE_IS_OPEN_SUBTITLES_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER))
#define SUBMARINE_OPEN_SUBTITLES_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_OPEN_SUBTITLES_SERVER, SubmarineOpenSubtitlesServerClass))

typedef struct _SubmarineOpenSubtitlesServer SubmarineOpenSubtitlesServer;
typedef struct _SubmarineOpenSubtitlesServerClass SubmarineOpenSubtitlesServerClass;

#define SUBMARINE_TYPE_PODNAPISI_SERVER (submarine_podnapisi_server_get_type ())
#define SUBMARINE_PODNAPISI_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_PODNAPISI_SERVER, SubmarinePodnapisiServer))
#define SUBMARINE_PODNAPISI_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_PODNAPISI_SERVER, SubmarinePodnapisiServerClass))
#define SUBMARINE_IS_PODNAPISI_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_PODNAPISI_SERVER))
#define SUBMARINE_IS_PODNAPISI_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_PODNAPISI_SERVER))
#define SUBMARINE_PODNAPISI_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_PODNAPISI_SERVER, SubmarinePodnapisiServerClass))

typedef struct _SubmarinePodnapisiServer SubmarinePodnapisiServer;
typedef struct _SubmarinePodnapisiServerClass SubmarinePodnapisiServerClass;

#define SUBMARINE_TYPE_SUB_DB_SERVER (submarine_sub_db_server_get_type ())
#define SUBMARINE_SUB_DB_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUB_DB_SERVER, SubmarineSubDBServer))
#define SUBMARINE_SUB_DB_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUB_DB_SERVER, SubmarineSubDBServerClass))
#define SUBMARINE_IS_SUB_DB_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUB_DB_SERVER))
#define SUBMARINE_IS_SUB_DB_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUB_DB_SERVER))
#define SUBMARINE_SUB_DB_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUB_DB_SERVER, SubmarineSubDBServerClass))

typedef struct _SubmarineSubDBServer SubmarineSubDBServer;
typedef struct _SubmarineSubDBServerClass SubmarineSubDBServerClass;

#define SUBMARINE_TYPE_BIERDOPJE_SERVER (submarine_bierdopje_server_get_type ())
#define SUBMARINE_BIERDOPJE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_BIERDOPJE_SERVER, SubmarineBierdopjeServer))
#define SUBMARINE_BIERDOPJE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_BIERDOPJE_SERVER, SubmarineBierdopjeServerClass))
#define SUBMARINE_IS_BIERDOPJE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_BIERDOPJE_SERVER))
#define SUBMARINE_IS_BIERDOPJE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_BIERDOPJE_SERVER))
#define SUBMARINE_BIERDOPJE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_BIERDOPJE_SERVER, SubmarineBierdopjeServerClass))

typedef struct _SubmarineBierdopjeServer SubmarineBierdopjeServer;
typedef struct _SubmarineBierdopjeServerClass SubmarineBierdopjeServerClass;

#define SUBMARINE_TYPE_DIV_XSUBS_SERVER (submarine_div_xsubs_server_get_type ())
#define SUBMARINE_DIV_XSUBS_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_DIV_XSUBS_SERVER, SubmarineDivXsubsServer))
#define SUBMARINE_DIV_XSUBS_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_DIV_XSUBS_SERVER, SubmarineDivXsubsServerClass))
#define SUBMARINE_IS_DIV_XSUBS_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_DIV_XSUBS_SERVER))
#define SUBMARINE_IS_DIV_XSUBS_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_DIV_XSUBS_SERVER))
#define SUBMARINE_DIV_XSUBS_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_DIV_XSUBS_SERVER, SubmarineDivXsubsServerClass))

typedef struct _SubmarineDivXsubsServer SubmarineDivXsubsServer;
typedef struct _SubmarineDivXsubsServerClass SubmarineDivXsubsServerClass;

#define SUBMARINE_TYPE_SUBTITULOS_ES_SERVER (submarine_subtitulos_es_server_get_type ())
#define SUBMARINE_SUBTITULOS_ES_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER, SubmarineSubtitulosESServer))
#define SUBMARINE_SUBTITULOS_ES_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER, SubmarineSubtitulosESServerClass))
#define SUBMARINE_IS_SUBTITULOS_ES_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER))
#define SUBMARINE_IS_SUBTITULOS_ES_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER))
#define SUBMARINE_SUBTITULOS_ES_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER, SubmarineSubtitulosESServerClass))

typedef struct _SubmarineSubtitulosESServer SubmarineSubtitulosESServer;
typedef struct _SubmarineSubtitulosESServerClass SubmarineSubtitulosESServerClass;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _SubmarineServerInfo {
	gchar* _name;
	gchar* _address;
	gchar* _code;
};

struct _SubmarineSubtitleServer {
	GObject parent_instance;
	SubmarineSubtitleServerPrivate * priv;
};

struct _SubmarineSubtitleServerClass {
	GObjectClass parent_class;
	gboolean (*connect) (SubmarineSubtitleServer* self);
	void (*disconnect) (SubmarineSubtitleServer* self);
	GeeSet* (*search) (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
	GeeMultiMap* (*search_multiple) (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
	SubmarineSubtitle* (*download) (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
	GeeSet* (*download_multiple) (SubmarineSubtitleServer* self, GeeCollection* subtitles);
};

struct _SubmarineSubtitleServerPrivate {
	SubmarineServerInfo _info;
};

typedef GValue* (*SubmarineSubtitleServerBatchRequestMethod) (GeeList* request_batch, void* user_data);
typedef gint (*SubmarineSubtitleServerBatchResponseMethod) (GValue* response, void* user_data);

static gpointer submarine_subtitle_server_parent_class = NULL;
extern GeeList* submarine_all_server_codes;
GeeList* submarine_all_server_codes = NULL;
extern GeeMap* submarine_server_infos;
GeeMap* submarine_server_infos = NULL;

GType submarine_server_info_get_type (void) G_GNUC_CONST;
SubmarineServerInfo* submarine_server_info_dup (const SubmarineServerInfo* self);
void submarine_server_info_free (SubmarineServerInfo* self);
void submarine_server_info_copy (const SubmarineServerInfo* self, SubmarineServerInfo* dest);
void submarine_server_info_destroy (SubmarineServerInfo* self);
void submarine_server_info_init (SubmarineServerInfo *self, const gchar* name, const gchar* address, const gchar* code);
static void submarine_server_info_set_name (SubmarineServerInfo* self, const gchar* value);
static void submarine_server_info_set_address (SubmarineServerInfo* self, const gchar* value);
static void submarine_server_info_set_code (SubmarineServerInfo* self, const gchar* value);
const gchar* submarine_server_info_get_name (SubmarineServerInfo* self);
const gchar* submarine_server_info_get_address (SubmarineServerInfo* self);
const gchar* submarine_server_info_get_code (SubmarineServerInfo* self);
GType submarine_subtitle_server_get_type (void) G_GNUC_CONST;
gpointer submarine_subtitle_ref (gpointer instance);
void submarine_subtitle_unref (gpointer instance);
GParamSpec* submarine_param_spec_subtitle (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_subtitle (GValue* value, gpointer v_object);
void submarine_value_take_subtitle (GValue* value, gpointer v_object);
gpointer submarine_value_get_subtitle (const GValue* value);
GType submarine_subtitle_get_type (void) G_GNUC_CONST;
#define SUBMARINE_SUBTITLE_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerPrivate))
enum  {
	SUBMARINE_SUBTITLE_SERVER_DUMMY_PROPERTY,
	SUBMARINE_SUBTITLE_SERVER_INFO,
	SUBMARINE_SUBTITLE_SERVER_NAME,
	SUBMARINE_SUBTITLE_SERVER_ADDRESS,
	SUBMARINE_SUBTITLE_SERVER_CODE
};
gboolean submarine_subtitle_server_connect (SubmarineSubtitleServer* self);
static gboolean submarine_subtitle_server_real_connect (SubmarineSubtitleServer* self);
void submarine_subtitle_server_disconnect (SubmarineSubtitleServer* self);
static void submarine_subtitle_server_real_disconnect (SubmarineSubtitleServer* self);
GeeSet* submarine_subtitle_server_search (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
static GeeSet* submarine_subtitle_server_real_search (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
GeeMultiMap* submarine_subtitle_server_search_multiple (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
static GeeMultiMap* submarine_subtitle_server_real_search_multiple (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
SubmarineSubtitle* submarine_subtitle_server_download (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
static SubmarineSubtitle* submarine_subtitle_server_real_download (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
GeeSet* submarine_subtitle_server_download_multiple (SubmarineSubtitleServer* self, GeeCollection* subtitles);
static GeeSet* submarine_subtitle_server_real_download_multiple (SubmarineSubtitleServer* self, GeeCollection* subtitles);
GeeArrayList* submarine_subtitle_server_batch_process (SubmarineSubtitleServer* self, GeeList* requests, SubmarineSubtitleServerBatchRequestMethod request_method, void* request_method_target, SubmarineSubtitleServerBatchResponseMethod response_method, void* response_method_target, gint max_request_size, gint max_response_size);
static GValue* _g_value_dup (GValue* self);
static void _vala_GValue_free (GValue* self);
SubmarineSubtitleServer* submarine_subtitle_server_construct (GType object_type);
void submarine_subtitle_server_get_info (SubmarineSubtitleServer* self, SubmarineServerInfo* result);
void submarine_subtitle_server_set_info (SubmarineSubtitleServer* self, SubmarineServerInfo* value);
const gchar* submarine_subtitle_server_get_name (SubmarineSubtitleServer* self);
const gchar* submarine_subtitle_server_get_address (SubmarineSubtitleServer* self);
const gchar* submarine_subtitle_server_get_code (SubmarineSubtitleServer* self);
static void submarine_subtitle_server_finalize (GObject* obj);
static void _vala_submarine_subtitle_server_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_submarine_subtitle_server_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GeeSet* submarine_get_servers (void);
SubmarineOpenSubtitlesServer* submarine_open_subtitles_server_new (void);
SubmarineOpenSubtitlesServer* submarine_open_subtitles_server_construct (GType object_type);
GType submarine_open_subtitles_server_get_type (void) G_GNUC_CONST;
SubmarinePodnapisiServer* submarine_podnapisi_server_new (void);
SubmarinePodnapisiServer* submarine_podnapisi_server_construct (GType object_type);
GType submarine_podnapisi_server_get_type (void) G_GNUC_CONST;
SubmarineSubDBServer* submarine_sub_db_server_new (void);
SubmarineSubDBServer* submarine_sub_db_server_construct (GType object_type);
GType submarine_sub_db_server_get_type (void) G_GNUC_CONST;
SubmarineBierdopjeServer* submarine_bierdopje_server_new (void);
SubmarineBierdopjeServer* submarine_bierdopje_server_construct (GType object_type);
GType submarine_bierdopje_server_get_type (void) G_GNUC_CONST;
SubmarineDivXsubsServer* submarine_div_xsubs_server_new (void);
SubmarineDivXsubsServer* submarine_div_xsubs_server_construct (GType object_type);
GType submarine_div_xsubs_server_get_type (void) G_GNUC_CONST;
SubmarineSubtitulosESServer* submarine_subtitulos_es_server_new (void);
SubmarineSubtitulosESServer* submarine_subtitulos_es_server_construct (GType object_type);
GType submarine_subtitulos_es_server_get_type (void) G_GNUC_CONST;
GeeList* submarine_get_server_codes (void);
static gint ___lambda11_ (const gchar* a, const gchar* b);
static gint ____lambda11__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self);
SubmarineServerInfo* submarine_get_server_info (const gchar* server_code);


void submarine_server_info_init (SubmarineServerInfo *self, const gchar* name, const gchar* address, const gchar* code) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_if_fail (name != NULL);
	g_return_if_fail (address != NULL);
	g_return_if_fail (code != NULL);
	memset (self, 0, sizeof (SubmarineServerInfo));
	_tmp0_ = name;
	submarine_server_info_set_name (&(*self), _tmp0_);
	_tmp1_ = address;
	submarine_server_info_set_address (&(*self), _tmp1_);
	_tmp2_ = code;
	submarine_server_info_set_code (&(*self), _tmp2_);
}


const gchar* submarine_server_info_get_name (SubmarineServerInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (*self)._name;
	result = _tmp0_;
	return result;
}


static void submarine_server_info_set_name (SubmarineServerInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*self)._name);
	(*self)._name = _tmp1_;
}


const gchar* submarine_server_info_get_address (SubmarineServerInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (*self)._address;
	result = _tmp0_;
	return result;
}


static void submarine_server_info_set_address (SubmarineServerInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*self)._address);
	(*self)._address = _tmp1_;
}


const gchar* submarine_server_info_get_code (SubmarineServerInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (*self)._code;
	result = _tmp0_;
	return result;
}


static void submarine_server_info_set_code (SubmarineServerInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*self)._code);
	(*self)._code = _tmp1_;
}


void submarine_server_info_copy (const SubmarineServerInfo* self, SubmarineServerInfo* dest) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	_tmp0_ = (*self)._name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest)._name);
	(*dest)._name = _tmp1_;
	_tmp2_ = (*self)._address;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 ((*dest)._address);
	(*dest)._address = _tmp3_;
	_tmp4_ = (*self)._code;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 ((*dest)._code);
	(*dest)._code = _tmp5_;
}


void submarine_server_info_destroy (SubmarineServerInfo* self) {
	_g_free0 ((*self)._name);
	_g_free0 ((*self)._address);
	_g_free0 ((*self)._code);
}


SubmarineServerInfo* submarine_server_info_dup (const SubmarineServerInfo* self) {
	SubmarineServerInfo* dup;
	dup = g_new0 (SubmarineServerInfo, 1);
	submarine_server_info_copy (self, dup);
	return dup;
}


void submarine_server_info_free (SubmarineServerInfo* self) {
	submarine_server_info_destroy (self);
	g_free (self);
}


GType submarine_server_info_get_type (void) {
	static volatile gsize submarine_server_info_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_server_info_type_id__volatile)) {
		GType submarine_server_info_type_id;
		submarine_server_info_type_id = g_boxed_type_register_static ("SubmarineServerInfo", (GBoxedCopyFunc) submarine_server_info_dup, (GBoxedFreeFunc) submarine_server_info_free);
		g_once_init_leave (&submarine_server_info_type_id__volatile, submarine_server_info_type_id);
	}
	return submarine_server_info_type_id__volatile;
}


static gboolean submarine_subtitle_server_real_connect (SubmarineSubtitleServer* self) {
	g_critical ("Type `%s' does not implement abstract method `submarine_subtitle_server_connect'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return FALSE;
}


gboolean submarine_subtitle_server_connect (SubmarineSubtitleServer* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	return SUBMARINE_SUBTITLE_SERVER_GET_CLASS (self)->connect (self);
}


static void submarine_subtitle_server_real_disconnect (SubmarineSubtitleServer* self) {
	g_critical ("Type `%s' does not implement abstract method `submarine_subtitle_server_disconnect'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return;
}


void submarine_subtitle_server_disconnect (SubmarineSubtitleServer* self) {
	g_return_if_fail (self != NULL);
	SUBMARINE_SUBTITLE_SERVER_GET_CLASS (self)->disconnect (self);
}


static GeeSet* submarine_subtitle_server_real_search (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages) {
	GeeSet* result = NULL;
	GeeHashSet* subtitles_found = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GeeHashSet* files = NULL;
	GeeHashSet* _tmp1_ = NULL;
	GeeHashSet* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	GeeMultiMap* subtitles_found_map = NULL;
	GeeHashSet* _tmp4_ = NULL;
	GeeCollection* _tmp5_ = NULL;
	GeeMultiMap* _tmp6_ = NULL;
	GeeMultiMap* _tmp7_ = NULL;
	GFile* _tmp8_ = NULL;
	gboolean _tmp9_ = FALSE;
	g_return_val_if_fail (file != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_found = _tmp0_;
	_tmp1_ = gee_hash_set_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	files = _tmp1_;
	_tmp2_ = files;
	_tmp3_ = file;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp2_, _tmp3_);
	_tmp4_ = files;
	_tmp5_ = languages;
	_tmp6_ = submarine_subtitle_server_search_multiple (self, (GeeCollection*) _tmp4_, _tmp5_);
	subtitles_found_map = _tmp6_;
	_tmp7_ = subtitles_found_map;
	_tmp8_ = file;
	_tmp9_ = gee_multi_map_contains (_tmp7_, _tmp8_);
	if (_tmp9_) {
		GeeHashSet* _tmp10_ = NULL;
		GeeMultiMap* _tmp11_ = NULL;
		GFile* _tmp12_ = NULL;
		GeeCollection* _tmp13_ = NULL;
		GeeCollection* _tmp14_ = NULL;
		_tmp10_ = subtitles_found;
		_tmp11_ = subtitles_found_map;
		_tmp12_ = file;
		_tmp13_ = gee_multi_map_get (_tmp11_, _tmp12_);
		_tmp14_ = _tmp13_;
		gee_collection_add_all ((GeeCollection*) _tmp10_, _tmp14_);
		_g_object_unref0 (_tmp14_);
	}
	result = (GeeSet*) subtitles_found;
	_g_object_unref0 (subtitles_found_map);
	_g_object_unref0 (files);
	return result;
}


GeeSet* submarine_subtitle_server_search (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages) {
	g_return_val_if_fail (self != NULL, NULL);
	return SUBMARINE_SUBTITLE_SERVER_GET_CLASS (self)->search (self, file, languages);
}


static GeeMultiMap* submarine_subtitle_server_real_search_multiple (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages) {
	GeeMultiMap* result = NULL;
	GeeHashMultiMap* subtitles_found_map = NULL;
	GeeHashMultiMap* _tmp0_ = NULL;
	g_return_val_if_fail (files != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_tmp0_ = gee_hash_multi_map_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_found_map = _tmp0_;
	{
		GeeIterator* _file_it = NULL;
		GeeCollection* _tmp1_ = NULL;
		GeeIterator* _tmp2_ = NULL;
		_tmp1_ = files;
		_tmp2_ = gee_iterable_iterator ((GeeIterable*) _tmp1_);
		_file_it = _tmp2_;
		while (TRUE) {
			GeeIterator* _tmp3_ = NULL;
			gboolean _tmp4_ = FALSE;
			GFile* file = NULL;
			GeeIterator* _tmp5_ = NULL;
			gpointer _tmp6_ = NULL;
			_tmp3_ = _file_it;
			_tmp4_ = gee_iterator_next (_tmp3_);
			if (!_tmp4_) {
				break;
			}
			_tmp5_ = _file_it;
			_tmp6_ = gee_iterator_get (_tmp5_);
			file = (GFile*) _tmp6_;
			{
				GeeIterator* _subtitle_it = NULL;
				GFile* _tmp7_ = NULL;
				GeeCollection* _tmp8_ = NULL;
				GeeSet* _tmp9_ = NULL;
				GeeSet* _tmp10_ = NULL;
				GeeIterator* _tmp11_ = NULL;
				GeeIterator* _tmp12_ = NULL;
				_tmp7_ = file;
				_tmp8_ = languages;
				_tmp9_ = submarine_subtitle_server_search (self, _tmp7_, _tmp8_);
				_tmp10_ = _tmp9_;
				_tmp11_ = gee_iterable_iterator ((GeeIterable*) _tmp10_);
				_tmp12_ = _tmp11_;
				_g_object_unref0 (_tmp10_);
				_subtitle_it = _tmp12_;
				while (TRUE) {
					GeeIterator* _tmp13_ = NULL;
					gboolean _tmp14_ = FALSE;
					SubmarineSubtitle* subtitle = NULL;
					GeeIterator* _tmp15_ = NULL;
					gpointer _tmp16_ = NULL;
					GeeHashMultiMap* _tmp17_ = NULL;
					GFile* _tmp18_ = NULL;
					SubmarineSubtitle* _tmp19_ = NULL;
					_tmp13_ = _subtitle_it;
					_tmp14_ = gee_iterator_next (_tmp13_);
					if (!_tmp14_) {
						break;
					}
					_tmp15_ = _subtitle_it;
					_tmp16_ = gee_iterator_get (_tmp15_);
					subtitle = (SubmarineSubtitle*) _tmp16_;
					_tmp17_ = subtitles_found_map;
					_tmp18_ = file;
					_tmp19_ = subtitle;
					gee_multi_map_set ((GeeMultiMap*) _tmp17_, _tmp18_, _tmp19_);
					_submarine_subtitle_unref0 (subtitle);
				}
				_g_object_unref0 (_subtitle_it);
			}
			_g_object_unref0 (file);
		}
		_g_object_unref0 (_file_it);
	}
	result = (GeeMultiMap*) subtitles_found_map;
	return result;
}


GeeMultiMap* submarine_subtitle_server_search_multiple (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages) {
	g_return_val_if_fail (self != NULL, NULL);
	return SUBMARINE_SUBTITLE_SERVER_GET_CLASS (self)->search_multiple (self, files, languages);
}


static SubmarineSubtitle* submarine_subtitle_server_real_download (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle) {
	SubmarineSubtitle* result = NULL;
	GeeHashSet* subtitles = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GeeHashSet* _tmp1_ = NULL;
	SubmarineSubtitle* _tmp2_ = NULL;
	GeeSet* subtitles_downloaded = NULL;
	GeeHashSet* _tmp3_ = NULL;
	GeeSet* _tmp4_ = NULL;
	GeeSet* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	g_return_val_if_fail (subtitle != NULL, NULL);
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles = _tmp0_;
	_tmp1_ = subtitles;
	_tmp2_ = subtitle;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp1_, _tmp2_);
	_tmp3_ = subtitles;
	_tmp4_ = submarine_subtitle_server_download_multiple (self, (GeeCollection*) _tmp3_);
	subtitles_downloaded = _tmp4_;
	_tmp5_ = subtitles_downloaded;
	_tmp6_ = gee_collection_get_is_empty ((GeeCollection*) _tmp5_);
	_tmp7_ = _tmp6_;
	if (!_tmp7_) {
		GeeIterator* it = NULL;
		GeeSet* _tmp8_ = NULL;
		GeeIterator* _tmp9_ = NULL;
		GeeIterator* _tmp10_ = NULL;
		GeeIterator* _tmp11_ = NULL;
		gpointer _tmp12_ = NULL;
		_tmp8_ = subtitles_downloaded;
		_tmp9_ = gee_iterable_iterator ((GeeIterable*) _tmp8_);
		it = _tmp9_;
		_tmp10_ = it;
		gee_iterator_next (_tmp10_);
		_tmp11_ = it;
		_tmp12_ = gee_iterator_get (_tmp11_);
		result = (SubmarineSubtitle*) _tmp12_;
		_g_object_unref0 (it);
		_g_object_unref0 (subtitles_downloaded);
		_g_object_unref0 (subtitles);
		return result;
	}
	result = NULL;
	_g_object_unref0 (subtitles_downloaded);
	_g_object_unref0 (subtitles);
	return result;
}


SubmarineSubtitle* submarine_subtitle_server_download (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle) {
	g_return_val_if_fail (self != NULL, NULL);
	return SUBMARINE_SUBTITLE_SERVER_GET_CLASS (self)->download (self, subtitle);
}


static GeeSet* submarine_subtitle_server_real_download_multiple (SubmarineSubtitleServer* self, GeeCollection* subtitles) {
	GeeSet* result = NULL;
	GeeHashSet* subtitles_downloaded = NULL;
	GeeHashSet* _tmp0_ = NULL;
	g_return_val_if_fail (subtitles != NULL, NULL);
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_downloaded = _tmp0_;
	{
		GeeIterator* _subtitle_it = NULL;
		GeeCollection* _tmp1_ = NULL;
		GeeIterator* _tmp2_ = NULL;
		_tmp1_ = subtitles;
		_tmp2_ = gee_iterable_iterator ((GeeIterable*) _tmp1_);
		_subtitle_it = _tmp2_;
		while (TRUE) {
			GeeIterator* _tmp3_ = NULL;
			gboolean _tmp4_ = FALSE;
			SubmarineSubtitle* subtitle = NULL;
			GeeIterator* _tmp5_ = NULL;
			gpointer _tmp6_ = NULL;
			SubmarineSubtitle* subtitle_downloaded = NULL;
			SubmarineSubtitle* _tmp7_ = NULL;
			SubmarineSubtitle* _tmp8_ = NULL;
			SubmarineSubtitle* _tmp9_ = NULL;
			_tmp3_ = _subtitle_it;
			_tmp4_ = gee_iterator_next (_tmp3_);
			if (!_tmp4_) {
				break;
			}
			_tmp5_ = _subtitle_it;
			_tmp6_ = gee_iterator_get (_tmp5_);
			subtitle = (SubmarineSubtitle*) _tmp6_;
			_tmp7_ = subtitle;
			_tmp8_ = submarine_subtitle_server_download (self, _tmp7_);
			subtitle_downloaded = _tmp8_;
			_tmp9_ = subtitle_downloaded;
			if (_tmp9_ != NULL) {
				GeeHashSet* _tmp10_ = NULL;
				SubmarineSubtitle* _tmp11_ = NULL;
				_tmp10_ = subtitles_downloaded;
				_tmp11_ = subtitle_downloaded;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, _tmp11_);
			}
			_submarine_subtitle_unref0 (subtitle_downloaded);
			_submarine_subtitle_unref0 (subtitle);
		}
		_g_object_unref0 (_subtitle_it);
	}
	result = (GeeSet*) subtitles_downloaded;
	return result;
}


GeeSet* submarine_subtitle_server_download_multiple (SubmarineSubtitleServer* self, GeeCollection* subtitles) {
	g_return_val_if_fail (self != NULL, NULL);
	return SUBMARINE_SUBTITLE_SERVER_GET_CLASS (self)->download_multiple (self, subtitles);
}


static GValue* _g_value_dup (GValue* self) {
	return g_boxed_copy (G_TYPE_VALUE, self);
}


static void _vala_GValue_free (GValue* self) {
	g_value_unset (self);
	g_free (self);
}


GeeArrayList* submarine_subtitle_server_batch_process (SubmarineSubtitleServer* self, GeeList* requests, SubmarineSubtitleServerBatchRequestMethod request_method, void* request_method_target, SubmarineSubtitleServerBatchResponseMethod response_method, void* response_method_target, gint max_request_size, gint max_response_size) {
	GeeArrayList* result = NULL;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint batch_size = 0;
	gint _tmp2_ = 0;
	GeeArrayList* responses = NULL;
	GeeArrayList* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gint request_index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (requests != NULL, NULL);
	_tmp0_ = max_request_size;
	_vala_return_val_if_fail (_tmp0_ > 0, "max_request_size > 0", NULL);
	_tmp1_ = max_response_size;
	_vala_return_val_if_fail (_tmp1_ >= 0, "max_response_size >= 0", NULL);
	_tmp2_ = max_request_size;
	batch_size = _tmp2_;
	_tmp3_ = gee_array_list_new (G_TYPE_VALUE, (GBoxedCopyFunc) _g_value_dup, _vala_GValue_free, NULL, NULL, NULL);
	responses = _tmp3_;
	_tmp5_ = max_response_size;
	if (_tmp5_ > 0) {
		gint _tmp6_ = 0;
		_tmp6_ = max_response_size;
		_tmp4_ = _tmp6_;
	} else {
		gint _tmp7_ = 0;
		_tmp7_ = max_request_size;
		_tmp4_ = _tmp7_;
	}
	max_response_size = _tmp4_;
	request_index = 0;
	while (TRUE) {
		gint _tmp8_ = 0;
		GeeList* _tmp9_ = NULL;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		GeeList* _tmp13_ = NULL;
		gint _tmp14_ = 0;
		gint _tmp15_ = 0;
		gint _tmp16_ = 0;
		gint _tmp17_ = 0;
		GeeArrayList* requests_batch = NULL;
		GeeArrayList* _tmp23_ = NULL;
		GValue* response = NULL;
		SubmarineSubtitleServerBatchRequestMethod _tmp35_ = NULL;
		void* _tmp35__target = NULL;
		GeeList* _tmp36_ = NULL;
		GValue* _tmp37_ = NULL;
		gboolean advance = FALSE;
		GValue* _tmp38_ = NULL;
		gboolean _tmp53_ = FALSE;
		_tmp8_ = request_index;
		_tmp9_ = requests;
		_tmp10_ = gee_collection_get_size ((GeeCollection*) _tmp9_);
		_tmp11_ = _tmp10_;
		if (!(_tmp8_ < _tmp11_)) {
			break;
		}
		_tmp13_ = requests;
		_tmp14_ = gee_collection_get_size ((GeeCollection*) _tmp13_);
		_tmp15_ = _tmp14_;
		_tmp16_ = request_index;
		_tmp17_ = batch_size;
		if ((_tmp15_ - _tmp16_) < _tmp17_) {
			GeeList* _tmp18_ = NULL;
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			gint _tmp21_ = 0;
			_tmp18_ = requests;
			_tmp19_ = gee_collection_get_size ((GeeCollection*) _tmp18_);
			_tmp20_ = _tmp19_;
			_tmp21_ = request_index;
			_tmp12_ = _tmp20_ - _tmp21_;
		} else {
			gint _tmp22_ = 0;
			_tmp22_ = batch_size;
			_tmp12_ = _tmp22_;
		}
		batch_size = _tmp12_;
		_tmp23_ = gee_array_list_new (G_TYPE_VALUE, (GBoxedCopyFunc) _g_value_dup, _vala_GValue_free, NULL, NULL, NULL);
		requests_batch = _tmp23_;
		{
			gint i = 0;
			gint _tmp24_ = 0;
			_tmp24_ = request_index;
			i = _tmp24_;
			{
				gboolean _tmp25_ = FALSE;
				_tmp25_ = TRUE;
				while (TRUE) {
					gint _tmp27_ = 0;
					gint _tmp28_ = 0;
					gint _tmp29_ = 0;
					GeeArrayList* _tmp30_ = NULL;
					GeeList* _tmp31_ = NULL;
					gint _tmp32_ = 0;
					gpointer _tmp33_ = NULL;
					GValue* _tmp34_ = NULL;
					if (!_tmp25_) {
						gint _tmp26_ = 0;
						_tmp26_ = i;
						i = _tmp26_ + 1;
					}
					_tmp25_ = FALSE;
					_tmp27_ = i;
					_tmp28_ = request_index;
					_tmp29_ = batch_size;
					if (!(_tmp27_ < (_tmp28_ + _tmp29_))) {
						break;
					}
					_tmp30_ = requests_batch;
					_tmp31_ = requests;
					_tmp32_ = i;
					_tmp33_ = gee_list_get (_tmp31_, _tmp32_);
					_tmp34_ = (GValue*) _tmp33_;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp30_, _tmp34_);
					__vala_GValue_free0 (_tmp34_);
				}
			}
		}
		_tmp35_ = request_method;
		_tmp35__target = request_method_target;
		_tmp36_ = requests;
		_tmp37_ = _tmp35_ (_tmp36_, _tmp35__target);
		response = _tmp37_;
		advance = TRUE;
		_tmp38_ = response;
		if (_tmp38_ != NULL) {
			gint results = 0;
			SubmarineSubtitleServerBatchResponseMethod _tmp39_ = NULL;
			void* _tmp39__target = NULL;
			GValue* _tmp40_ = NULL;
			GValue _tmp41_ = {0};
			gint _tmp42_ = 0;
			gboolean _tmp43_ = FALSE;
			gint _tmp44_ = 0;
			gint _tmp45_ = 0;
			_tmp39_ = response_method;
			_tmp39__target = response_method_target;
			_tmp40_ = response;
			_tmp41_ = *_tmp40_;
			_tmp42_ = _tmp39_ (&_tmp41_, _tmp39__target);
			results = _tmp42_;
			_tmp44_ = results;
			_tmp45_ = max_response_size;
			if (_tmp44_ < _tmp45_) {
				_tmp43_ = TRUE;
			} else {
				gint _tmp46_ = 0;
				_tmp46_ = batch_size;
				_tmp43_ = _tmp46_ == 1;
			}
			if (_tmp43_) {
				GeeArrayList* _tmp47_ = NULL;
				GValue* _tmp48_ = NULL;
				_tmp47_ = responses;
				_tmp48_ = response;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp47_, _tmp48_);
			} else {
				gint _tmp49_ = 0;
				gint _tmp50_ = 0;
				gint _tmp51_ = 0;
				_tmp49_ = batch_size;
				batch_size = _tmp49_ / 2;
				_tmp51_ = batch_size;
				if (_tmp51_ > 0) {
					gint _tmp52_ = 0;
					_tmp52_ = batch_size;
					_tmp50_ = _tmp52_;
				} else {
					_tmp50_ = 1;
				}
				batch_size = _tmp50_;
				advance = FALSE;
			}
		}
		_tmp53_ = advance;
		if (_tmp53_) {
			gint _tmp54_ = 0;
			gint _tmp55_ = 0;
			_tmp54_ = request_index;
			_tmp55_ = batch_size;
			request_index = _tmp54_ + _tmp55_;
		}
		__vala_GValue_free0 (response);
		_g_object_unref0 (requests_batch);
	}
	result = responses;
	return result;
}


SubmarineSubtitleServer* submarine_subtitle_server_construct (GType object_type) {
	SubmarineSubtitleServer * self = NULL;
	self = (SubmarineSubtitleServer*) g_object_new (object_type, NULL);
	return self;
}


void submarine_subtitle_server_get_info (SubmarineSubtitleServer* self, SubmarineServerInfo* result) {
	SubmarineServerInfo _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_info;
	*result = _tmp0_;
	return;
}


void submarine_subtitle_server_set_info (SubmarineSubtitleServer* self, SubmarineServerInfo* value) {
	SubmarineServerInfo _tmp0_ = {0};
	SubmarineServerInfo _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = *value;
	submarine_server_info_copy (&_tmp0_, &_tmp1_);
	submarine_server_info_destroy (&self->priv->_info);
	self->priv->_info = _tmp1_;
	g_object_notify ((GObject *) self, "info");
}


const gchar* submarine_subtitle_server_get_name (SubmarineSubtitleServer* self) {
	const gchar* result;
	SubmarineServerInfo _tmp0_ = {0};
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_info;
	_tmp1_ = submarine_server_info_get_name (&_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


const gchar* submarine_subtitle_server_get_address (SubmarineSubtitleServer* self) {
	const gchar* result;
	SubmarineServerInfo _tmp0_ = {0};
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_info;
	_tmp1_ = submarine_server_info_get_address (&_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


const gchar* submarine_subtitle_server_get_code (SubmarineSubtitleServer* self) {
	const gchar* result;
	SubmarineServerInfo _tmp0_ = {0};
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_info;
	_tmp1_ = submarine_server_info_get_code (&_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static void submarine_subtitle_server_class_init (SubmarineSubtitleServerClass * klass) {
	submarine_subtitle_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SubmarineSubtitleServerPrivate));
	((SubmarineSubtitleServerClass *) klass)->connect = submarine_subtitle_server_real_connect;
	((SubmarineSubtitleServerClass *) klass)->disconnect = submarine_subtitle_server_real_disconnect;
	((SubmarineSubtitleServerClass *) klass)->search = submarine_subtitle_server_real_search;
	((SubmarineSubtitleServerClass *) klass)->search_multiple = submarine_subtitle_server_real_search_multiple;
	((SubmarineSubtitleServerClass *) klass)->download = submarine_subtitle_server_real_download;
	((SubmarineSubtitleServerClass *) klass)->download_multiple = submarine_subtitle_server_real_download_multiple;
	G_OBJECT_CLASS (klass)->get_property = _vala_submarine_subtitle_server_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_submarine_subtitle_server_set_property;
	G_OBJECT_CLASS (klass)->finalize = submarine_subtitle_server_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SUBMARINE_SUBTITLE_SERVER_INFO, g_param_spec_boxed ("info", "info", "info", SUBMARINE_TYPE_SERVER_INFO, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SUBMARINE_SUBTITLE_SERVER_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SUBMARINE_SUBTITLE_SERVER_ADDRESS, g_param_spec_string ("address", "address", "address", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SUBMARINE_SUBTITLE_SERVER_CODE, g_param_spec_string ("code", "code", "code", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void submarine_subtitle_server_instance_init (SubmarineSubtitleServer * self) {
	self->priv = SUBMARINE_SUBTITLE_SERVER_GET_PRIVATE (self);
}


static void submarine_subtitle_server_finalize (GObject* obj) {
	SubmarineSubtitleServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer);
	submarine_server_info_destroy (&self->priv->_info);
	G_OBJECT_CLASS (submarine_subtitle_server_parent_class)->finalize (obj);
}


GType submarine_subtitle_server_get_type (void) {
	static volatile gsize submarine_subtitle_server_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_subtitle_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineSubtitleServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_subtitle_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineSubtitleServer), 0, (GInstanceInitFunc) submarine_subtitle_server_instance_init, NULL };
		GType submarine_subtitle_server_type_id;
		submarine_subtitle_server_type_id = g_type_register_static (G_TYPE_OBJECT, "SubmarineSubtitleServer", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&submarine_subtitle_server_type_id__volatile, submarine_subtitle_server_type_id);
	}
	return submarine_subtitle_server_type_id__volatile;
}


static void _vala_submarine_subtitle_server_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SubmarineSubtitleServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer);
	switch (property_id) {
		case SUBMARINE_SUBTITLE_SERVER_INFO:
		{
			SubmarineServerInfo boxed;
			submarine_subtitle_server_get_info (self, &boxed);
			g_value_set_boxed (value, &boxed);
		}
		break;
		case SUBMARINE_SUBTITLE_SERVER_NAME:
		g_value_set_string (value, submarine_subtitle_server_get_name (self));
		break;
		case SUBMARINE_SUBTITLE_SERVER_ADDRESS:
		g_value_set_string (value, submarine_subtitle_server_get_address (self));
		break;
		case SUBMARINE_SUBTITLE_SERVER_CODE:
		g_value_set_string (value, submarine_subtitle_server_get_code (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_submarine_subtitle_server_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SubmarineSubtitleServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer);
	switch (property_id) {
		case SUBMARINE_SUBTITLE_SERVER_INFO:
		submarine_subtitle_server_set_info (self, g_value_get_boxed (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


GeeSet* submarine_get_servers (void) {
	GeeSet* result = NULL;
	GeeHashSet* all_servers = NULL;
	GeeHashSet* _tmp0_ = NULL;
	SubmarineOpenSubtitlesServer* _tmp1_ = NULL;
	SubmarineOpenSubtitlesServer* _tmp2_ = NULL;
	SubmarinePodnapisiServer* _tmp3_ = NULL;
	SubmarinePodnapisiServer* _tmp4_ = NULL;
	SubmarineSubDBServer* _tmp5_ = NULL;
	SubmarineSubDBServer* _tmp6_ = NULL;
	SubmarineBierdopjeServer* _tmp7_ = NULL;
	SubmarineBierdopjeServer* _tmp8_ = NULL;
	SubmarineDivXsubsServer* _tmp9_ = NULL;
	SubmarineDivXsubsServer* _tmp10_ = NULL;
	SubmarineSubtitulosESServer* _tmp11_ = NULL;
	SubmarineSubtitulosESServer* _tmp12_ = NULL;
	GeeSet* _tmp13_ = NULL;
	GeeSet* _tmp14_ = NULL;
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE_SERVER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	all_servers = _tmp0_;
	_tmp1_ = submarine_open_subtitles_server_new ();
	_tmp2_ = _tmp1_;
	gee_abstract_collection_add ((GeeAbstractCollection*) all_servers, (SubmarineSubtitleServer*) _tmp2_);
	_g_object_unref0 (_tmp2_);
	_tmp3_ = submarine_podnapisi_server_new ();
	_tmp4_ = _tmp3_;
	gee_abstract_collection_add ((GeeAbstractCollection*) all_servers, (SubmarineSubtitleServer*) _tmp4_);
	_g_object_unref0 (_tmp4_);
	_tmp5_ = submarine_sub_db_server_new ();
	_tmp6_ = _tmp5_;
	gee_abstract_collection_add ((GeeAbstractCollection*) all_servers, (SubmarineSubtitleServer*) _tmp6_);
	_g_object_unref0 (_tmp6_);
	_tmp7_ = submarine_bierdopje_server_new ();
	_tmp8_ = _tmp7_;
	gee_abstract_collection_add ((GeeAbstractCollection*) all_servers, (SubmarineSubtitleServer*) _tmp8_);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = submarine_div_xsubs_server_new ();
	_tmp10_ = _tmp9_;
	gee_abstract_collection_add ((GeeAbstractCollection*) all_servers, (SubmarineSubtitleServer*) _tmp10_);
	_g_object_unref0 (_tmp10_);
	_tmp11_ = submarine_subtitulos_es_server_new ();
	_tmp12_ = _tmp11_;
	gee_abstract_collection_add ((GeeAbstractCollection*) all_servers, (SubmarineSubtitleServer*) _tmp12_);
	_g_object_unref0 (_tmp12_);
	_tmp13_ = gee_abstract_set_get_read_only_view ((GeeAbstractSet*) all_servers);
	_tmp14_ = _tmp13_;
	result = _tmp14_;
	_g_object_unref0 (all_servers);
	return result;
}


static gint ___lambda11_ (const gchar* a, const gchar* b) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = a;
	_tmp1_ = b;
	_tmp2_ = g_ascii_strcasecmp ((const gchar*) _tmp0_, (const gchar*) _tmp1_);
	result = _tmp2_;
	return result;
}


static gint ____lambda11__gcompare_data_func (gconstpointer a, gconstpointer b, gpointer self) {
	gint result;
	result = ___lambda11_ ((const gchar*) a, (const gchar*) b);
	return result;
}


GeeList* submarine_get_server_codes (void) {
	GeeList* result = NULL;
	GeeList* _tmp0_ = NULL;
	GeeList* _tmp17_ = NULL;
	GeeList* _tmp18_ = NULL;
	GeeList* _tmp19_ = NULL;
	_tmp0_ = submarine_all_server_codes;
	if (_tmp0_ == NULL) {
		GeeArrayList* _tmp1_ = NULL;
		GeeList* _tmp16_ = NULL;
		_tmp1_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
		_g_object_unref0 (submarine_all_server_codes);
		submarine_all_server_codes = (GeeList*) _tmp1_;
		{
			GeeIterator* _server_it = NULL;
			GeeSet* _tmp2_ = NULL;
			GeeSet* _tmp3_ = NULL;
			GeeIterator* _tmp4_ = NULL;
			GeeIterator* _tmp5_ = NULL;
			_tmp2_ = submarine_get_servers ();
			_tmp3_ = _tmp2_;
			_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
			_tmp5_ = _tmp4_;
			_g_object_unref0 (_tmp3_);
			_server_it = _tmp5_;
			while (TRUE) {
				GeeIterator* _tmp6_ = NULL;
				gboolean _tmp7_ = FALSE;
				SubmarineSubtitleServer* server = NULL;
				GeeIterator* _tmp8_ = NULL;
				gpointer _tmp9_ = NULL;
				GeeList* _tmp10_ = NULL;
				SubmarineSubtitleServer* _tmp11_ = NULL;
				SubmarineServerInfo _tmp12_ = {0};
				SubmarineServerInfo _tmp13_ = {0};
				const gchar* _tmp14_ = NULL;
				const gchar* _tmp15_ = NULL;
				_tmp6_ = _server_it;
				_tmp7_ = gee_iterator_next (_tmp6_);
				if (!_tmp7_) {
					break;
				}
				_tmp8_ = _server_it;
				_tmp9_ = gee_iterator_get (_tmp8_);
				server = (SubmarineSubtitleServer*) _tmp9_;
				_tmp10_ = submarine_all_server_codes;
				_tmp11_ = server;
				submarine_subtitle_server_get_info (_tmp11_, &_tmp12_);
				_tmp13_ = _tmp12_;
				_tmp14_ = submarine_server_info_get_code (&_tmp13_);
				_tmp15_ = _tmp14_;
				gee_collection_add ((GeeCollection*) _tmp10_, _tmp15_);
				_g_object_unref0 (server);
			}
			_g_object_unref0 (_server_it);
		}
		_tmp16_ = submarine_all_server_codes;
		gee_list_sort (_tmp16_, ____lambda11__gcompare_data_func, NULL, NULL);
	}
	_tmp17_ = submarine_all_server_codes;
	_tmp18_ = gee_list_get_read_only_view (_tmp17_);
	_tmp19_ = _tmp18_;
	result = _tmp19_;
	return result;
}


SubmarineServerInfo* submarine_get_server_info (const gchar* server_code) {
	SubmarineServerInfo* result = NULL;
	GeeMap* _tmp0_ = NULL;
	GeeMap* _tmp19_ = NULL;
	GeeSet* _tmp20_ = NULL;
	GeeSet* _tmp21_ = NULL;
	GeeSet* _tmp22_ = NULL;
	const gchar* _tmp23_ = NULL;
	gboolean _tmp24_ = FALSE;
	gboolean _tmp25_ = FALSE;
	g_return_val_if_fail (server_code != NULL, NULL);
	_tmp0_ = submarine_server_infos;
	if (_tmp0_ == NULL) {
		GeeHashMap* _tmp1_ = NULL;
		_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, SUBMARINE_TYPE_SERVER_INFO, (GBoxedCopyFunc) submarine_server_info_dup, submarine_server_info_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		_g_object_unref0 (submarine_server_infos);
		submarine_server_infos = (GeeMap*) _tmp1_;
		{
			GeeIterator* _server_it = NULL;
			GeeSet* _tmp2_ = NULL;
			GeeSet* _tmp3_ = NULL;
			GeeIterator* _tmp4_ = NULL;
			GeeIterator* _tmp5_ = NULL;
			_tmp2_ = submarine_get_servers ();
			_tmp3_ = _tmp2_;
			_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
			_tmp5_ = _tmp4_;
			_g_object_unref0 (_tmp3_);
			_server_it = _tmp5_;
			while (TRUE) {
				GeeIterator* _tmp6_ = NULL;
				gboolean _tmp7_ = FALSE;
				SubmarineSubtitleServer* server = NULL;
				GeeIterator* _tmp8_ = NULL;
				gpointer _tmp9_ = NULL;
				GeeMap* _tmp10_ = NULL;
				SubmarineSubtitleServer* _tmp11_ = NULL;
				SubmarineServerInfo _tmp12_ = {0};
				SubmarineServerInfo _tmp13_ = {0};
				const gchar* _tmp14_ = NULL;
				const gchar* _tmp15_ = NULL;
				SubmarineSubtitleServer* _tmp16_ = NULL;
				SubmarineServerInfo _tmp17_ = {0};
				SubmarineServerInfo _tmp18_ = {0};
				_tmp6_ = _server_it;
				_tmp7_ = gee_iterator_next (_tmp6_);
				if (!_tmp7_) {
					break;
				}
				_tmp8_ = _server_it;
				_tmp9_ = gee_iterator_get (_tmp8_);
				server = (SubmarineSubtitleServer*) _tmp9_;
				_tmp10_ = submarine_server_infos;
				_tmp11_ = server;
				submarine_subtitle_server_get_info (_tmp11_, &_tmp12_);
				_tmp13_ = _tmp12_;
				_tmp14_ = submarine_server_info_get_code (&_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = server;
				submarine_subtitle_server_get_info (_tmp16_, &_tmp17_);
				_tmp18_ = _tmp17_;
				gee_map_set (_tmp10_, _tmp15_, &_tmp18_);
				_g_object_unref0 (server);
			}
			_g_object_unref0 (_server_it);
		}
	}
	_tmp19_ = submarine_server_infos;
	_tmp20_ = gee_map_get_keys (_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = _tmp21_;
	_tmp23_ = server_code;
	_tmp24_ = gee_collection_contains ((GeeCollection*) _tmp22_, _tmp23_);
	_tmp25_ = _tmp24_;
	_g_object_unref0 (_tmp22_);
	if (_tmp25_) {
		GeeMap* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		gpointer _tmp28_ = NULL;
		_tmp26_ = submarine_server_infos;
		_tmp27_ = server_code;
		_tmp28_ = gee_map_get (_tmp26_, _tmp27_);
		result = (SubmarineServerInfo*) _tmp28_;
		return result;
	}
	result = NULL;
	return result;
}



