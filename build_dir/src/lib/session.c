/* session.c generated by valac 0.28.0, the Vala compiler
 * generated from session.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>


#define SUBMARINE_TYPE_SESSION (submarine_session_get_type ())
#define SUBMARINE_SESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SESSION, SubmarineSession))
#define SUBMARINE_SESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SESSION, SubmarineSessionClass))
#define SUBMARINE_IS_SESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SESSION))
#define SUBMARINE_IS_SESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SESSION))
#define SUBMARINE_SESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SESSION, SubmarineSessionClass))

typedef struct _SubmarineSession SubmarineSession;
typedef struct _SubmarineSessionClass SubmarineSessionClass;
typedef struct _SubmarineSessionPrivate SubmarineSessionPrivate;

#define SUBMARINE_TYPE_SUBTITLE_SERVER (submarine_subtitle_server_get_type ())
#define SUBMARINE_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer))
#define SUBMARINE_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))
#define SUBMARINE_IS_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_IS_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_SUBTITLE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))

typedef struct _SubmarineSubtitleServer SubmarineSubtitleServer;
typedef struct _SubmarineSubtitleServerClass SubmarineSubtitleServerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define SUBMARINE_TYPE_SUBTITLE (submarine_subtitle_get_type ())
#define SUBMARINE_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitle))
#define SUBMARINE_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))
#define SUBMARINE_IS_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_IS_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_SUBTITLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))

typedef struct _SubmarineSubtitle SubmarineSubtitle;
typedef struct _SubmarineSubtitleClass SubmarineSubtitleClass;
#define _submarine_subtitle_unref0(var) ((var == NULL) ? NULL : (var = (submarine_subtitle_unref (var), NULL)))

#define SUBMARINE_TYPE_SERVER_INFO (submarine_server_info_get_type ())
typedef struct _SubmarineServerInfo SubmarineServerInfo;

struct _SubmarineSession {
	GObject parent_instance;
	SubmarineSessionPrivate * priv;
};

struct _SubmarineSessionClass {
	GObjectClass parent_class;
};

struct _SubmarineSessionPrivate {
	GeeMap* sub_server_map;
	GeeSet* connected_servers;
};

struct _SubmarineServerInfo {
	gchar* _name;
	gchar* _address;
	gchar* _code;
};


static gpointer submarine_session_parent_class = NULL;

GType submarine_session_get_type (void) G_GNUC_CONST;
GType submarine_subtitle_server_get_type (void) G_GNUC_CONST;
#define SUBMARINE_SESSION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_SESSION, SubmarineSessionPrivate))
enum  {
	SUBMARINE_SESSION_DUMMY_PROPERTY
};
void submarine_subtitle_server_disconnect (SubmarineSubtitleServer* self);
SubmarineSession* submarine_session_new (void);
SubmarineSession* submarine_session_construct (GType object_type);
GeeSet* submarine_get_servers (void);
const gchar* submarine_subtitle_server_get_code (SubmarineSubtitleServer* self);
gboolean submarine_session_server_connect (SubmarineSession* self, const gchar* server_code);
void submarine_session_server_disconnect (SubmarineSession* self, const gchar* server_code);
gboolean submarine_subtitle_server_connect (SubmarineSubtitleServer* self);
GeeSet* submarine_session_server_connect_multiple (SubmarineSession* self, GeeCollection* server_codes);
void submarine_session_server_disconnect_multiple (SubmarineSession* self, GeeCollection* server_codes);
gpointer submarine_subtitle_ref (gpointer instance);
void submarine_subtitle_unref (gpointer instance);
GParamSpec* submarine_param_spec_subtitle (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_subtitle (GValue* value, gpointer v_object);
void submarine_value_take_subtitle (GValue* value, gpointer v_object);
gpointer submarine_value_get_subtitle (const GValue* value);
GType submarine_subtitle_get_type (void) G_GNUC_CONST;
GeeSet* submarine_session_subtitle_search (SubmarineSession* self, const gchar* filename, GeeCollection* languages);
GeeSet* submarine_subtitle_server_search (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
GeeMultiMap* submarine_session_subtitle_search_multiple (SubmarineSession* self, GeeCollection* filenames, GeeCollection* languages);
GeeMultiMap* submarine_subtitle_server_search_multiple (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
SubmarineSubtitle* submarine_session_subtitle_download (SubmarineSession* self, SubmarineSubtitle* subtitle);
GType submarine_server_info_get_type (void) G_GNUC_CONST;
SubmarineServerInfo* submarine_server_info_dup (const SubmarineServerInfo* self);
void submarine_server_info_free (SubmarineServerInfo* self);
void submarine_server_info_copy (const SubmarineServerInfo* self, SubmarineServerInfo* dest);
void submarine_server_info_destroy (SubmarineServerInfo* self);
void submarine_subtitle_get_server_info (SubmarineSubtitle* self, SubmarineServerInfo* result);
const gchar* submarine_server_info_get_code (SubmarineServerInfo* self);
SubmarineSubtitle* submarine_subtitle_server_download (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
GeeSet* submarine_session_subtitle_download_multiple (SubmarineSession* self, GeeCollection* subtitle_set);
GeeSet* submarine_subtitle_server_download_multiple (SubmarineSubtitleServer* self, GeeCollection* subtitles);
static void submarine_session_finalize (GObject* obj);


SubmarineSession* submarine_session_construct (GType object_type) {
	SubmarineSession * self = NULL;
	GeeHashSet* all_servers = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GeeHashSet* _tmp1_ = NULL;
	GeeSet* _tmp2_ = NULL;
	GeeSet* _tmp3_ = NULL;
	self = (SubmarineSession*) g_object_new (object_type, NULL);
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE_SERVER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	all_servers = _tmp0_;
	_tmp1_ = all_servers;
	_tmp2_ = submarine_get_servers ();
	_tmp3_ = _tmp2_;
	gee_collection_add_all ((GeeCollection*) _tmp1_, (GeeCollection*) _tmp3_);
	_g_object_unref0 (_tmp3_);
	{
		GeeIterator* _sub_server_it = NULL;
		GeeHashSet* _tmp4_ = NULL;
		GeeIterator* _tmp5_ = NULL;
		_tmp4_ = all_servers;
		_tmp5_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp4_);
		_sub_server_it = _tmp5_;
		while (TRUE) {
			GeeIterator* _tmp6_ = NULL;
			gboolean _tmp7_ = FALSE;
			SubmarineSubtitleServer* sub_server = NULL;
			GeeIterator* _tmp8_ = NULL;
			gpointer _tmp9_ = NULL;
			GeeMap* _tmp10_ = NULL;
			SubmarineSubtitleServer* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			SubmarineSubtitleServer* _tmp14_ = NULL;
			_tmp6_ = _sub_server_it;
			_tmp7_ = gee_iterator_next (_tmp6_);
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = _sub_server_it;
			_tmp9_ = gee_iterator_get (_tmp8_);
			sub_server = (SubmarineSubtitleServer*) _tmp9_;
			_tmp10_ = self->priv->sub_server_map;
			_tmp11_ = sub_server;
			_tmp12_ = submarine_subtitle_server_get_code (_tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = sub_server;
			gee_map_set (_tmp10_, _tmp13_, _tmp14_);
			_g_object_unref0 (sub_server);
		}
		_g_object_unref0 (_sub_server_it);
	}
	_g_object_unref0 (all_servers);
	return self;
}


SubmarineSession* submarine_session_new (void) {
	return submarine_session_construct (SUBMARINE_TYPE_SESSION);
}


gboolean submarine_session_server_connect (SubmarineSession* self, const gchar* server_code) {
	gboolean result = FALSE;
	GeeMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (server_code != NULL, FALSE);
	_tmp0_ = self->priv->sub_server_map;
	_tmp1_ = server_code;
	_tmp2_ = gee_map_has_key (_tmp0_, _tmp1_);
	if (_tmp2_) {
		GeeSet* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		GeeMap* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gpointer _tmp9_ = NULL;
		SubmarineSubtitleServer* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		gboolean _tmp12_ = FALSE;
		_tmp3_ = self->priv->connected_servers;
		_tmp4_ = server_code;
		_tmp5_ = gee_collection_contains ((GeeCollection*) _tmp3_, _tmp4_);
		if (_tmp5_) {
			const gchar* _tmp6_ = NULL;
			_tmp6_ = server_code;
			submarine_session_server_disconnect (self, _tmp6_);
		}
		_tmp7_ = self->priv->sub_server_map;
		_tmp8_ = server_code;
		_tmp9_ = gee_map_get (_tmp7_, _tmp8_);
		_tmp10_ = (SubmarineSubtitleServer*) _tmp9_;
		_tmp11_ = submarine_subtitle_server_connect (_tmp10_);
		_tmp12_ = _tmp11_;
		_g_object_unref0 (_tmp10_);
		if (_tmp12_) {
			GeeSet* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			_tmp13_ = self->priv->connected_servers;
			_tmp14_ = server_code;
			gee_collection_add ((GeeCollection*) _tmp13_, _tmp14_);
			result = TRUE;
			return result;
		}
	}
	result = FALSE;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GeeSet* submarine_session_server_connect_multiple (SubmarineSession* self, GeeCollection* server_codes) {
	GeeSet* result = NULL;
	GeeHashSet* servers_connected = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GeeCollection* _tmp1_ = NULL;
	GeeCollection* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (server_codes != NULL, NULL);
	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	servers_connected = _tmp0_;
	_tmp2_ = server_codes;
	_tmp3_ = gee_collection_get_is_empty (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_) {
		GeeMap* _tmp5_ = NULL;
		GeeSet* _tmp6_ = NULL;
		GeeSet* _tmp7_ = NULL;
		_tmp5_ = self->priv->sub_server_map;
		_tmp6_ = gee_map_get_keys (_tmp5_);
		_tmp7_ = _tmp6_;
		_g_object_unref0 (_tmp1_);
		_tmp1_ = (GeeCollection*) _tmp7_;
	} else {
		GeeCollection* _tmp8_ = NULL;
		GeeCollection* _tmp9_ = NULL;
		_tmp8_ = server_codes;
		_tmp9_ = _g_object_ref0 (_tmp8_);
		_g_object_unref0 (_tmp1_);
		_tmp1_ = _tmp9_;
	}
	server_codes = _tmp1_;
	{
		GeeIterator* _server_code_it = NULL;
		GeeCollection* _tmp10_ = NULL;
		GeeIterator* _tmp11_ = NULL;
		_tmp10_ = server_codes;
		_tmp11_ = gee_iterable_iterator ((GeeIterable*) _tmp10_);
		_server_code_it = _tmp11_;
		while (TRUE) {
			GeeIterator* _tmp12_ = NULL;
			gboolean _tmp13_ = FALSE;
			gchar* server_code = NULL;
			GeeIterator* _tmp14_ = NULL;
			gpointer _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gboolean _tmp17_ = FALSE;
			_tmp12_ = _server_code_it;
			_tmp13_ = gee_iterator_next (_tmp12_);
			if (!_tmp13_) {
				break;
			}
			_tmp14_ = _server_code_it;
			_tmp15_ = gee_iterator_get (_tmp14_);
			server_code = (gchar*) _tmp15_;
			_tmp16_ = server_code;
			_tmp17_ = submarine_session_server_connect (self, _tmp16_);
			if (_tmp17_) {
				GeeHashSet* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				_tmp18_ = servers_connected;
				_tmp19_ = server_code;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp18_, _tmp19_);
			}
			_g_free0 (server_code);
		}
		_g_object_unref0 (_server_code_it);
	}
	result = (GeeSet*) servers_connected;
	_g_object_unref0 (_tmp1_);
	return result;
}


void submarine_session_server_disconnect (SubmarineSession* self, const gchar* server_code) {
	GeeSet* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (server_code != NULL);
	_tmp0_ = self->priv->connected_servers;
	_tmp1_ = server_code;
	_tmp2_ = gee_collection_contains ((GeeCollection*) _tmp0_, _tmp1_);
	if (_tmp2_) {
		GeeMap* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		SubmarineSubtitleServer* _tmp6_ = NULL;
		GeeSet* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		_tmp3_ = self->priv->sub_server_map;
		_tmp4_ = server_code;
		_tmp5_ = gee_map_get (_tmp3_, _tmp4_);
		_tmp6_ = (SubmarineSubtitleServer*) _tmp5_;
		submarine_subtitle_server_disconnect (_tmp6_);
		_g_object_unref0 (_tmp6_);
		_tmp7_ = self->priv->connected_servers;
		_tmp8_ = server_code;
		gee_collection_remove ((GeeCollection*) _tmp7_, _tmp8_);
	}
}


void submarine_session_server_disconnect_multiple (SubmarineSession* self, GeeCollection* server_codes) {
	GeeCollection* _tmp0_ = NULL;
	GeeCollection* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (server_codes != NULL);
	_tmp1_ = server_codes;
	_tmp2_ = gee_collection_get_is_empty (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_) {
		GeeSet* _tmp4_ = NULL;
		_tmp4_ = self->priv->connected_servers;
		_tmp0_ = (GeeCollection*) _tmp4_;
	} else {
		GeeCollection* _tmp5_ = NULL;
		_tmp5_ = server_codes;
		_tmp0_ = _tmp5_;
	}
	server_codes = _tmp0_;
	{
		GeeIterator* _server_code_it = NULL;
		GeeCollection* _tmp6_ = NULL;
		GeeIterator* _tmp7_ = NULL;
		_tmp6_ = server_codes;
		_tmp7_ = gee_iterable_iterator ((GeeIterable*) _tmp6_);
		_server_code_it = _tmp7_;
		while (TRUE) {
			GeeIterator* _tmp8_ = NULL;
			gboolean _tmp9_ = FALSE;
			gchar* server_code = NULL;
			GeeIterator* _tmp10_ = NULL;
			gpointer _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			_tmp8_ = _server_code_it;
			_tmp9_ = gee_iterator_next (_tmp8_);
			if (!_tmp9_) {
				break;
			}
			_tmp10_ = _server_code_it;
			_tmp11_ = gee_iterator_get (_tmp10_);
			server_code = (gchar*) _tmp11_;
			_tmp12_ = server_code;
			submarine_session_server_disconnect (self, _tmp12_);
			_g_free0 (server_code);
		}
		_g_object_unref0 (_server_code_it);
	}
}


GeeSet* submarine_session_subtitle_search (SubmarineSession* self, const gchar* filename, GeeCollection* languages) {
	GeeSet* result = NULL;
	GeeHashSet* subtitles_found = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GFile* file = NULL;
	const gchar* _tmp1_ = NULL;
	GFile* _tmp2_ = NULL;
	GFile* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (filename != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_found = _tmp0_;
	_tmp1_ = filename;
	_tmp2_ = g_file_new_for_path (_tmp1_);
	file = _tmp2_;
	_tmp3_ = file;
	_tmp4_ = g_file_query_exists (_tmp3_, NULL);
	if (_tmp4_) {
		{
			GeeIterator* _server_code_it = NULL;
			GeeSet* _tmp5_ = NULL;
			GeeIterator* _tmp6_ = NULL;
			_tmp5_ = self->priv->connected_servers;
			_tmp6_ = gee_iterable_iterator ((GeeIterable*) _tmp5_);
			_server_code_it = _tmp6_;
			while (TRUE) {
				GeeIterator* _tmp7_ = NULL;
				gboolean _tmp8_ = FALSE;
				gchar* server_code = NULL;
				GeeIterator* _tmp9_ = NULL;
				gpointer _tmp10_ = NULL;
				GeeHashSet* _tmp11_ = NULL;
				GeeMap* _tmp12_ = NULL;
				const gchar* _tmp13_ = NULL;
				gpointer _tmp14_ = NULL;
				SubmarineSubtitleServer* _tmp15_ = NULL;
				GFile* _tmp16_ = NULL;
				GeeCollection* _tmp17_ = NULL;
				GeeSet* _tmp18_ = NULL;
				GeeSet* _tmp19_ = NULL;
				_tmp7_ = _server_code_it;
				_tmp8_ = gee_iterator_next (_tmp7_);
				if (!_tmp8_) {
					break;
				}
				_tmp9_ = _server_code_it;
				_tmp10_ = gee_iterator_get (_tmp9_);
				server_code = (gchar*) _tmp10_;
				_tmp11_ = subtitles_found;
				_tmp12_ = self->priv->sub_server_map;
				_tmp13_ = server_code;
				_tmp14_ = gee_map_get (_tmp12_, _tmp13_);
				_tmp15_ = (SubmarineSubtitleServer*) _tmp14_;
				_tmp16_ = file;
				_tmp17_ = languages;
				_tmp18_ = submarine_subtitle_server_search (_tmp15_, _tmp16_, _tmp17_);
				_tmp19_ = _tmp18_;
				gee_collection_add_all ((GeeCollection*) _tmp11_, (GeeCollection*) _tmp19_);
				_g_object_unref0 (_tmp19_);
				_g_object_unref0 (_tmp15_);
				_g_free0 (server_code);
			}
			_g_object_unref0 (_server_code_it);
		}
	}
	result = (GeeSet*) subtitles_found;
	_g_object_unref0 (file);
	return result;
}


GeeMultiMap* submarine_session_subtitle_search_multiple (SubmarineSession* self, GeeCollection* filenames, GeeCollection* languages) {
	GeeMultiMap* result = NULL;
	GeeHashMultiMap* subtitles_found_map = NULL;
	GeeHashMultiMap* _tmp0_ = NULL;
	GeeHashSet* files = NULL;
	GeeHashSet* _tmp1_ = NULL;
	GeeHashMap* file_filename = NULL;
	GeeHashMap* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (filenames != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_tmp0_ = gee_hash_multi_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_found_map = _tmp0_;
	_tmp1_ = gee_hash_set_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	files = _tmp1_;
	_tmp2_ = gee_hash_map_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	file_filename = _tmp2_;
	{
		GeeIterator* _filename_it = NULL;
		GeeCollection* _tmp3_ = NULL;
		GeeIterator* _tmp4_ = NULL;
		_tmp3_ = filenames;
		_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
		_filename_it = _tmp4_;
		while (TRUE) {
			GeeIterator* _tmp5_ = NULL;
			gboolean _tmp6_ = FALSE;
			gchar* filename = NULL;
			GeeIterator* _tmp7_ = NULL;
			gpointer _tmp8_ = NULL;
			GFile* file = NULL;
			const gchar* _tmp9_ = NULL;
			GFile* _tmp10_ = NULL;
			GFile* _tmp11_ = NULL;
			gboolean _tmp12_ = FALSE;
			_tmp5_ = _filename_it;
			_tmp6_ = gee_iterator_next (_tmp5_);
			if (!_tmp6_) {
				break;
			}
			_tmp7_ = _filename_it;
			_tmp8_ = gee_iterator_get (_tmp7_);
			filename = (gchar*) _tmp8_;
			_tmp9_ = filename;
			_tmp10_ = g_file_new_for_path (_tmp9_);
			file = _tmp10_;
			_tmp11_ = file;
			_tmp12_ = g_file_query_exists (_tmp11_, NULL);
			if (_tmp12_) {
				GeeHashSet* _tmp13_ = NULL;
				GFile* _tmp14_ = NULL;
				GeeHashMap* _tmp15_ = NULL;
				GFile* _tmp16_ = NULL;
				const gchar* _tmp17_ = NULL;
				_tmp13_ = files;
				_tmp14_ = file;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp13_, _tmp14_);
				_tmp15_ = file_filename;
				_tmp16_ = file;
				_tmp17_ = filename;
				gee_abstract_map_set ((GeeAbstractMap*) _tmp15_, _tmp16_, _tmp17_);
			}
			_g_object_unref0 (file);
			_g_free0 (filename);
		}
		_g_object_unref0 (_filename_it);
	}
	{
		GeeIterator* _server_code_it = NULL;
		GeeSet* _tmp18_ = NULL;
		GeeIterator* _tmp19_ = NULL;
		_tmp18_ = self->priv->connected_servers;
		_tmp19_ = gee_iterable_iterator ((GeeIterable*) _tmp18_);
		_server_code_it = _tmp19_;
		while (TRUE) {
			GeeIterator* _tmp20_ = NULL;
			gboolean _tmp21_ = FALSE;
			gchar* server_code = NULL;
			GeeIterator* _tmp22_ = NULL;
			gpointer _tmp23_ = NULL;
			GeeMultiMap* file_subtitle_map = NULL;
			GeeMap* _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			gpointer _tmp26_ = NULL;
			SubmarineSubtitleServer* _tmp27_ = NULL;
			GeeHashSet* _tmp28_ = NULL;
			GeeCollection* _tmp29_ = NULL;
			GeeMultiMap* _tmp30_ = NULL;
			GeeMultiMap* _tmp31_ = NULL;
			_tmp20_ = _server_code_it;
			_tmp21_ = gee_iterator_next (_tmp20_);
			if (!_tmp21_) {
				break;
			}
			_tmp22_ = _server_code_it;
			_tmp23_ = gee_iterator_get (_tmp22_);
			server_code = (gchar*) _tmp23_;
			_tmp24_ = self->priv->sub_server_map;
			_tmp25_ = server_code;
			_tmp26_ = gee_map_get (_tmp24_, _tmp25_);
			_tmp27_ = (SubmarineSubtitleServer*) _tmp26_;
			_tmp28_ = files;
			_tmp29_ = languages;
			_tmp30_ = submarine_subtitle_server_search_multiple (_tmp27_, (GeeCollection*) _tmp28_, _tmp29_);
			_tmp31_ = _tmp30_;
			_g_object_unref0 (_tmp27_);
			file_subtitle_map = _tmp31_;
			{
				GeeIterator* _key_it = NULL;
				GeeMultiMap* _tmp32_ = NULL;
				GeeSet* _tmp33_ = NULL;
				GeeSet* _tmp34_ = NULL;
				GeeIterator* _tmp35_ = NULL;
				GeeIterator* _tmp36_ = NULL;
				_tmp32_ = file_subtitle_map;
				_tmp33_ = gee_multi_map_get_keys (_tmp32_);
				_tmp34_ = _tmp33_;
				_tmp35_ = gee_iterable_iterator ((GeeIterable*) _tmp34_);
				_tmp36_ = _tmp35_;
				_g_object_unref0 (_tmp34_);
				_key_it = _tmp36_;
				while (TRUE) {
					GeeIterator* _tmp37_ = NULL;
					gboolean _tmp38_ = FALSE;
					GFile* key = NULL;
					GeeIterator* _tmp39_ = NULL;
					gpointer _tmp40_ = NULL;
					_tmp37_ = _key_it;
					_tmp38_ = gee_iterator_next (_tmp37_);
					if (!_tmp38_) {
						break;
					}
					_tmp39_ = _key_it;
					_tmp40_ = gee_iterator_get (_tmp39_);
					key = (GFile*) _tmp40_;
					{
						GeeIterator* _subtitle_it = NULL;
						GeeMultiMap* _tmp41_ = NULL;
						GFile* _tmp42_ = NULL;
						GeeCollection* _tmp43_ = NULL;
						GeeCollection* _tmp44_ = NULL;
						GeeIterator* _tmp45_ = NULL;
						GeeIterator* _tmp46_ = NULL;
						_tmp41_ = file_subtitle_map;
						_tmp42_ = key;
						_tmp43_ = gee_multi_map_get (_tmp41_, _tmp42_);
						_tmp44_ = _tmp43_;
						_tmp45_ = gee_iterable_iterator ((GeeIterable*) _tmp44_);
						_tmp46_ = _tmp45_;
						_g_object_unref0 (_tmp44_);
						_subtitle_it = _tmp46_;
						while (TRUE) {
							GeeIterator* _tmp47_ = NULL;
							gboolean _tmp48_ = FALSE;
							SubmarineSubtitle* subtitle = NULL;
							GeeIterator* _tmp49_ = NULL;
							gpointer _tmp50_ = NULL;
							GeeHashMultiMap* _tmp51_ = NULL;
							GeeHashMap* _tmp52_ = NULL;
							GFile* _tmp53_ = NULL;
							gpointer _tmp54_ = NULL;
							gchar* _tmp55_ = NULL;
							SubmarineSubtitle* _tmp56_ = NULL;
							_tmp47_ = _subtitle_it;
							_tmp48_ = gee_iterator_next (_tmp47_);
							if (!_tmp48_) {
								break;
							}
							_tmp49_ = _subtitle_it;
							_tmp50_ = gee_iterator_get (_tmp49_);
							subtitle = (SubmarineSubtitle*) _tmp50_;
							_tmp51_ = subtitles_found_map;
							_tmp52_ = file_filename;
							_tmp53_ = key;
							_tmp54_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp52_, _tmp53_);
							_tmp55_ = (gchar*) _tmp54_;
							_tmp56_ = subtitle;
							gee_multi_map_set ((GeeMultiMap*) _tmp51_, _tmp55_, _tmp56_);
							_g_free0 (_tmp55_);
							_submarine_subtitle_unref0 (subtitle);
						}
						_g_object_unref0 (_subtitle_it);
					}
					_g_object_unref0 (key);
				}
				_g_object_unref0 (_key_it);
			}
			_g_object_unref0 (file_subtitle_map);
			_g_free0 (server_code);
		}
		_g_object_unref0 (_server_code_it);
	}
	result = (GeeMultiMap*) subtitles_found_map;
	_g_object_unref0 (file_filename);
	_g_object_unref0 (files);
	return result;
}


SubmarineSubtitle* submarine_session_subtitle_download (SubmarineSession* self, SubmarineSubtitle* subtitle) {
	SubmarineSubtitle* result = NULL;
	GeeSet* _tmp0_ = NULL;
	SubmarineSubtitle* _tmp1_ = NULL;
	SubmarineServerInfo _tmp2_ = {0};
	SubmarineServerInfo _tmp3_ = {0};
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (subtitle != NULL, NULL);
	_tmp0_ = self->priv->connected_servers;
	_tmp1_ = subtitle;
	submarine_subtitle_get_server_info (_tmp1_, &_tmp2_);
	_tmp3_ = _tmp2_;
	_tmp4_ = submarine_server_info_get_code (&_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = gee_collection_contains ((GeeCollection*) _tmp0_, _tmp5_);
	if (_tmp6_) {
		GeeMap* _tmp7_ = NULL;
		SubmarineSubtitle* _tmp8_ = NULL;
		SubmarineServerInfo _tmp9_ = {0};
		SubmarineServerInfo _tmp10_ = {0};
		const gchar* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		gpointer _tmp13_ = NULL;
		SubmarineSubtitleServer* _tmp14_ = NULL;
		SubmarineSubtitle* _tmp15_ = NULL;
		SubmarineSubtitle* _tmp16_ = NULL;
		SubmarineSubtitle* _tmp17_ = NULL;
		_tmp7_ = self->priv->sub_server_map;
		_tmp8_ = subtitle;
		submarine_subtitle_get_server_info (_tmp8_, &_tmp9_);
		_tmp10_ = _tmp9_;
		_tmp11_ = submarine_server_info_get_code (&_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = gee_map_get (_tmp7_, _tmp12_);
		_tmp14_ = (SubmarineSubtitleServer*) _tmp13_;
		_tmp15_ = subtitle;
		_tmp16_ = submarine_subtitle_server_download (_tmp14_, _tmp15_);
		_tmp17_ = _tmp16_;
		_g_object_unref0 (_tmp14_);
		result = _tmp17_;
		return result;
	} else {
		result = NULL;
		return result;
	}
}


GeeSet* submarine_session_subtitle_download_multiple (SubmarineSession* self, GeeCollection* subtitle_set) {
	GeeSet* result = NULL;
	GeeHashSet* subtitles_downloaded = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GeeHashMultiMap* subtitle_map = NULL;
	GeeHashMultiMap* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (subtitle_set != NULL, NULL);
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_downloaded = _tmp0_;
	_tmp1_ = gee_hash_multi_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitle_map = _tmp1_;
	{
		GeeIterator* _subtitle_it = NULL;
		GeeCollection* _tmp2_ = NULL;
		GeeIterator* _tmp3_ = NULL;
		_tmp2_ = subtitle_set;
		_tmp3_ = gee_iterable_iterator ((GeeIterable*) _tmp2_);
		_subtitle_it = _tmp3_;
		while (TRUE) {
			GeeIterator* _tmp4_ = NULL;
			gboolean _tmp5_ = FALSE;
			SubmarineSubtitle* subtitle = NULL;
			GeeIterator* _tmp6_ = NULL;
			gpointer _tmp7_ = NULL;
			GeeSet* _tmp8_ = NULL;
			SubmarineSubtitle* _tmp9_ = NULL;
			SubmarineServerInfo _tmp10_ = {0};
			SubmarineServerInfo _tmp11_ = {0};
			const gchar* _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			gboolean _tmp14_ = FALSE;
			_tmp4_ = _subtitle_it;
			_tmp5_ = gee_iterator_next (_tmp4_);
			if (!_tmp5_) {
				break;
			}
			_tmp6_ = _subtitle_it;
			_tmp7_ = gee_iterator_get (_tmp6_);
			subtitle = (SubmarineSubtitle*) _tmp7_;
			_tmp8_ = self->priv->connected_servers;
			_tmp9_ = subtitle;
			submarine_subtitle_get_server_info (_tmp9_, &_tmp10_);
			_tmp11_ = _tmp10_;
			_tmp12_ = submarine_server_info_get_code (&_tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = gee_collection_contains ((GeeCollection*) _tmp8_, _tmp13_);
			if (_tmp14_) {
				GeeHashMultiMap* _tmp15_ = NULL;
				SubmarineSubtitle* _tmp16_ = NULL;
				SubmarineServerInfo _tmp17_ = {0};
				SubmarineServerInfo _tmp18_ = {0};
				const gchar* _tmp19_ = NULL;
				const gchar* _tmp20_ = NULL;
				SubmarineSubtitle* _tmp21_ = NULL;
				_tmp15_ = subtitle_map;
				_tmp16_ = subtitle;
				submarine_subtitle_get_server_info (_tmp16_, &_tmp17_);
				_tmp18_ = _tmp17_;
				_tmp19_ = submarine_server_info_get_code (&_tmp18_);
				_tmp20_ = _tmp19_;
				_tmp21_ = subtitle;
				gee_multi_map_set ((GeeMultiMap*) _tmp15_, _tmp20_, _tmp21_);
			}
			_submarine_subtitle_unref0 (subtitle);
		}
		_g_object_unref0 (_subtitle_it);
	}
	{
		GeeIterator* _key_it = NULL;
		GeeHashMultiMap* _tmp22_ = NULL;
		GeeSet* _tmp23_ = NULL;
		GeeSet* _tmp24_ = NULL;
		GeeIterator* _tmp25_ = NULL;
		GeeIterator* _tmp26_ = NULL;
		_tmp22_ = subtitle_map;
		_tmp23_ = gee_multi_map_get_keys ((GeeMultiMap*) _tmp22_);
		_tmp24_ = _tmp23_;
		_tmp25_ = gee_iterable_iterator ((GeeIterable*) _tmp24_);
		_tmp26_ = _tmp25_;
		_g_object_unref0 (_tmp24_);
		_key_it = _tmp26_;
		while (TRUE) {
			GeeIterator* _tmp27_ = NULL;
			gboolean _tmp28_ = FALSE;
			gchar* key = NULL;
			GeeIterator* _tmp29_ = NULL;
			gpointer _tmp30_ = NULL;
			GeeHashSet* _tmp31_ = NULL;
			GeeMap* _tmp32_ = NULL;
			const gchar* _tmp33_ = NULL;
			gpointer _tmp34_ = NULL;
			SubmarineSubtitleServer* _tmp35_ = NULL;
			GeeHashMultiMap* _tmp36_ = NULL;
			const gchar* _tmp37_ = NULL;
			GeeCollection* _tmp38_ = NULL;
			GeeCollection* _tmp39_ = NULL;
			GeeSet* _tmp40_ = NULL;
			GeeSet* _tmp41_ = NULL;
			_tmp27_ = _key_it;
			_tmp28_ = gee_iterator_next (_tmp27_);
			if (!_tmp28_) {
				break;
			}
			_tmp29_ = _key_it;
			_tmp30_ = gee_iterator_get (_tmp29_);
			key = (gchar*) _tmp30_;
			_tmp31_ = subtitles_downloaded;
			_tmp32_ = self->priv->sub_server_map;
			_tmp33_ = key;
			_tmp34_ = gee_map_get (_tmp32_, _tmp33_);
			_tmp35_ = (SubmarineSubtitleServer*) _tmp34_;
			_tmp36_ = subtitle_map;
			_tmp37_ = key;
			_tmp38_ = gee_multi_map_get ((GeeMultiMap*) _tmp36_, _tmp37_);
			_tmp39_ = _tmp38_;
			_tmp40_ = submarine_subtitle_server_download_multiple (_tmp35_, _tmp39_);
			_tmp41_ = _tmp40_;
			gee_collection_add_all ((GeeCollection*) _tmp31_, (GeeCollection*) _tmp41_);
			_g_object_unref0 (_tmp41_);
			_g_object_unref0 (_tmp39_);
			_g_object_unref0 (_tmp35_);
			_g_free0 (key);
		}
		_g_object_unref0 (_key_it);
	}
	result = (GeeSet*) subtitles_downloaded;
	_g_object_unref0 (subtitle_map);
	return result;
}


static void submarine_session_class_init (SubmarineSessionClass * klass) {
	submarine_session_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SubmarineSessionPrivate));
	G_OBJECT_CLASS (klass)->finalize = submarine_session_finalize;
}


static void submarine_session_instance_init (SubmarineSession * self) {
	GeeHashMap* _tmp0_ = NULL;
	GeeHashSet* _tmp1_ = NULL;
	self->priv = SUBMARINE_SESSION_GET_PRIVATE (self);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, SUBMARINE_TYPE_SUBTITLE_SERVER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	self->priv->sub_server_map = (GeeMap*) _tmp0_;
	_tmp1_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	self->priv->connected_servers = (GeeSet*) _tmp1_;
}


static void submarine_session_finalize (GObject* obj) {
	SubmarineSession * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_SESSION, SubmarineSession);
	{
		GeeIterator* _sub_server_it = NULL;
		GeeMap* _tmp0_ = NULL;
		GeeCollection* _tmp1_ = NULL;
		GeeCollection* _tmp2_ = NULL;
		GeeCollection* _tmp3_ = NULL;
		GeeIterator* _tmp4_ = NULL;
		GeeIterator* _tmp5_ = NULL;
		_tmp0_ = self->priv->sub_server_map;
		_tmp1_ = gee_map_get_values (_tmp0_);
		_tmp2_ = _tmp1_;
		_tmp3_ = _tmp2_;
		_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
		_tmp5_ = _tmp4_;
		_g_object_unref0 (_tmp3_);
		_sub_server_it = _tmp5_;
		while (TRUE) {
			GeeIterator* _tmp6_ = NULL;
			gboolean _tmp7_ = FALSE;
			SubmarineSubtitleServer* sub_server = NULL;
			GeeIterator* _tmp8_ = NULL;
			gpointer _tmp9_ = NULL;
			SubmarineSubtitleServer* _tmp10_ = NULL;
			_tmp6_ = _sub_server_it;
			_tmp7_ = gee_iterator_next (_tmp6_);
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = _sub_server_it;
			_tmp9_ = gee_iterator_get (_tmp8_);
			sub_server = (SubmarineSubtitleServer*) _tmp9_;
			_tmp10_ = sub_server;
			submarine_subtitle_server_disconnect (_tmp10_);
			_g_object_unref0 (sub_server);
		}
		_g_object_unref0 (_sub_server_it);
	}
	_g_object_unref0 (self->priv->sub_server_map);
	_g_object_unref0 (self->priv->connected_servers);
	G_OBJECT_CLASS (submarine_session_parent_class)->finalize (obj);
}


GType submarine_session_get_type (void) {
	static volatile gsize submarine_session_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_session_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineSessionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_session_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineSession), 0, (GInstanceInitFunc) submarine_session_instance_init, NULL };
		GType submarine_session_type_id;
		submarine_session_type_id = g_type_register_static (G_TYPE_OBJECT, "SubmarineSession", &g_define_type_info, 0);
		g_once_init_leave (&submarine_session_type_id__volatile, submarine_session_type_id);
	}
	return submarine_session_type_id__volatile;
}



