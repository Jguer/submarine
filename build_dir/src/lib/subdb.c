/* subdb.c generated by valac 0.28.0, the Vala compiler
 * generated from subdb.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <libsoup/soup.h>
#include <stdio.h>
#include <float.h>
#include <math.h>


#define SUBMARINE_TYPE_SUBTITLE_SERVER (submarine_subtitle_server_get_type ())
#define SUBMARINE_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer))
#define SUBMARINE_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))
#define SUBMARINE_IS_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_IS_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_SUBTITLE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))

typedef struct _SubmarineSubtitleServer SubmarineSubtitleServer;
typedef struct _SubmarineSubtitleServerClass SubmarineSubtitleServerClass;
typedef struct _SubmarineSubtitleServerPrivate SubmarineSubtitleServerPrivate;

#define SUBMARINE_TYPE_SUBTITLE (submarine_subtitle_get_type ())
#define SUBMARINE_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitle))
#define SUBMARINE_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))
#define SUBMARINE_IS_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_IS_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_SUBTITLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))

typedef struct _SubmarineSubtitle SubmarineSubtitle;
typedef struct _SubmarineSubtitleClass SubmarineSubtitleClass;

#define SUBMARINE_TYPE_SUB_DB_SERVER (submarine_sub_db_server_get_type ())
#define SUBMARINE_SUB_DB_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUB_DB_SERVER, SubmarineSubDBServer))
#define SUBMARINE_SUB_DB_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUB_DB_SERVER, SubmarineSubDBServerClass))
#define SUBMARINE_IS_SUB_DB_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUB_DB_SERVER))
#define SUBMARINE_IS_SUB_DB_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUB_DB_SERVER))
#define SUBMARINE_SUB_DB_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUB_DB_SERVER, SubmarineSubDBServerClass))

typedef struct _SubmarineSubDBServer SubmarineSubDBServer;
typedef struct _SubmarineSubDBServerClass SubmarineSubDBServerClass;
typedef struct _SubmarineSubDBServerPrivate SubmarineSubDBServerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_checksum_free0(var) ((var == NULL) ? NULL : (var = (g_checksum_free (var), NULL)))

#define SUBMARINE_TYPE_SERVER_INFO (submarine_server_info_get_type ())
typedef struct _SubmarineServerInfo SubmarineServerInfo;
#define _submarine_subtitle_unref0(var) ((var == NULL) ? NULL : (var = (submarine_subtitle_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define __vala_SoupMessageHeaders_free0(var) ((var == NULL) ? NULL : (var = (_vala_SoupMessageHeaders_free (var), NULL)))

struct _SubmarineSubtitleServer {
	GObject parent_instance;
	SubmarineSubtitleServerPrivate * priv;
};

struct _SubmarineSubtitleServerClass {
	GObjectClass parent_class;
	gboolean (*connect) (SubmarineSubtitleServer* self);
	void (*disconnect) (SubmarineSubtitleServer* self);
	GeeSet* (*search) (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
	GeeMultiMap* (*search_multiple) (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
	SubmarineSubtitle* (*download) (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
	GeeSet* (*download_multiple) (SubmarineSubtitleServer* self, GeeCollection* subtitles);
};

struct _SubmarineSubDBServer {
	SubmarineSubtitleServer parent_instance;
	SubmarineSubDBServerPrivate * priv;
};

struct _SubmarineSubDBServerClass {
	SubmarineSubtitleServerClass parent_class;
};

struct _SubmarineSubDBServerPrivate {
	SoupSessionSync* session;
	gchar* filepath;
	gchar* filehash;
};

struct _SubmarineServerInfo {
	gchar* _name;
	gchar* _address;
	gchar* _code;
};


static gpointer submarine_sub_db_server_parent_class = NULL;

GType submarine_subtitle_server_get_type (void) G_GNUC_CONST;
gpointer submarine_subtitle_ref (gpointer instance);
void submarine_subtitle_unref (gpointer instance);
GParamSpec* submarine_param_spec_subtitle (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_subtitle (GValue* value, gpointer v_object);
void submarine_value_take_subtitle (GValue* value, gpointer v_object);
gpointer submarine_value_get_subtitle (const GValue* value);
GType submarine_subtitle_get_type (void) G_GNUC_CONST;
GType submarine_sub_db_server_get_type (void) G_GNUC_CONST;
#define SUBMARINE_SUB_DB_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_SUB_DB_SERVER, SubmarineSubDBServerPrivate))
enum  {
	SUBMARINE_SUB_DB_SERVER_DUMMY_PROPERTY
};
#define SUBMARINE_SUB_DB_SERVER_XMLRPC_URI "http://api.thesubdb.com/"
#define SUBMARINE_SUB_DB_SERVER_USER_AGENT "SubDB/1.0 (submarine/0.1; https://github.com/blazt/submarine)"
static guint64 submarine_sub_db_server_file_size (SubmarineSubDBServer* self, GFile* file, GError** error);
static gchar* submarine_sub_db_server_file_hash (SubmarineSubDBServer* self, GFile* file, GError** error);
static gboolean submarine_sub_db_server_real_connect (SubmarineSubtitleServer* base);
static void submarine_sub_db_server_real_disconnect (SubmarineSubtitleServer* base);
static GeeSet* submarine_sub_db_server_real_search (SubmarineSubtitleServer* base, GFile* file, GeeCollection* languages);
GType submarine_server_info_get_type (void) G_GNUC_CONST;
SubmarineServerInfo* submarine_server_info_dup (const SubmarineServerInfo* self);
void submarine_server_info_free (SubmarineServerInfo* self);
void submarine_server_info_copy (const SubmarineServerInfo* self, SubmarineServerInfo* dest);
void submarine_server_info_destroy (SubmarineServerInfo* self);
void submarine_subtitle_server_get_info (SubmarineSubtitleServer* self, SubmarineServerInfo* result);
SubmarineSubtitle* submarine_subtitle_new (SubmarineServerInfo* server_info, GValue* server_data);
SubmarineSubtitle* submarine_subtitle_construct (GType object_type, SubmarineServerInfo* server_info, GValue* server_data);
void submarine_subtitle_set_language (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_rating (SubmarineSubtitle* self, gdouble value);
static SubmarineSubtitle* submarine_sub_db_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle);
const gchar* submarine_subtitle_get_language (SubmarineSubtitle* self);
static SoupMessageHeaders* _vala_SoupMessageHeaders_copy (SoupMessageHeaders* self);
void submarine_subtitle_set_format (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_data (SubmarineSubtitle* self, const gchar* value);
static void _vala_SoupMessageHeaders_free (SoupMessageHeaders* self);
SubmarineSubDBServer* submarine_sub_db_server_new (void);
SubmarineSubDBServer* submarine_sub_db_server_construct (GType object_type);
SubmarineSubtitleServer* submarine_subtitle_server_construct (GType object_type);
static GObject * submarine_sub_db_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void submarine_server_info_init (SubmarineServerInfo *self, const gchar* name, const gchar* address, const gchar* code);
void submarine_subtitle_server_set_info (SubmarineSubtitleServer* self, SubmarineServerInfo* value);
static void submarine_sub_db_server_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static guint64 submarine_sub_db_server_file_size (SubmarineSubDBServer* self, GFile* file, GError** error) {
	guint64 result = 0ULL;
	FILE* _tmp0_ = NULL;
	GFileInfo* file_info = NULL;
	GFile* _tmp1_ = NULL;
	GFileInfo* _tmp2_ = NULL;
	gint64 _tmp3_ = 0LL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0ULL);
	g_return_val_if_fail (file != NULL, 0ULL);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "file_size\n");
	_tmp1_ = file;
	_tmp2_ = g_file_query_info (_tmp1_, "*", G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
	file_info = _tmp2_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return 0ULL;
	}
	_tmp3_ = g_file_info_get_size (file_info);
	result = (guint64) _tmp3_;
	_g_object_unref0 (file_info);
	return result;
}


static gchar* submarine_sub_db_server_file_hash (SubmarineSubDBServer* self, GFile* file, GError** error) {
	gchar* result = NULL;
	FILE* _tmp0_ = NULL;
	gchar* final_hash = NULL;
	guint64 size = 0ULL;
	guint8 buffer1[65536] = {0};
	guint8 buffer2[65536] = {0};
	guint64 _tmp1_ = 0ULL;
	GFile* _tmp2_ = NULL;
	guint64 _tmp3_ = 0ULL;
	FILE* _tmp4_ = NULL;
	guint64 _tmp5_ = 0ULL;
	guint64 _tmp6_ = 0ULL;
	GFileInputStream* _tmp8_ = NULL;
	GFile* _tmp9_ = NULL;
	GFileInputStream* _tmp10_ = NULL;
	GDataInputStream* dis = NULL;
	GDataInputStream* _tmp11_ = NULL;
	GDataInputStream* _tmp12_ = NULL;
	GFileInputStream* _tmp13_ = NULL;
	GFile* _tmp14_ = NULL;
	GFileInputStream* _tmp15_ = NULL;
	GDataInputStream* _tmp16_ = NULL;
	GDataInputStream* _tmp17_ = NULL;
	guint64 _tmp18_ = 0ULL;
	GDataInputStream* _tmp19_ = NULL;
	GChecksum* ch = NULL;
	GChecksum* _tmp20_ = NULL;
	GChecksum* _tmp21_ = NULL;
	GChecksum* _tmp22_ = NULL;
	GChecksum* _tmp23_ = NULL;
	const gchar* _tmp24_ = NULL;
	gchar* _tmp25_ = NULL;
	const gchar* _tmp26_ = NULL;
	gchar* _tmp27_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (file != NULL, NULL);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "file_hash\n");
	_tmp2_ = file;
	_tmp3_ = submarine_sub_db_server_file_size (self, _tmp2_, &_inner_error_);
	_tmp1_ = _tmp3_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_free0 (final_hash);
		return NULL;
	}
	size = _tmp1_;
	_tmp4_ = stdout;
	_tmp5_ = size;
	fprintf (_tmp4_, "Tamano: %lld\n", _tmp5_);
	_tmp6_ = size;
	if (_tmp6_ < ((guint64) 131072)) {
		gchar* _tmp7_ = NULL;
		_tmp7_ = g_strdup ("");
		result = _tmp7_;
		_g_free0 (final_hash);
		return result;
	}
	_tmp9_ = file;
	_tmp10_ = g_file_read (_tmp9_, NULL, &_inner_error_);
	_tmp8_ = _tmp10_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_free0 (final_hash);
		return NULL;
	}
	_tmp11_ = g_data_input_stream_new ((GInputStream*) _tmp8_);
	dis = _tmp11_;
	_tmp12_ = dis;
	g_input_stream_read ((GInputStream*) _tmp12_, buffer1, (gsize) 65536, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp8_);
		_g_free0 (final_hash);
		return NULL;
	}
	_tmp14_ = file;
	_tmp15_ = g_file_read (_tmp14_, NULL, &_inner_error_);
	_tmp13_ = _tmp15_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp8_);
		_g_free0 (final_hash);
		return NULL;
	}
	_tmp16_ = g_data_input_stream_new ((GInputStream*) _tmp13_);
	_g_object_unref0 (dis);
	dis = _tmp16_;
	_tmp17_ = dis;
	_tmp18_ = size;
	g_input_stream_skip ((GInputStream*) _tmp17_, (gsize) (_tmp18_ - 65536), NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (_tmp13_);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp8_);
		_g_free0 (final_hash);
		return NULL;
	}
	_tmp19_ = dis;
	g_input_stream_read ((GInputStream*) _tmp19_, buffer2, (gsize) 65536, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (_tmp13_);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp8_);
		_g_free0 (final_hash);
		return NULL;
	}
	_tmp20_ = g_checksum_new (G_CHECKSUM_MD5);
	ch = _tmp20_;
	_tmp21_ = ch;
	g_checksum_update (_tmp21_, (guchar*) buffer1, (gsize) 65536);
	_tmp22_ = ch;
	g_checksum_update (_tmp22_, (guchar*) buffer2, (gsize) 65536);
	_tmp23_ = ch;
	_tmp24_ = g_checksum_get_string (_tmp23_);
	_tmp25_ = g_strdup (_tmp24_);
	_g_free0 (final_hash);
	final_hash = _tmp25_;
	_tmp26_ = final_hash;
	_tmp27_ = g_strdup (_tmp26_);
	_g_free0 (self->priv->filehash);
	self->priv->filehash = _tmp27_;
	result = final_hash;
	_g_checksum_free0 (ch);
	_g_object_unref0 (_tmp13_);
	_g_object_unref0 (dis);
	_g_object_unref0 (_tmp8_);
	return result;
}


static gboolean submarine_sub_db_server_real_connect (SubmarineSubtitleServer* base) {
	SubmarineSubDBServer * self;
	gboolean result = FALSE;
	SoupSessionSync* _tmp0_ = NULL;
	self = (SubmarineSubDBServer*) base;
	_tmp0_ = (SoupSessionSync*) soup_session_sync_new ();
	_g_object_unref0 (self->priv->session);
	self->priv->session = _tmp0_;
	result = TRUE;
	return result;
}


static void submarine_sub_db_server_real_disconnect (SubmarineSubtitleServer* base) {
	SubmarineSubDBServer * self;
	self = (SubmarineSubDBServer*) base;
}


static GeeSet* submarine_sub_db_server_real_search (SubmarineSubtitleServer* base, GFile* file, GeeCollection* languages) {
	SubmarineSubDBServer * self;
	GeeSet* result = NULL;
	GFile* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	GeeHashSet* subtitles_downloaded = NULL;
	GeeHashSet* _tmp2_ = NULL;
	gchar* hash = NULL;
	GFile* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	SoupMessage* message = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	SoupMessage* _tmp9_ = NULL;
	SoupMessage* _tmp10_ = NULL;
	SoupMessage* _tmp11_ = NULL;
	SoupMessageHeaders* _tmp12_ = NULL;
	guint status_code = 0U;
	SoupSessionSync* _tmp13_ = NULL;
	SoupMessage* _tmp14_ = NULL;
	guint _tmp15_ = 0U;
	guint _tmp16_ = 0U;
	GError * _inner_error_ = NULL;
	self = (SubmarineSubDBServer*) base;
	g_return_val_if_fail (file != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_tmp0_ = file;
	_tmp1_ = g_file_get_path (_tmp0_);
	_g_free0 (self->priv->filepath);
	self->priv->filepath = _tmp1_;
	_tmp2_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_downloaded = _tmp2_;
	_tmp3_ = file;
	_tmp4_ = submarine_sub_db_server_file_hash (self, _tmp3_, &_inner_error_);
	hash = _tmp4_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (subtitles_downloaded);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp5_ = g_strdup_printf ("?action=search&hash=%s", hash);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_strconcat (SUBMARINE_SUB_DB_SERVER_XMLRPC_URI, _tmp6_, NULL);
	_tmp8_ = _tmp7_;
	_tmp9_ = soup_message_new ("GET", _tmp8_);
	_tmp10_ = _tmp9_;
	_g_free0 (_tmp8_);
	_g_free0 (_tmp6_);
	message = _tmp10_;
	_tmp11_ = message;
	_tmp12_ = _tmp11_->request_headers;
	soup_message_headers_append (_tmp12_, "User-Agent", SUBMARINE_SUB_DB_SERVER_USER_AGENT);
	_tmp13_ = self->priv->session;
	_tmp14_ = message;
	_tmp15_ = soup_session_send_message ((SoupSession*) _tmp13_, _tmp14_);
	status_code = _tmp15_;
	_tmp16_ = status_code;
	if (_tmp16_ == ((guint) 200)) {
		gchar* rv = NULL;
		SoupMessage* _tmp17_ = NULL;
		SoupMessageBody* _tmp18_ = NULL;
		guint8* _tmp19_ = NULL;
		gint _tmp19__length1 = 0;
		gchar* _tmp20_ = NULL;
		gchar** list = NULL;
		const gchar* _tmp21_ = NULL;
		gchar** _tmp22_ = NULL;
		gchar** _tmp23_ = NULL;
		gint list_length1 = 0;
		gint _list_size_ = 0;
		GValue v = {0};
		GValue _tmp24_ = {0};
		gchar** _tmp25_ = NULL;
		gint _tmp25__length1 = 0;
		_tmp17_ = message;
		_tmp18_ = _tmp17_->response_body;
		_tmp19_ = _tmp18_->data;
		_tmp19__length1 = (gint) _tmp18_->length;
		_tmp20_ = g_strdup ((const gchar*) _tmp19_);
		rv = _tmp20_;
		_tmp21_ = rv;
		_tmp23_ = _tmp22_ = g_strsplit (_tmp21_, ",", 0);
		list = _tmp23_;
		list_length1 = _vala_array_length (_tmp22_);
		_list_size_ = list_length1;
		g_value_init (&_tmp24_, G_TYPE_STRING);
		g_value_set_string (&_tmp24_, hash);
		v = _tmp24_;
		_tmp25_ = list;
		_tmp25__length1 = list_length1;
		{
			gchar** sub_collection = NULL;
			gint sub_collection_length1 = 0;
			gint _sub_collection_size_ = 0;
			gint sub_it = 0;
			sub_collection = _tmp25_;
			sub_collection_length1 = _tmp25__length1;
			for (sub_it = 0; sub_it < _tmp25__length1; sub_it = sub_it + 1) {
				gchar* _tmp26_ = NULL;
				gchar* sub = NULL;
				_tmp26_ = g_strdup (sub_collection[sub_it]);
				sub = _tmp26_;
				{
					GeeCollection* _tmp27_ = NULL;
					const gchar* _tmp28_ = NULL;
					gboolean _tmp29_ = FALSE;
					_tmp27_ = languages;
					_tmp28_ = sub;
					_tmp29_ = gee_collection_contains (_tmp27_, _tmp28_);
					if (_tmp29_) {
						SubmarineSubtitle* subtitle = NULL;
						SubmarineServerInfo _tmp30_ = {0};
						SubmarineServerInfo _tmp31_ = {0};
						GValue _tmp32_ = {0};
						SubmarineSubtitle* _tmp33_ = NULL;
						SubmarineSubtitle* _tmp34_ = NULL;
						const gchar* _tmp35_ = NULL;
						SubmarineSubtitle* _tmp36_ = NULL;
						SubmarineSubtitle* _tmp37_ = NULL;
						submarine_subtitle_server_get_info ((SubmarineSubtitleServer*) self, &_tmp30_);
						_tmp31_ = _tmp30_;
						_tmp32_ = v;
						_tmp33_ = submarine_subtitle_new (&_tmp31_, &_tmp32_);
						subtitle = _tmp33_;
						_tmp34_ = subtitle;
						_tmp35_ = sub;
						submarine_subtitle_set_language (_tmp34_, _tmp35_);
						_tmp36_ = subtitle;
						submarine_subtitle_set_rating (_tmp36_, 9.0);
						_tmp37_ = subtitle;
						gee_abstract_collection_add ((GeeAbstractCollection*) subtitles_downloaded, _tmp37_);
						_submarine_subtitle_unref0 (subtitle);
					}
					_g_free0 (sub);
				}
			}
		}
		G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
		list = (_vala_array_free (list, list_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (rv);
	}
	result = (GeeSet*) subtitles_downloaded;
	_g_object_unref0 (message);
	_g_free0 (hash);
	return result;
}


static SoupMessageHeaders* _vala_SoupMessageHeaders_copy (SoupMessageHeaders* self) {
	return g_boxed_copy (soup_message_headers_get_type (), self);
}


static gpointer __vala_SoupMessageHeaders_copy0 (gpointer self) {
	return self ? _vala_SoupMessageHeaders_copy (self) : NULL;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


static gint string_last_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gpointer _submarine_subtitle_ref0 (gpointer self) {
	return self ? submarine_subtitle_ref (self) : NULL;
}


static void _vala_SoupMessageHeaders_free (SoupMessageHeaders* self) {
	g_boxed_free (soup_message_headers_get_type (), self);
}


static SubmarineSubtitle* submarine_sub_db_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle) {
	SubmarineSubDBServer * self;
	SubmarineSubtitle* result = NULL;
	SoupMessage* message = NULL;
	const gchar* _tmp0_ = NULL;
	SubmarineSubtitle* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	SoupMessage* _tmp8_ = NULL;
	SoupMessage* _tmp9_ = NULL;
	SoupMessage* _tmp10_ = NULL;
	SoupMessageHeaders* _tmp11_ = NULL;
	guint status_code = 0U;
	SoupSessionSync* _tmp12_ = NULL;
	SoupMessage* _tmp13_ = NULL;
	guint _tmp14_ = 0U;
	guint _tmp15_ = 0U;
	self = (SubmarineSubDBServer*) base;
	g_return_val_if_fail (subtitle != NULL, NULL);
	_tmp0_ = self->priv->filehash;
	_tmp1_ = subtitle;
	_tmp2_ = submarine_subtitle_get_language (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strdup_printf ("?action=download&hash=%s&language_codes_string=%s", _tmp0_, _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat (SUBMARINE_SUB_DB_SERVER_XMLRPC_URI, _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = soup_message_new ("GET", _tmp7_);
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	message = _tmp9_;
	_tmp10_ = message;
	_tmp11_ = _tmp10_->request_headers;
	soup_message_headers_append (_tmp11_, "User-Agent", SUBMARINE_SUB_DB_SERVER_USER_AGENT);
	_tmp12_ = self->priv->session;
	_tmp13_ = message;
	_tmp14_ = soup_session_send_message ((SoupSession*) _tmp12_, _tmp13_);
	status_code = _tmp14_;
	_tmp15_ = status_code;
	if (_tmp15_ == ((guint) 200)) {
		SoupMessageHeaders* rsp = NULL;
		SoupMessage* _tmp16_ = NULL;
		SoupMessageHeaders* _tmp17_ = NULL;
		SoupMessageHeaders* _tmp18_ = NULL;
		gchar* type = NULL;
		gchar* _tmp19_ = NULL;
		gchar* cadena = NULL;
		GHashTable* params = NULL;
		SoupMessageHeaders* _tmp20_ = NULL;
		gchar* _tmp21_ = NULL;
		GHashTable* _tmp22_ = NULL;
		gboolean _tmp23_ = FALSE;
		gboolean _tmp37_ = FALSE;
		const gchar* _tmp38_ = NULL;
		gchar* _tmp39_ = NULL;
		gchar* _tmp40_ = NULL;
		gchar* _tmp41_ = NULL;
		gchar* _tmp42_ = NULL;
		gboolean _tmp43_ = FALSE;
		_tmp16_ = message;
		_tmp17_ = _tmp16_->response_headers;
		_tmp18_ = __vala_SoupMessageHeaders_copy0 (_tmp17_);
		rsp = _tmp18_;
		_tmp19_ = g_strdup ("");
		type = _tmp19_;
		_tmp20_ = rsp;
		_tmp23_ = soup_message_headers_get_content_disposition (_tmp20_, &_tmp21_, &_tmp22_);
		_g_free0 (cadena);
		cadena = _tmp21_;
		_g_hash_table_unref0 (params);
		params = _tmp22_;
		if (_tmp23_) {
			GList* lista = NULL;
			GHashTable* _tmp24_ = NULL;
			GList* _tmp25_ = NULL;
			GList* _tmp26_ = NULL;
			_tmp24_ = params;
			_tmp25_ = g_hash_table_get_keys (_tmp24_);
			lista = _tmp25_;
			_tmp26_ = lista;
			{
				GList* entrada_collection = NULL;
				GList* entrada_it = NULL;
				entrada_collection = _tmp26_;
				for (entrada_it = entrada_collection; entrada_it != NULL; entrada_it = entrada_it->next) {
					gchar* _tmp27_ = NULL;
					gchar* entrada = NULL;
					_tmp27_ = g_strdup ((const gchar*) entrada_it->data);
					entrada = _tmp27_;
					{
						const gchar* _tmp28_ = NULL;
						_tmp28_ = entrada;
						if (g_strcmp0 (_tmp28_, "filename") == 0) {
							gchar* valor = NULL;
							GHashTable* _tmp29_ = NULL;
							const gchar* _tmp30_ = NULL;
							gconstpointer _tmp31_ = NULL;
							gchar* _tmp32_ = NULL;
							const gchar* _tmp33_ = NULL;
							const gchar* _tmp34_ = NULL;
							gint _tmp35_ = 0;
							gchar* _tmp36_ = NULL;
							_tmp29_ = params;
							_tmp30_ = entrada;
							_tmp31_ = g_hash_table_lookup (_tmp29_, _tmp30_);
							_tmp32_ = g_strdup ((const gchar*) _tmp31_);
							valor = _tmp32_;
							_tmp33_ = valor;
							_tmp34_ = valor;
							_tmp35_ = string_last_index_of (_tmp34_, ".", 0);
							_tmp36_ = string_substring (_tmp33_, (glong) (_tmp35_ + 1), (glong) (-1));
							_g_free0 (type);
							type = _tmp36_;
							_g_free0 (valor);
						}
						_g_free0 (entrada);
					}
				}
			}
			_g_list_free0 (lista);
		}
		_tmp38_ = type;
		_tmp39_ = g_utf8_casefold (_tmp38_, (gssize) (-1));
		_tmp40_ = _tmp39_;
		_tmp41_ = g_utf8_casefold ("sub", (gssize) (-1));
		_tmp42_ = _tmp41_;
		_tmp43_ = g_strcmp0 (_tmp40_, _tmp42_) == 0;
		_g_free0 (_tmp42_);
		_g_free0 (_tmp40_);
		if (_tmp43_) {
			_tmp37_ = TRUE;
		} else {
			const gchar* _tmp44_ = NULL;
			gchar* _tmp45_ = NULL;
			gchar* _tmp46_ = NULL;
			gchar* _tmp47_ = NULL;
			gchar* _tmp48_ = NULL;
			_tmp44_ = type;
			_tmp45_ = g_utf8_casefold (_tmp44_, (gssize) (-1));
			_tmp46_ = _tmp45_;
			_tmp47_ = g_utf8_casefold ("srt", (gssize) (-1));
			_tmp48_ = _tmp47_;
			_tmp37_ = g_strcmp0 (_tmp46_, _tmp48_) == 0;
			_g_free0 (_tmp48_);
			_g_free0 (_tmp46_);
		}
		if (_tmp37_) {
			SubmarineSubtitle* _tmp49_ = NULL;
			const gchar* _tmp50_ = NULL;
			SubmarineSubtitle* _tmp51_ = NULL;
			SoupMessage* _tmp52_ = NULL;
			SoupMessageBody* _tmp53_ = NULL;
			guint8* _tmp54_ = NULL;
			gint _tmp54__length1 = 0;
			SubmarineSubtitle* _tmp55_ = NULL;
			SubmarineSubtitle* _tmp56_ = NULL;
			_tmp49_ = subtitle;
			_tmp50_ = type;
			submarine_subtitle_set_format (_tmp49_, _tmp50_);
			_tmp51_ = subtitle;
			_tmp52_ = message;
			_tmp53_ = _tmp52_->response_body;
			_tmp54_ = _tmp53_->data;
			_tmp54__length1 = (gint) _tmp53_->length;
			submarine_subtitle_set_data (_tmp51_, (const gchar*) _tmp54_);
			_tmp55_ = subtitle;
			_tmp56_ = _submarine_subtitle_ref0 (_tmp55_);
			result = _tmp56_;
			_g_hash_table_unref0 (params);
			_g_free0 (cadena);
			_g_free0 (type);
			__vala_SoupMessageHeaders_free0 (rsp);
			_g_object_unref0 (message);
			return result;
		} else {
			result = NULL;
			_g_hash_table_unref0 (params);
			_g_free0 (cadena);
			_g_free0 (type);
			__vala_SoupMessageHeaders_free0 (rsp);
			_g_object_unref0 (message);
			return result;
		}
		_g_hash_table_unref0 (params);
		_g_free0 (cadena);
		_g_free0 (type);
		__vala_SoupMessageHeaders_free0 (rsp);
	}
	result = NULL;
	_g_object_unref0 (message);
	return result;
}


SubmarineSubDBServer* submarine_sub_db_server_construct (GType object_type) {
	SubmarineSubDBServer * self = NULL;
	self = (SubmarineSubDBServer*) submarine_subtitle_server_construct (object_type);
	return self;
}


SubmarineSubDBServer* submarine_sub_db_server_new (void) {
	return submarine_sub_db_server_construct (SUBMARINE_TYPE_SUB_DB_SERVER);
}


static GObject * submarine_sub_db_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SubmarineSubDBServer * self;
	SubmarineServerInfo _tmp0_ = {0};
	SubmarineServerInfo _tmp1_ = {0};
	gchar* _tmp2_ = NULL;
	parent_class = G_OBJECT_CLASS (submarine_sub_db_server_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_SUB_DB_SERVER, SubmarineSubDBServer);
	submarine_server_info_init (&_tmp0_, "SubDB", "http://thesubdb.com", "db");
	_tmp1_ = _tmp0_;
	submarine_subtitle_server_set_info ((SubmarineSubtitleServer*) self, &_tmp1_);
	submarine_server_info_destroy (&_tmp1_);
	_tmp2_ = g_strdup ("");
	_g_free0 (self->priv->filepath);
	self->priv->filepath = _tmp2_;
	return obj;
}


static void submarine_sub_db_server_class_init (SubmarineSubDBServerClass * klass) {
	submarine_sub_db_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SubmarineSubDBServerPrivate));
	((SubmarineSubtitleServerClass *) klass)->connect = submarine_sub_db_server_real_connect;
	((SubmarineSubtitleServerClass *) klass)->disconnect = submarine_sub_db_server_real_disconnect;
	((SubmarineSubtitleServerClass *) klass)->search = submarine_sub_db_server_real_search;
	((SubmarineSubtitleServerClass *) klass)->download = submarine_sub_db_server_real_download;
	G_OBJECT_CLASS (klass)->constructor = submarine_sub_db_server_constructor;
	G_OBJECT_CLASS (klass)->finalize = submarine_sub_db_server_finalize;
}


static void submarine_sub_db_server_instance_init (SubmarineSubDBServer * self) {
	self->priv = SUBMARINE_SUB_DB_SERVER_GET_PRIVATE (self);
}


static void submarine_sub_db_server_finalize (GObject* obj) {
	SubmarineSubDBServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_SUB_DB_SERVER, SubmarineSubDBServer);
	_g_object_unref0 (self->priv->session);
	_g_free0 (self->priv->filepath);
	_g_free0 (self->priv->filehash);
	G_OBJECT_CLASS (submarine_sub_db_server_parent_class)->finalize (obj);
}


GType submarine_sub_db_server_get_type (void) {
	static volatile gsize submarine_sub_db_server_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_sub_db_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineSubDBServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_sub_db_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineSubDBServer), 0, (GInstanceInitFunc) submarine_sub_db_server_instance_init, NULL };
		GType submarine_sub_db_server_type_id;
		submarine_sub_db_server_type_id = g_type_register_static (SUBMARINE_TYPE_SUBTITLE_SERVER, "SubmarineSubDBServer", &g_define_type_info, 0);
		g_once_init_leave (&submarine_sub_db_server_type_id__volatile, submarine_sub_db_server_type_id);
	}
	return submarine_sub_db_server_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



