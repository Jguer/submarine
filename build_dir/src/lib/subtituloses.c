/* subtituloses.c generated by valac 0.28.0, the Vala compiler
 * generated from subtituloses.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <libsoup/soup.h>
#include <libxml/tree.h>
#include <stdio.h>
#include <libxml/HTMLtree.h>
#include <libxml/HTMLparser.h>
#include <libxml/parser.h>
#include <float.h>
#include <math.h>


#define SUBMARINE_TYPE_SUBTITLE_SERVER (submarine_subtitle_server_get_type ())
#define SUBMARINE_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServer))
#define SUBMARINE_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))
#define SUBMARINE_IS_SUBTITLE_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_IS_SUBTITLE_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE_SERVER))
#define SUBMARINE_SUBTITLE_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE_SERVER, SubmarineSubtitleServerClass))

typedef struct _SubmarineSubtitleServer SubmarineSubtitleServer;
typedef struct _SubmarineSubtitleServerClass SubmarineSubtitleServerClass;
typedef struct _SubmarineSubtitleServerPrivate SubmarineSubtitleServerPrivate;

#define SUBMARINE_TYPE_SUBTITLE (submarine_subtitle_get_type ())
#define SUBMARINE_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitle))
#define SUBMARINE_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))
#define SUBMARINE_IS_SUBTITLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_IS_SUBTITLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITLE))
#define SUBMARINE_SUBTITLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITLE, SubmarineSubtitleClass))

typedef struct _SubmarineSubtitle SubmarineSubtitle;
typedef struct _SubmarineSubtitleClass SubmarineSubtitleClass;

#define SUBMARINE_TYPE_SUBTITULOS_ES_SERVER (submarine_subtitulos_es_server_get_type ())
#define SUBMARINE_SUBTITULOS_ES_SERVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER, SubmarineSubtitulosESServer))
#define SUBMARINE_SUBTITULOS_ES_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER, SubmarineSubtitulosESServerClass))
#define SUBMARINE_IS_SUBTITULOS_ES_SERVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER))
#define SUBMARINE_IS_SUBTITULOS_ES_SERVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER))
#define SUBMARINE_SUBTITULOS_ES_SERVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER, SubmarineSubtitulosESServerClass))

typedef struct _SubmarineSubtitulosESServer SubmarineSubtitulosESServer;
typedef struct _SubmarineSubtitulosESServerClass SubmarineSubtitulosESServerClass;
typedef struct _SubmarineSubtitulosESServerPrivate SubmarineSubtitulosESServerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define SUBMARINE_TYPE_NAME_PARSER (submarine_name_parser_get_type ())
#define SUBMARINE_NAME_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParser))
#define SUBMARINE_NAME_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParserClass))
#define SUBMARINE_IS_NAME_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SUBMARINE_TYPE_NAME_PARSER))
#define SUBMARINE_IS_NAME_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SUBMARINE_TYPE_NAME_PARSER))
#define SUBMARINE_NAME_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SUBMARINE_TYPE_NAME_PARSER, SubmarineNameParserClass))

typedef struct _SubmarineNameParser SubmarineNameParser;
typedef struct _SubmarineNameParserClass SubmarineNameParserClass;
typedef struct _SubmarineNameParserPrivate SubmarineNameParserPrivate;

#define SUBMARINE_TYPE_RESOLUTION (submarine_resolution_get_type ())

#define SUBMARINE_TYPE_CODEC (submarine_codec_get_type ())

#define SUBMARINE_TYPE_SOURCE (submarine_source_get_type ())
#define _submarine_name_parser_unref0(var) ((var == NULL) ? NULL : (var = (submarine_name_parser_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define SUBMARINE_TYPE_SERVER_INFO (submarine_server_info_get_type ())
typedef struct _SubmarineServerInfo SubmarineServerInfo;
#define _submarine_subtitle_unref0(var) ((var == NULL) ? NULL : (var = (submarine_subtitle_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define __vala_SoupMessageHeaders_free0(var) ((var == NULL) ? NULL : (var = (_vala_SoupMessageHeaders_free (var), NULL)))

struct _SubmarineSubtitleServer {
	GObject parent_instance;
	SubmarineSubtitleServerPrivate * priv;
};

struct _SubmarineSubtitleServerClass {
	GObjectClass parent_class;
	gboolean (*connect) (SubmarineSubtitleServer* self);
	void (*disconnect) (SubmarineSubtitleServer* self);
	GeeSet* (*search) (SubmarineSubtitleServer* self, GFile* file, GeeCollection* languages);
	GeeMultiMap* (*search_multiple) (SubmarineSubtitleServer* self, GeeCollection* files, GeeCollection* languages);
	SubmarineSubtitle* (*download) (SubmarineSubtitleServer* self, SubmarineSubtitle* subtitle);
	GeeSet* (*download_multiple) (SubmarineSubtitleServer* self, GeeCollection* subtitles);
};

struct _SubmarineSubtitulosESServer {
	SubmarineSubtitleServer parent_instance;
	SubmarineSubtitulosESServerPrivate * priv;
};

struct _SubmarineSubtitulosESServerClass {
	SubmarineSubtitleServerClass parent_class;
};

struct _SubmarineSubtitulosESServerPrivate {
	SoupSessionSync* session;
	gchar* filepath;
	xmlNode* internal_last_node;
};

typedef enum  {
	SUBMARINE_RESOLUTION_PAL_NTSC,
	SUBMARINE_RESOLUTION_HDREADY,
	SUBMARINE_RESOLUTION_FULLHD,
	SUBMARINE_RESOLUTION_UNKNOWN
} SubmarineResolution;

typedef enum  {
	SUBMARINE_CODEC_X264,
	SUBMARINE_CODEC_DIVX,
	SUBMARINE_CODEC_XVID,
	SUBMARINE_CODEC_MPEG,
	SUBMARINE_CODEC_UNKNOWN
} SubmarineCodec;

typedef enum  {
	SUBMARINE_SOURCE_DVDRIP,
	SUBMARINE_SOURCE_BDRIP,
	SUBMARINE_SOURCE_HDTV,
	SUBMARINE_SOURCE_UNKNOWN
} SubmarineSource;

struct _SubmarineNameParser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SubmarineNameParserPrivate * priv;
	gchar* title;
	gint year;
	gint season;
	gint chapter;
	SubmarineResolution resolution;
	SubmarineCodec codec;
	SubmarineSource source;
};

struct _SubmarineNameParserClass {
	GTypeClass parent_class;
	void (*finalize) (SubmarineNameParser *self);
};

struct _SubmarineServerInfo {
	gchar* _name;
	gchar* _address;
	gchar* _code;
};


static gpointer submarine_subtitulos_es_server_parent_class = NULL;

GType submarine_subtitle_server_get_type (void) G_GNUC_CONST;
gpointer submarine_subtitle_ref (gpointer instance);
void submarine_subtitle_unref (gpointer instance);
GParamSpec* submarine_param_spec_subtitle (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_subtitle (GValue* value, gpointer v_object);
void submarine_value_take_subtitle (GValue* value, gpointer v_object);
gpointer submarine_value_get_subtitle (const GValue* value);
GType submarine_subtitle_get_type (void) G_GNUC_CONST;
GType submarine_subtitulos_es_server_get_type (void) G_GNUC_CONST;
#define SUBMARINE_SUBTITULOS_ES_SERVER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SUBMARINE_TYPE_SUBTITULOS_ES_SERVER, SubmarineSubtitulosESServerPrivate))
enum  {
	SUBMARINE_SUBTITULOS_ES_SERVER_DUMMY_PROPERTY
};
#define SUBMARINE_SUBTITULOS_ES_SERVER_MAIN_URI "http://duckduckgo.com/html"
#define SUBMARINE_SUBTITULOS_ES_SERVER_SECD_URI "http://www.subtitulos.es"
#define SUBMARINE_SUBTITULOS_ES_SERVER_USER_AGENT "submarine/0.1"
static gboolean submarine_subtitulos_es_server_real_connect (SubmarineSubtitleServer* base);
static void submarine_subtitulos_es_server_real_disconnect (SubmarineSubtitleServer* base);
static gboolean submarine_subtitulos_es_server_check_attribute (SubmarineSubtitulosESServer* self, xmlNode* c_node, const gchar* attr_name, const gchar* attr_value);
static xmlNode* submarine_subtitulos_es_server_find_node (SubmarineSubtitulosESServer* self, xmlNode* c_node, const gchar* name, const gchar* attr_name, const gchar* attr_value, xmlNode* last, gboolean is_first);
static gchar* submarine_subtitulos_es_server_get_inner_text (SubmarineSubtitulosESServer* self, xmlNode* c_node);
static GeeSet* submarine_subtitulos_es_server_real_search (SubmarineSubtitleServer* base, GFile* file, GeeCollection* languages);
gpointer submarine_name_parser_ref (gpointer instance);
void submarine_name_parser_unref (gpointer instance);
GParamSpec* submarine_param_spec_name_parser (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void submarine_value_set_name_parser (GValue* value, gpointer v_object);
void submarine_value_take_name_parser (GValue* value, gpointer v_object);
gpointer submarine_value_get_name_parser (const GValue* value);
GType submarine_name_parser_get_type (void) G_GNUC_CONST;
SubmarineNameParser* submarine_name_parser_new (GFile* file);
SubmarineNameParser* submarine_name_parser_construct (GType object_type, GFile* file);
GType submarine_resolution_get_type (void) G_GNUC_CONST;
GType submarine_codec_get_type (void) G_GNUC_CONST;
GType submarine_source_get_type (void) G_GNUC_CONST;
static gboolean submarine_subtitulos_es_server_extract_subtitles (SubmarineSubtitulosESServer* self, const gchar* uri, GeeCollection* languages, GeeSet* subtitles_downloaded, gdouble rating);
gchar* submarine_get_alternate (const gchar* language);
GType submarine_server_info_get_type (void) G_GNUC_CONST;
SubmarineServerInfo* submarine_server_info_dup (const SubmarineServerInfo* self);
void submarine_server_info_free (SubmarineServerInfo* self);
void submarine_server_info_copy (const SubmarineServerInfo* self, SubmarineServerInfo* dest);
void submarine_server_info_destroy (SubmarineServerInfo* self);
void submarine_subtitle_server_get_info (SubmarineSubtitleServer* self, SubmarineServerInfo* result);
SubmarineSubtitle* submarine_subtitle_new (SubmarineServerInfo* server_info, GValue* server_data);
SubmarineSubtitle* submarine_subtitle_construct (GType object_type, SubmarineServerInfo* server_info, GValue* server_data);
void submarine_subtitle_set_language (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_data (SubmarineSubtitle* self, const gchar* value);
void submarine_subtitle_set_rating (SubmarineSubtitle* self, gdouble value);
static SubmarineSubtitle* submarine_subtitulos_es_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle);
void submarine_subtitle_get_server_data (SubmarineSubtitle* self, GValue* result);
const gchar* submarine_subtitle_get_data (SubmarineSubtitle* self);
static SoupMessageHeaders* _vala_SoupMessageHeaders_copy (SoupMessageHeaders* self);
void submarine_subtitle_set_format (SubmarineSubtitle* self, const gchar* value);
static void _vala_SoupMessageHeaders_free (SoupMessageHeaders* self);
SubmarineSubtitulosESServer* submarine_subtitulos_es_server_new (void);
SubmarineSubtitulosESServer* submarine_subtitulos_es_server_construct (GType object_type);
SubmarineSubtitleServer* submarine_subtitle_server_construct (GType object_type);
static GObject * submarine_subtitulos_es_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
void submarine_server_info_init (SubmarineServerInfo *self, const gchar* name, const gchar* address, const gchar* code);
void submarine_subtitle_server_set_info (SubmarineSubtitleServer* self, SubmarineServerInfo* value);
static void submarine_subtitulos_es_server_finalize (GObject* obj);


static gboolean submarine_subtitulos_es_server_real_connect (SubmarineSubtitleServer* base) {
	SubmarineSubtitulosESServer * self;
	gboolean result = FALSE;
	SoupSessionSync* _tmp0_ = NULL;
	self = (SubmarineSubtitulosESServer*) base;
	_tmp0_ = (SoupSessionSync*) soup_session_sync_new ();
	_g_object_unref0 (self->priv->session);
	self->priv->session = _tmp0_;
	result = TRUE;
	return result;
}


static void submarine_subtitulos_es_server_real_disconnect (SubmarineSubtitleServer* base) {
	SubmarineSubtitulosESServer * self;
	self = (SubmarineSubtitulosESServer*) base;
}


static gboolean submarine_subtitulos_es_server_check_attribute (SubmarineSubtitulosESServer* self, xmlNode* c_node, const gchar* attr_name, const gchar* attr_value) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	xmlAttr* prop = NULL;
	xmlNode* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	xmlAttr* _tmp3_ = NULL;
	xmlAttr* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (attr_name != NULL, FALSE);
	g_return_val_if_fail (attr_value != NULL, FALSE);
	_tmp0_ = attr_name;
	if (g_strcmp0 (_tmp0_, "") == 0) {
		result = TRUE;
		return result;
	}
	_tmp1_ = c_node;
	_tmp2_ = attr_name;
	_tmp3_ = xmlHasProp (_tmp1_, (xmlChar*) _tmp2_);
	prop = _tmp3_;
	_tmp4_ = prop;
	if (NULL != _tmp4_) {
		const gchar* _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		xmlAttr* _tmp7_ = NULL;
		xmlNode* _tmp8_ = NULL;
		_tmp5_ = attr_value;
		if (g_strcmp0 (_tmp5_, "") == 0) {
			result = TRUE;
			return result;
		}
		_tmp7_ = prop;
		_tmp8_ = _tmp7_->children;
		if (_tmp8_ != NULL) {
			xmlAttr* _tmp9_ = NULL;
			xmlNode* _tmp10_ = NULL;
			const gchar* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			_tmp9_ = prop;
			_tmp10_ = _tmp9_->children;
			_tmp11_ = _tmp10_->content;
			_tmp12_ = attr_value;
			_tmp6_ = g_strcmp0 (_tmp11_, _tmp12_) == 0;
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			result = TRUE;
			return result;
		}
	}
	result = FALSE;
	return result;
}


static xmlNode* submarine_subtitulos_es_server_find_node (SubmarineSubtitulosESServer* self, xmlNode* c_node, const gchar* name, const gchar* attr_name, const gchar* attr_value, xmlNode* last, gboolean is_first) {
	xmlNode* result = NULL;
	xmlNode* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp3_ = FALSE;
	xmlNode* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	xmlNode* _tmp13_ = NULL;
	xmlNode* _tmp14_ = NULL;
	xmlNode* _tmp15_ = NULL;
	xmlNode* _tmp16_ = NULL;
	xmlNode* _tmp25_ = NULL;
	xmlNode* _tmp26_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (attr_name != NULL, NULL);
	g_return_val_if_fail (attr_value != NULL, NULL);
	_tmp0_ = c_node;
	if (_tmp0_ == NULL) {
		result = NULL;
		return result;
	}
	_tmp1_ = is_first;
	if (_tmp1_) {
		xmlNode* _tmp2_ = NULL;
		_tmp2_ = last;
		self->priv->internal_last_node = _tmp2_;
	}
	_tmp4_ = c_node;
	_tmp5_ = _tmp4_->name;
	_tmp6_ = name;
	if (g_strcmp0 (_tmp5_, _tmp6_) == 0) {
		xmlNode* _tmp7_ = NULL;
		_tmp7_ = self->priv->internal_last_node;
		_tmp3_ = _tmp7_ == NULL;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		xmlNode* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		_tmp8_ = c_node;
		_tmp9_ = attr_name;
		_tmp10_ = attr_value;
		_tmp11_ = submarine_subtitulos_es_server_check_attribute (self, _tmp8_, _tmp9_, _tmp10_);
		if (_tmp11_) {
			xmlNode* _tmp12_ = NULL;
			_tmp12_ = c_node;
			result = _tmp12_;
			return result;
		}
	}
	_tmp13_ = c_node;
	_tmp14_ = self->priv->internal_last_node;
	if (_tmp13_ == _tmp14_) {
		self->priv->internal_last_node = NULL;
	}
	_tmp15_ = c_node;
	_tmp16_ = _tmp15_->children;
	if (_tmp16_ != NULL) {
		xmlNode* rv = NULL;
		xmlNode* _tmp17_ = NULL;
		xmlNode* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		xmlNode* _tmp22_ = NULL;
		xmlNode* _tmp23_ = NULL;
		_tmp17_ = c_node;
		_tmp18_ = _tmp17_->children;
		_tmp19_ = name;
		_tmp20_ = attr_name;
		_tmp21_ = attr_value;
		_tmp22_ = submarine_subtitulos_es_server_find_node (self, _tmp18_, _tmp19_, _tmp20_, _tmp21_, NULL, FALSE);
		rv = _tmp22_;
		_tmp23_ = rv;
		if (_tmp23_ != NULL) {
			xmlNode* _tmp24_ = NULL;
			_tmp24_ = rv;
			result = _tmp24_;
			return result;
		}
	}
	_tmp25_ = c_node;
	_tmp26_ = _tmp25_->next;
	if (_tmp26_ != NULL) {
		xmlNode* rv = NULL;
		xmlNode* _tmp27_ = NULL;
		xmlNode* _tmp28_ = NULL;
		const gchar* _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		const gchar* _tmp31_ = NULL;
		xmlNode* _tmp32_ = NULL;
		xmlNode* _tmp33_ = NULL;
		_tmp27_ = c_node;
		_tmp28_ = _tmp27_->next;
		_tmp29_ = name;
		_tmp30_ = attr_name;
		_tmp31_ = attr_value;
		_tmp32_ = submarine_subtitulos_es_server_find_node (self, _tmp28_, _tmp29_, _tmp30_, _tmp31_, NULL, FALSE);
		rv = _tmp32_;
		_tmp33_ = rv;
		if (_tmp33_ != NULL) {
			xmlNode* _tmp34_ = NULL;
			_tmp34_ = rv;
			result = _tmp34_;
			return result;
		}
	}
	result = NULL;
	return result;
}


static gchar* submarine_subtitulos_es_server_get_inner_text (SubmarineSubtitulosESServer* self, xmlNode* c_node) {
	gchar* result = NULL;
	xmlNode* _tmp0_ = NULL;
	gchar* content = NULL;
	gchar* _tmp2_ = NULL;
	xmlNode* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp9_ = NULL;
	xmlNode* _tmp10_ = NULL;
	xmlNode* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	xmlNode* _tmp14_ = NULL;
	xmlNode* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = c_node;
	if (_tmp0_ == NULL) {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_strdup ("");
		result = _tmp1_;
		return result;
	}
	_tmp2_ = g_strdup ("");
	content = _tmp2_;
	_tmp3_ = c_node;
	_tmp4_ = _tmp3_->content;
	if (_tmp4_ != NULL) {
		const gchar* _tmp5_ = NULL;
		xmlNode* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		_tmp5_ = content;
		_tmp6_ = c_node;
		_tmp7_ = _tmp6_->content;
		_tmp8_ = g_strconcat (_tmp5_, _tmp7_, NULL);
		_g_free0 (content);
		content = _tmp8_;
	}
	_tmp9_ = content;
	_tmp10_ = c_node;
	_tmp11_ = _tmp10_->children;
	_tmp12_ = submarine_subtitulos_es_server_get_inner_text (self, _tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = c_node;
	_tmp15_ = _tmp14_->next;
	_tmp16_ = submarine_subtitulos_es_server_get_inner_text (self, _tmp15_);
	_tmp17_ = _tmp16_;
	_tmp18_ = g_strconcat (_tmp13_, _tmp17_, NULL);
	_tmp19_ = _tmp18_;
	_tmp20_ = g_strconcat (_tmp9_, _tmp19_, NULL);
	_g_free0 (content);
	content = _tmp20_;
	_g_free0 (_tmp19_);
	_g_free0 (_tmp17_);
	_g_free0 (_tmp13_);
	result = content;
	return result;
}


static gint string_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch10_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) (-1), 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch10_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally10;
	__catch10_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally10:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static GeeSet* submarine_subtitulos_es_server_real_search (SubmarineSubtitleServer* base, GFile* file, GeeCollection* languages) {
	SubmarineSubtitulosESServer * self;
	GeeSet* result = NULL;
	GeeHashSet* subtitles_downloaded = NULL;
	GeeHashSet* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	SubmarineNameParser* parser = NULL;
	GFile* _tmp3_ = NULL;
	SubmarineNameParser* _tmp4_ = NULL;
	SubmarineNameParser* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* title = NULL;
	gchar* title_full = NULL;
	gchar* seasons = NULL;
	gboolean found = FALSE;
	SubmarineNameParser* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	gboolean _tmp18_ = FALSE;
	SubmarineNameParser* _tmp19_ = NULL;
	gint _tmp20_ = 0;
	FILE* _tmp34_ = NULL;
	const gchar* _tmp35_ = NULL;
	SoupMessage* message = NULL;
	const gchar* _tmp36_ = NULL;
	gchar* _tmp37_ = NULL;
	gchar* _tmp38_ = NULL;
	SoupMessage* _tmp39_ = NULL;
	SoupMessage* _tmp40_ = NULL;
	SoupMessage* _tmp41_ = NULL;
	SoupMessageHeaders* _tmp42_ = NULL;
	guint status_code = 0U;
	SoupSessionSync* _tmp43_ = NULL;
	SoupMessage* _tmp44_ = NULL;
	guint _tmp45_ = 0U;
	guint _tmp46_ = 0U;
	gchar* rv = NULL;
	SoupMessage* _tmp47_ = NULL;
	SoupMessageBody* _tmp48_ = NULL;
	guint8* _tmp49_ = NULL;
	gint _tmp49__length1 = 0;
	gchar* _tmp50_ = NULL;
	xmlDoc* htmlparser = NULL;
	const gchar* _tmp51_ = NULL;
	xmlDoc* _tmp52_ = NULL;
	xmlNode* c_node = NULL;
	xmlDoc* _tmp53_ = NULL;
	xmlNode* _tmp54_ = NULL;
	xmlNode* top_tree = NULL;
	xmlNode* _tmp55_ = NULL;
	xmlNode* _tmp56_ = NULL;
	xmlNode* _tmp57_ = NULL;
	xmlNode* last_node = NULL;
	GeeArrayList* uris = NULL;
	GeeArrayList* _tmp58_ = NULL;
	gboolean _tmp103_ = FALSE;
	self = (SubmarineSubtitulosESServer*) base;
	g_return_val_if_fail (file != NULL, NULL);
	g_return_val_if_fail (languages != NULL, NULL);
	_tmp0_ = gee_hash_set_new (SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_downloaded = _tmp0_;
	_tmp1_ = file;
	_tmp2_ = g_file_get_path (_tmp1_);
	_g_free0 (self->priv->filepath);
	self->priv->filepath = _tmp2_;
	_tmp3_ = file;
	_tmp4_ = submarine_name_parser_new (_tmp3_);
	parser = _tmp4_;
	_tmp5_ = parser;
	_tmp6_ = _tmp5_->title;
	if (_tmp6_ == NULL) {
		FILE* _tmp7_ = NULL;
		_tmp7_ = stdout;
		fprintf (_tmp7_, "Subtitulos.es: Can't determine the serie/movie title\n");
		result = (GeeSet*) subtitles_downloaded;
		_submarine_name_parser_unref0 (parser);
		return result;
	}
	found = FALSE;
	_tmp8_ = parser;
	_tmp9_ = _tmp8_->year;
	if (_tmp9_ != (-1)) {
		SubmarineNameParser* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		SubmarineNameParser* _tmp12_ = NULL;
		gint _tmp13_ = 0;
		gchar* _tmp14_ = NULL;
		_tmp10_ = parser;
		_tmp11_ = _tmp10_->title;
		_tmp12_ = parser;
		_tmp13_ = _tmp12_->year;
		_tmp14_ = g_strdup_printf ("%s (%d)", _tmp11_, _tmp13_);
		_g_free0 (title);
		title = _tmp14_;
	} else {
		SubmarineNameParser* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		_tmp15_ = parser;
		_tmp16_ = _tmp15_->title;
		_tmp17_ = g_strdup_printf ("%s", _tmp16_);
		_g_free0 (title);
		title = _tmp17_;
	}
	_tmp19_ = parser;
	_tmp20_ = _tmp19_->season;
	if (_tmp20_ != (-1)) {
		SubmarineNameParser* _tmp21_ = NULL;
		gint _tmp22_ = 0;
		_tmp21_ = parser;
		_tmp22_ = _tmp21_->chapter;
		_tmp18_ = _tmp22_ != (-1);
	} else {
		_tmp18_ = FALSE;
	}
	if (_tmp18_) {
		SubmarineNameParser* _tmp23_ = NULL;
		gint _tmp24_ = 0;
		SubmarineNameParser* _tmp25_ = NULL;
		gint _tmp26_ = 0;
		gchar* _tmp27_ = NULL;
		const gchar* _tmp28_ = NULL;
		const gchar* _tmp29_ = NULL;
		gchar* _tmp30_ = NULL;
		_tmp23_ = parser;
		_tmp24_ = _tmp23_->season;
		_tmp25_ = parser;
		_tmp26_ = _tmp25_->chapter;
		_tmp27_ = g_strdup_printf ("%dx%02d", _tmp24_, _tmp26_);
		_g_free0 (seasons);
		seasons = _tmp27_;
		_tmp28_ = title;
		_tmp29_ = seasons;
		_tmp30_ = g_strdup_printf ("%s %s", _tmp28_, _tmp29_);
		_g_free0 (title_full);
		title_full = _tmp30_;
	} else {
		gchar* _tmp31_ = NULL;
		const gchar* _tmp32_ = NULL;
		gchar* _tmp33_ = NULL;
		_tmp31_ = g_strdup ("");
		_g_free0 (seasons);
		seasons = _tmp31_;
		_tmp32_ = title;
		_tmp33_ = g_strdup (_tmp32_);
		_g_free0 (title_full);
		title_full = _tmp33_;
	}
	_tmp34_ = stdout;
	_tmp35_ = title_full;
	fprintf (_tmp34_, "Subtitulos.es: searching for %s\n", _tmp35_);
	_tmp36_ = title_full;
	_tmp37_ = g_strconcat (_tmp36_, " site:www.subtitulos.es", NULL);
	_tmp38_ = _tmp37_;
	_tmp39_ = soup_form_request_new ("GET", SUBMARINE_SUBTITULOS_ES_SERVER_MAIN_URI, "q", _tmp38_, NULL);
	_tmp40_ = _tmp39_;
	_g_free0 (_tmp38_);
	message = _tmp40_;
	_tmp41_ = message;
	_tmp42_ = _tmp41_->request_headers;
	soup_message_headers_append (_tmp42_, "User-Agent", SUBMARINE_SUBTITULOS_ES_SERVER_USER_AGENT);
	_tmp43_ = self->priv->session;
	_tmp44_ = message;
	_tmp45_ = soup_session_send_message ((SoupSession*) _tmp43_, _tmp44_);
	status_code = _tmp45_;
	_tmp46_ = status_code;
	if (_tmp46_ != ((guint) 200)) {
		result = (GeeSet*) subtitles_downloaded;
		_g_object_unref0 (message);
		_g_free0 (seasons);
		_g_free0 (title_full);
		_g_free0 (title);
		_submarine_name_parser_unref0 (parser);
		return result;
	}
	_tmp47_ = message;
	_tmp48_ = _tmp47_->response_body;
	_tmp49_ = _tmp48_->data;
	_tmp49__length1 = (gint) _tmp48_->length;
	_tmp50_ = g_strdup ((const gchar*) _tmp49_);
	rv = _tmp50_;
	_tmp51_ = rv;
	_tmp52_ = htmlReadDoc ((xmlChar*) _tmp51_, "", NULL, 0);
	htmlparser = _tmp52_;
	_tmp53_ = htmlparser;
	_tmp54_ = xmlDocGetRootElement (_tmp53_);
	c_node = _tmp54_;
	_tmp55_ = c_node;
	_tmp56_ = submarine_subtitulos_es_server_find_node (self, _tmp55_, "div", "id", "links", NULL, TRUE);
	top_tree = _tmp56_;
	_tmp57_ = top_tree;
	if (_tmp57_ == NULL) {
		result = (GeeSet*) subtitles_downloaded;
		_g_free0 (rv);
		_g_object_unref0 (message);
		_g_free0 (seasons);
		_g_free0 (title_full);
		_g_free0 (title);
		_submarine_name_parser_unref0 (parser);
		return result;
	}
	last_node = NULL;
	_tmp58_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	uris = _tmp58_;
	while (TRUE) {
		xmlNode* current_node = NULL;
		xmlNode* _tmp59_ = NULL;
		xmlNode* _tmp60_ = NULL;
		xmlNode* _tmp61_ = NULL;
		xmlNode* _tmp62_ = NULL;
		xmlNode* _tmp63_ = NULL;
		xmlNode* link_node = NULL;
		xmlNode* _tmp64_ = NULL;
		xmlNode* _tmp65_ = NULL;
		xmlNode* _tmp66_ = NULL;
		xmlNode* text_node = NULL;
		xmlNode* _tmp67_ = NULL;
		xmlNode* _tmp68_ = NULL;
		gchar* link_description = NULL;
		xmlNode* _tmp69_ = NULL;
		gchar* _tmp70_ = NULL;
		gchar* link_uri = NULL;
		xmlNode* _tmp71_ = NULL;
		gchar* _tmp72_ = NULL;
		const gchar* _tmp73_ = NULL;
		gint _tmp74_ = 0;
		const gchar* _tmp75_ = NULL;
		const gchar* _tmp76_ = NULL;
		gint _tmp77_ = 0;
		gboolean _tmp78_ = FALSE;
		const gchar* _tmp79_ = NULL;
		GeeArrayList* _tmp83_ = NULL;
		const gchar* _tmp84_ = NULL;
		gboolean _tmp85_ = FALSE;
		_tmp59_ = top_tree;
		_tmp60_ = last_node;
		_tmp61_ = submarine_subtitulos_es_server_find_node (self, _tmp59_, "div", "class", "links_main links_deep", _tmp60_, TRUE);
		current_node = _tmp61_;
		_tmp62_ = current_node;
		if (_tmp62_ == NULL) {
			break;
		}
		_tmp63_ = current_node;
		last_node = _tmp63_;
		_tmp64_ = current_node;
		_tmp65_ = submarine_subtitulos_es_server_find_node (self, _tmp64_, "a", "href", "", NULL, TRUE);
		link_node = _tmp65_;
		_tmp66_ = link_node;
		if (_tmp66_ == NULL) {
			continue;
		}
		_tmp67_ = link_node;
		_tmp68_ = _tmp67_->children;
		text_node = _tmp68_;
		_tmp69_ = text_node;
		_tmp70_ = submarine_subtitulos_es_server_get_inner_text (self, _tmp69_);
		link_description = _tmp70_;
		_tmp71_ = link_node;
		_tmp72_ = (gchar*) xmlGetProp (_tmp71_, (xmlChar*) "href");
		link_uri = _tmp72_;
		_tmp73_ = link_uri;
		_tmp74_ = string_index_of (_tmp73_, "http://www.subtitulos.es", 0);
		if (0 != _tmp74_) {
			_g_free0 (link_uri);
			_g_free0 (link_description);
			continue;
		}
		_tmp75_ = link_description;
		_tmp76_ = title;
		_tmp77_ = string_index_of (_tmp75_, _tmp76_, 0);
		if ((-1) == _tmp77_) {
			_g_free0 (link_uri);
			_g_free0 (link_description);
			continue;
		}
		_tmp79_ = seasons;
		if (g_strcmp0 (_tmp79_, "") != 0) {
			const gchar* _tmp80_ = NULL;
			const gchar* _tmp81_ = NULL;
			gint _tmp82_ = 0;
			_tmp80_ = link_description;
			_tmp81_ = seasons;
			_tmp82_ = string_index_of (_tmp80_, _tmp81_, 0);
			_tmp78_ = (-1) == _tmp82_;
		} else {
			_tmp78_ = FALSE;
		}
		if (_tmp78_) {
			_g_free0 (link_uri);
			_g_free0 (link_description);
			continue;
		}
		_tmp83_ = uris;
		_tmp84_ = link_uri;
		_tmp85_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp83_, _tmp84_);
		if (FALSE == _tmp85_) {
			GeeArrayList* _tmp86_ = NULL;
			const gchar* _tmp87_ = NULL;
			_tmp86_ = uris;
			_tmp87_ = link_uri;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp86_, _tmp87_);
		}
		_g_free0 (link_uri);
		_g_free0 (link_description);
	}
	{
		GeeArrayList* _uri_list = NULL;
		GeeArrayList* _tmp88_ = NULL;
		GeeArrayList* _tmp89_ = NULL;
		gint _uri_size = 0;
		GeeArrayList* _tmp90_ = NULL;
		gint _tmp91_ = 0;
		gint _tmp92_ = 0;
		gint _uri_index = 0;
		_tmp88_ = uris;
		_tmp89_ = _g_object_ref0 (_tmp88_);
		_uri_list = _tmp89_;
		_tmp90_ = _uri_list;
		_tmp91_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp90_);
		_tmp92_ = _tmp91_;
		_uri_size = _tmp92_;
		_uri_index = -1;
		while (TRUE) {
			gint _tmp93_ = 0;
			gint _tmp94_ = 0;
			gint _tmp95_ = 0;
			gchar* uri = NULL;
			GeeArrayList* _tmp96_ = NULL;
			gint _tmp97_ = 0;
			gpointer _tmp98_ = NULL;
			const gchar* _tmp99_ = NULL;
			GeeCollection* _tmp100_ = NULL;
			GeeHashSet* _tmp101_ = NULL;
			gboolean _tmp102_ = FALSE;
			_tmp93_ = _uri_index;
			_uri_index = _tmp93_ + 1;
			_tmp94_ = _uri_index;
			_tmp95_ = _uri_size;
			if (!(_tmp94_ < _tmp95_)) {
				break;
			}
			_tmp96_ = _uri_list;
			_tmp97_ = _uri_index;
			_tmp98_ = gee_abstract_list_get ((GeeAbstractList*) _tmp96_, _tmp97_);
			uri = (gchar*) _tmp98_;
			_tmp99_ = uri;
			_tmp100_ = languages;
			_tmp101_ = subtitles_downloaded;
			_tmp102_ = submarine_subtitulos_es_server_extract_subtitles (self, _tmp99_, _tmp100_, (GeeSet*) _tmp101_, 8.0);
			if (_tmp102_) {
				found = TRUE;
			}
			_g_free0 (uri);
		}
		_g_object_unref0 (_uri_list);
	}
	_tmp103_ = found;
	if (_tmp103_ == FALSE) {
		gchar* uri = NULL;
		const gchar* _tmp104_ = NULL;
		gchar* _tmp105_ = NULL;
		gchar* _tmp106_ = NULL;
		gchar* _tmp107_ = NULL;
		gchar* _tmp108_ = NULL;
		gchar* _tmp109_ = NULL;
		gchar* _tmp110_ = NULL;
		const gchar* _tmp111_ = NULL;
		gchar* _tmp112_ = NULL;
		gchar* _tmp113_ = NULL;
		const gchar* _tmp114_ = NULL;
		GeeCollection* _tmp115_ = NULL;
		GeeHashSet* _tmp116_ = NULL;
		_tmp104_ = title;
		_tmp105_ = string_replace (_tmp104_, " ", "-");
		_tmp106_ = _tmp105_;
		_tmp107_ = g_strconcat (SUBMARINE_SUBTITULOS_ES_SERVER_SECD_URI "/", _tmp106_, NULL);
		_tmp108_ = _tmp107_;
		_tmp109_ = g_strconcat (_tmp108_, "/", NULL);
		_tmp110_ = _tmp109_;
		_tmp111_ = seasons;
		_tmp112_ = g_strconcat (_tmp110_, _tmp111_, NULL);
		_tmp113_ = _tmp112_;
		_g_free0 (_tmp110_);
		_g_free0 (_tmp108_);
		_g_free0 (_tmp106_);
		uri = _tmp113_;
		_tmp114_ = uri;
		_tmp115_ = languages;
		_tmp116_ = subtitles_downloaded;
		submarine_subtitulos_es_server_extract_subtitles (self, _tmp114_, _tmp115_, (GeeSet*) _tmp116_, 7.0);
		_g_free0 (uri);
	}
	result = (GeeSet*) subtitles_downloaded;
	_g_object_unref0 (uris);
	_g_free0 (rv);
	_g_object_unref0 (message);
	_g_free0 (seasons);
	_g_free0 (title_full);
	_g_free0 (title);
	_submarine_name_parser_unref0 (parser);
	return result;
}


static gboolean submarine_subtitulos_es_server_extract_subtitles (SubmarineSubtitulosESServer* self, const gchar* uri, GeeCollection* languages, GeeSet* subtitles_downloaded, gdouble rating) {
	gboolean result = FALSE;
	SoupMessage* message = NULL;
	const gchar* _tmp0_ = NULL;
	SoupMessage* _tmp1_ = NULL;
	SoupMessage* _tmp2_ = NULL;
	SoupMessageHeaders* _tmp3_ = NULL;
	guint status_code = 0U;
	SoupSessionSync* _tmp4_ = NULL;
	SoupMessage* _tmp5_ = NULL;
	guint _tmp6_ = 0U;
	guint _tmp7_ = 0U;
	gchar* rv = NULL;
	SoupMessage* _tmp8_ = NULL;
	SoupMessageBody* _tmp9_ = NULL;
	guint8* _tmp10_ = NULL;
	gint _tmp10__length1 = 0;
	gchar* _tmp11_ = NULL;
	xmlDoc* htmlparser = NULL;
	const gchar* _tmp12_ = NULL;
	xmlDoc* _tmp13_ = NULL;
	xmlNode* c_node = NULL;
	xmlDoc* _tmp14_ = NULL;
	xmlNode* _tmp15_ = NULL;
	xmlNode* top_tree = NULL;
	xmlNode* _tmp16_ = NULL;
	xmlNode* _tmp17_ = NULL;
	xmlNode* _tmp18_ = NULL;
	xmlNode* _tmp19_ = NULL;
	xmlNode* _tmp20_ = NULL;
	xmlNode* _tmp21_ = NULL;
	xmlNode* _tmp22_ = NULL;
	gboolean found = FALSE;
	xmlNode* last_node = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (uri != NULL, FALSE);
	g_return_val_if_fail (languages != NULL, FALSE);
	g_return_val_if_fail (subtitles_downloaded != NULL, FALSE);
	_tmp0_ = uri;
	_tmp1_ = soup_form_request_new ("GET", _tmp0_, NULL);
	message = _tmp1_;
	_tmp2_ = message;
	_tmp3_ = _tmp2_->request_headers;
	soup_message_headers_append (_tmp3_, "User-Agent", SUBMARINE_SUBTITULOS_ES_SERVER_USER_AGENT);
	_tmp4_ = self->priv->session;
	_tmp5_ = message;
	_tmp6_ = soup_session_send_message ((SoupSession*) _tmp4_, _tmp5_);
	status_code = _tmp6_;
	_tmp7_ = status_code;
	if (_tmp7_ != ((guint) 200)) {
		result = FALSE;
		_g_object_unref0 (message);
		return result;
	}
	_tmp8_ = message;
	_tmp9_ = _tmp8_->response_body;
	_tmp10_ = _tmp9_->data;
	_tmp10__length1 = (gint) _tmp9_->length;
	_tmp11_ = g_strdup ((const gchar*) _tmp10_);
	rv = _tmp11_;
	_tmp12_ = rv;
	_tmp13_ = htmlReadDoc ((xmlChar*) _tmp12_, "", NULL, 0);
	htmlparser = _tmp13_;
	_tmp14_ = htmlparser;
	_tmp15_ = xmlDocGetRootElement (_tmp14_);
	c_node = _tmp15_;
	_tmp16_ = c_node;
	_tmp17_ = submarine_subtitulos_es_server_find_node (self, _tmp16_, "div", "id", "content", NULL, TRUE);
	top_tree = _tmp17_;
	_tmp18_ = top_tree;
	if (_tmp18_ == NULL) {
		result = FALSE;
		_g_free0 (rv);
		_g_object_unref0 (message);
		return result;
	}
	_tmp19_ = c_node;
	_tmp20_ = top_tree;
	_tmp21_ = submarine_subtitulos_es_server_find_node (self, _tmp19_, "div", "id", "version", _tmp20_, TRUE);
	top_tree = _tmp21_;
	_tmp22_ = top_tree;
	if (_tmp22_ == NULL) {
		result = FALSE;
		_g_free0 (rv);
		_g_object_unref0 (message);
		return result;
	}
	found = FALSE;
	last_node = NULL;
	while (TRUE) {
		xmlNode* current_node = NULL;
		xmlNode* _tmp23_ = NULL;
		xmlNode* _tmp24_ = NULL;
		xmlNode* _tmp25_ = NULL;
		xmlNode* _tmp26_ = NULL;
		xmlNode* _tmp27_ = NULL;
		gchar* lengua = NULL;
		xmlNode* _tmp28_ = NULL;
		xmlNode* _tmp29_ = NULL;
		gchar* _tmp30_ = NULL;
		gchar* _tmp31_ = NULL;
		gchar* _tmp32_ = NULL;
		gchar* _tmp33_ = NULL;
		gchar* _tmp34_ = NULL;
		gchar* _tmp35_ = NULL;
		gchar* _tmp36_ = NULL;
		gchar* _tmp37_ = NULL;
		gchar* _tmp38_ = NULL;
		gchar* _tmp39_ = NULL;
		gchar* current_language = NULL;
		gchar* _tmp40_ = NULL;
		const gchar* _tmp41_ = NULL;
		const gchar* _tmp42_ = NULL;
		GQuark _tmp44_ = 0U;
		static GQuark _tmp43_label0 = 0;
		static GQuark _tmp43_label1 = 0;
		static GQuark _tmp43_label2 = 0;
		static GQuark _tmp43_label3 = 0;
		static GQuark _tmp43_label4 = 0;
		static GQuark _tmp43_label5 = 0;
		static GQuark _tmp43_label6 = 0;
		static GQuark _tmp43_label7 = 0;
		const gchar* _tmp51_ = NULL;
		xmlNode* first_span = NULL;
		xmlNode* _tmp52_ = NULL;
		xmlNode* _tmp53_ = NULL;
		xmlNode* _tmp54_ = NULL;
		xmlNode* _tmp55_ = NULL;
		xmlNode* uri_link = NULL;
		xmlNode* _tmp56_ = NULL;
		xmlNode* _tmp57_ = NULL;
		xmlNode* _tmp58_ = NULL;
		_tmp23_ = top_tree;
		_tmp24_ = last_node;
		_tmp25_ = submarine_subtitulos_es_server_find_node (self, _tmp23_, "li", "class", "li-idioma", _tmp24_, TRUE);
		current_node = _tmp25_;
		_tmp26_ = current_node;
		if (_tmp26_ == NULL) {
			break;
		}
		_tmp27_ = current_node;
		last_node = _tmp27_;
		_tmp28_ = current_node;
		_tmp29_ = _tmp28_->children;
		_tmp30_ = submarine_subtitulos_es_server_get_inner_text (self, _tmp29_);
		_tmp31_ = _tmp30_;
		_tmp32_ = string_replace (_tmp31_, " ", "");
		_tmp33_ = _tmp32_;
		_tmp34_ = string_replace (_tmp33_, "\n", "");
		_tmp35_ = _tmp34_;
		_tmp36_ = string_replace (_tmp35_, "\r", "");
		_tmp37_ = _tmp36_;
		_tmp38_ = string_replace (_tmp37_, "\t", "");
		_tmp39_ = _tmp38_;
		_g_free0 (_tmp37_);
		_g_free0 (_tmp35_);
		_g_free0 (_tmp33_);
		_g_free0 (_tmp31_);
		lengua = _tmp39_;
		_tmp40_ = g_strdup ("");
		current_language = _tmp40_;
		_tmp41_ = lengua;
		_tmp42_ = _tmp41_;
		_tmp44_ = (NULL == _tmp42_) ? 0 : g_quark_from_string (_tmp42_);
		if (((_tmp44_ == ((0 != _tmp43_label0) ? _tmp43_label0 : (_tmp43_label0 = g_quark_from_static_string ("Español")))) || (_tmp44_ == ((0 != _tmp43_label1) ? _tmp43_label1 : (_tmp43_label1 = g_quark_from_static_string ("Español(España)"))))) || (_tmp44_ == ((0 != _tmp43_label2) ? _tmp43_label2 : (_tmp43_label2 = g_quark_from_static_string ("Español(Latinoamérica)"))))) {
			switch (0) {
				default:
				{
					gchar* _tmp45_ = NULL;
					_tmp45_ = g_strdup ("spa");
					_g_free0 (current_language);
					current_language = _tmp45_;
					break;
				}
			}
		} else if (_tmp44_ == ((0 != _tmp43_label3) ? _tmp43_label3 : (_tmp43_label3 = g_quark_from_static_string ("English")))) {
			switch (0) {
				default:
				{
					gchar* _tmp46_ = NULL;
					_tmp46_ = g_strdup ("eng");
					_g_free0 (current_language);
					current_language = _tmp46_;
					break;
				}
			}
		} else if (_tmp44_ == ((0 != _tmp43_label4) ? _tmp43_label4 : (_tmp43_label4 = g_quark_from_static_string ("Català")))) {
			switch (0) {
				default:
				{
					gchar* _tmp47_ = NULL;
					_tmp47_ = g_strdup ("cat");
					_g_free0 (current_language);
					current_language = _tmp47_;
					break;
				}
			}
		} else if (_tmp44_ == ((0 != _tmp43_label5) ? _tmp43_label5 : (_tmp43_label5 = g_quark_from_static_string ("Galego")))) {
			switch (0) {
				default:
				{
					gchar* _tmp48_ = NULL;
					_tmp48_ = g_strdup ("glg");
					_g_free0 (current_language);
					current_language = _tmp48_;
					break;
				}
			}
		} else if (_tmp44_ == ((0 != _tmp43_label6) ? _tmp43_label6 : (_tmp43_label6 = g_quark_from_static_string ("Portuguese")))) {
			switch (0) {
				default:
				{
					gchar* _tmp49_ = NULL;
					_tmp49_ = g_strdup ("por");
					_g_free0 (current_language);
					current_language = _tmp49_;
					break;
				}
			}
		} else if (_tmp44_ == ((0 != _tmp43_label7) ? _tmp43_label7 : (_tmp43_label7 = g_quark_from_static_string ("Euskera")))) {
			switch (0) {
				default:
				{
					gchar* _tmp50_ = NULL;
					_tmp50_ = g_strdup ("baq");
					_g_free0 (current_language);
					current_language = _tmp50_;
					break;
				}
			}
		}
		_tmp51_ = current_language;
		if (g_strcmp0 (_tmp51_, "") == 0) {
			_g_free0 (current_language);
			_g_free0 (lengua);
			continue;
		}
		_tmp52_ = top_tree;
		_tmp53_ = last_node;
		_tmp54_ = submarine_subtitulos_es_server_find_node (self, _tmp52_, "span", "", "", _tmp53_, TRUE);
		first_span = _tmp54_;
		_tmp55_ = first_span;
		if (_tmp55_ == NULL) {
			_g_free0 (current_language);
			_g_free0 (lengua);
			continue;
		}
		_tmp56_ = first_span;
		_tmp57_ = submarine_subtitulos_es_server_find_node (self, _tmp56_, "a", "href", "", NULL, TRUE);
		uri_link = _tmp57_;
		_tmp58_ = uri_link;
		if (_tmp58_ == NULL) {
			_g_free0 (current_language);
			_g_free0 (lengua);
			continue;
		}
		{
			GeeIterator* _language_it = NULL;
			GeeCollection* _tmp59_ = NULL;
			GeeIterator* _tmp60_ = NULL;
			_tmp59_ = languages;
			_tmp60_ = gee_iterable_iterator ((GeeIterable*) _tmp59_);
			_language_it = _tmp60_;
			while (TRUE) {
				GeeIterator* _tmp61_ = NULL;
				gboolean _tmp62_ = FALSE;
				gchar* language = NULL;
				GeeIterator* _tmp63_ = NULL;
				gpointer _tmp64_ = NULL;
				const gchar* _tmp65_ = NULL;
				gint _tmp66_ = 0;
				gint _tmp67_ = 0;
				const gchar* _tmp70_ = NULL;
				const gchar* _tmp71_ = NULL;
				_tmp61_ = _language_it;
				_tmp62_ = gee_iterator_next (_tmp61_);
				if (!_tmp62_) {
					break;
				}
				_tmp63_ = _language_it;
				_tmp64_ = gee_iterator_get (_tmp63_);
				language = (gchar*) _tmp64_;
				_tmp65_ = language;
				_tmp66_ = strlen (_tmp65_);
				_tmp67_ = _tmp66_;
				if (_tmp67_ == 2) {
					const gchar* _tmp68_ = NULL;
					gchar* _tmp69_ = NULL;
					_tmp68_ = language;
					_tmp69_ = submarine_get_alternate (_tmp68_);
					_g_free0 (language);
					language = _tmp69_;
				}
				_tmp70_ = language;
				_tmp71_ = current_language;
				if (g_strcmp0 (_tmp70_, _tmp71_) == 0) {
					GValue v = {0};
					xmlNode* _tmp72_ = NULL;
					gchar* _tmp73_ = NULL;
					GValue _tmp74_ = {0};
					SubmarineSubtitle* subtitle = NULL;
					SubmarineServerInfo _tmp75_ = {0};
					SubmarineServerInfo _tmp76_ = {0};
					GValue _tmp77_ = {0};
					SubmarineSubtitle* _tmp78_ = NULL;
					SubmarineSubtitle* _tmp79_ = NULL;
					const gchar* _tmp80_ = NULL;
					SubmarineSubtitle* _tmp81_ = NULL;
					const gchar* _tmp82_ = NULL;
					SubmarineSubtitle* _tmp83_ = NULL;
					gdouble _tmp84_ = 0.0;
					GeeSet* _tmp85_ = NULL;
					SubmarineSubtitle* _tmp86_ = NULL;
					_tmp72_ = uri_link;
					_tmp73_ = (gchar*) xmlGetProp (_tmp72_, (xmlChar*) "href");
					g_value_init (&_tmp74_, G_TYPE_STRING);
					g_value_take_string (&_tmp74_, _tmp73_);
					v = _tmp74_;
					submarine_subtitle_server_get_info ((SubmarineSubtitleServer*) self, &_tmp75_);
					_tmp76_ = _tmp75_;
					_tmp77_ = v;
					_tmp78_ = submarine_subtitle_new (&_tmp76_, &_tmp77_);
					subtitle = _tmp78_;
					_tmp79_ = subtitle;
					_tmp80_ = language;
					submarine_subtitle_set_language (_tmp79_, _tmp80_);
					_tmp81_ = subtitle;
					_tmp82_ = uri;
					submarine_subtitle_set_data (_tmp81_, _tmp82_);
					_tmp83_ = subtitle;
					_tmp84_ = rating;
					submarine_subtitle_set_rating (_tmp83_, _tmp84_);
					_tmp85_ = subtitles_downloaded;
					_tmp86_ = subtitle;
					gee_collection_add ((GeeCollection*) _tmp85_, _tmp86_);
					found = TRUE;
					_submarine_subtitle_unref0 (subtitle);
					G_IS_VALUE (&v) ? (g_value_unset (&v), NULL) : NULL;
					_g_free0 (language);
					break;
				}
				_g_free0 (language);
			}
			_g_object_unref0 (_language_it);
		}
		_g_free0 (current_language);
		_g_free0 (lengua);
	}
	result = found;
	_g_free0 (rv);
	_g_object_unref0 (message);
	return result;
}


static SoupMessageHeaders* _vala_SoupMessageHeaders_copy (SoupMessageHeaders* self) {
	return g_boxed_copy (soup_message_headers_get_type (), self);
}


static gpointer __vala_SoupMessageHeaders_copy0 (gpointer self) {
	return self ? _vala_SoupMessageHeaders_copy (self) : NULL;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


static gint string_last_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gpointer _submarine_subtitle_ref0 (gpointer self) {
	return self ? submarine_subtitle_ref (self) : NULL;
}


static void _vala_SoupMessageHeaders_free (SoupMessageHeaders* self) {
	g_boxed_free (soup_message_headers_get_type (), self);
}


static SubmarineSubtitle* submarine_subtitulos_es_server_real_download (SubmarineSubtitleServer* base, SubmarineSubtitle* subtitle) {
	SubmarineSubtitulosESServer * self;
	SubmarineSubtitle* result = NULL;
	SoupMessage* message = NULL;
	SubmarineSubtitle* _tmp0_ = NULL;
	GValue _tmp1_ = {0};
	GValue _tmp2_ = {0};
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	SoupMessage* _tmp6_ = NULL;
	SoupMessage* _tmp7_ = NULL;
	SoupMessage* _tmp8_ = NULL;
	SoupMessageHeaders* _tmp9_ = NULL;
	SubmarineSubtitle* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	guint status_code = 0U;
	SoupSessionSync* _tmp18_ = NULL;
	SoupMessage* _tmp19_ = NULL;
	guint _tmp20_ = 0U;
	guint _tmp21_ = 0U;
	self = (SubmarineSubtitulosESServer*) base;
	g_return_val_if_fail (subtitle != NULL, NULL);
	_tmp0_ = subtitle;
	submarine_subtitle_get_server_data (_tmp0_, &_tmp1_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_value_get_string (&_tmp2_);
	_tmp4_ = g_strdup_printf ("%s", _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = soup_message_new ("GET", _tmp5_);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	message = _tmp7_;
	_tmp8_ = message;
	_tmp9_ = _tmp8_->request_headers;
	soup_message_headers_append (_tmp9_, "User-Agent", SUBMARINE_SUBTITULOS_ES_SERVER_USER_AGENT);
	_tmp10_ = subtitle;
	_tmp11_ = submarine_subtitle_get_data (_tmp10_);
	_tmp12_ = _tmp11_;
	if (g_strcmp0 (_tmp12_, "") != 0) {
		SoupMessage* _tmp13_ = NULL;
		SoupMessageHeaders* _tmp14_ = NULL;
		SubmarineSubtitle* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		_tmp13_ = message;
		_tmp14_ = _tmp13_->request_headers;
		_tmp15_ = subtitle;
		_tmp16_ = submarine_subtitle_get_data (_tmp15_);
		_tmp17_ = _tmp16_;
		soup_message_headers_append (_tmp14_, "Referer", _tmp17_);
	}
	_tmp18_ = self->priv->session;
	_tmp19_ = message;
	_tmp20_ = soup_session_send_message ((SoupSession*) _tmp18_, _tmp19_);
	status_code = _tmp20_;
	_tmp21_ = status_code;
	if (_tmp21_ == ((guint) 200)) {
		SoupMessageHeaders* rsp = NULL;
		SoupMessage* _tmp22_ = NULL;
		SoupMessageHeaders* _tmp23_ = NULL;
		SoupMessageHeaders* _tmp24_ = NULL;
		gchar* type = NULL;
		gchar* _tmp25_ = NULL;
		gchar* cadena = NULL;
		GHashTable* params = NULL;
		SoupMessageHeaders* _tmp26_ = NULL;
		gchar* _tmp27_ = NULL;
		GHashTable* _tmp28_ = NULL;
		gboolean _tmp29_ = FALSE;
		gboolean _tmp43_ = FALSE;
		const gchar* _tmp44_ = NULL;
		gchar* _tmp45_ = NULL;
		gchar* _tmp46_ = NULL;
		gchar* _tmp47_ = NULL;
		gchar* _tmp48_ = NULL;
		gboolean _tmp49_ = FALSE;
		_tmp22_ = message;
		_tmp23_ = _tmp22_->response_headers;
		_tmp24_ = __vala_SoupMessageHeaders_copy0 (_tmp23_);
		rsp = _tmp24_;
		_tmp25_ = g_strdup ("");
		type = _tmp25_;
		_tmp26_ = rsp;
		_tmp29_ = soup_message_headers_get_content_disposition (_tmp26_, &_tmp27_, &_tmp28_);
		_g_free0 (cadena);
		cadena = _tmp27_;
		_g_hash_table_unref0 (params);
		params = _tmp28_;
		if (_tmp29_) {
			GList* lista = NULL;
			GHashTable* _tmp30_ = NULL;
			GList* _tmp31_ = NULL;
			GList* _tmp32_ = NULL;
			_tmp30_ = params;
			_tmp31_ = g_hash_table_get_keys (_tmp30_);
			lista = _tmp31_;
			_tmp32_ = lista;
			{
				GList* entrada_collection = NULL;
				GList* entrada_it = NULL;
				entrada_collection = _tmp32_;
				for (entrada_it = entrada_collection; entrada_it != NULL; entrada_it = entrada_it->next) {
					gchar* _tmp33_ = NULL;
					gchar* entrada = NULL;
					_tmp33_ = g_strdup ((const gchar*) entrada_it->data);
					entrada = _tmp33_;
					{
						const gchar* _tmp34_ = NULL;
						_tmp34_ = entrada;
						if (g_strcmp0 (_tmp34_, "filename") == 0) {
							gchar* valor = NULL;
							GHashTable* _tmp35_ = NULL;
							const gchar* _tmp36_ = NULL;
							gconstpointer _tmp37_ = NULL;
							gchar* _tmp38_ = NULL;
							const gchar* _tmp39_ = NULL;
							const gchar* _tmp40_ = NULL;
							gint _tmp41_ = 0;
							gchar* _tmp42_ = NULL;
							_tmp35_ = params;
							_tmp36_ = entrada;
							_tmp37_ = g_hash_table_lookup (_tmp35_, _tmp36_);
							_tmp38_ = g_strdup ((const gchar*) _tmp37_);
							valor = _tmp38_;
							_tmp39_ = valor;
							_tmp40_ = valor;
							_tmp41_ = string_last_index_of (_tmp40_, ".", 0);
							_tmp42_ = string_substring (_tmp39_, (glong) (_tmp41_ + 1), (glong) (-1));
							_g_free0 (type);
							type = _tmp42_;
							_g_free0 (valor);
						}
						_g_free0 (entrada);
					}
				}
			}
			_g_list_free0 (lista);
		}
		_tmp44_ = type;
		_tmp45_ = g_utf8_casefold (_tmp44_, (gssize) (-1));
		_tmp46_ = _tmp45_;
		_tmp47_ = g_utf8_casefold ("sub", (gssize) (-1));
		_tmp48_ = _tmp47_;
		_tmp49_ = g_strcmp0 (_tmp46_, _tmp48_) == 0;
		_g_free0 (_tmp48_);
		_g_free0 (_tmp46_);
		if (_tmp49_) {
			_tmp43_ = TRUE;
		} else {
			const gchar* _tmp50_ = NULL;
			gchar* _tmp51_ = NULL;
			gchar* _tmp52_ = NULL;
			gchar* _tmp53_ = NULL;
			gchar* _tmp54_ = NULL;
			_tmp50_ = type;
			_tmp51_ = g_utf8_casefold (_tmp50_, (gssize) (-1));
			_tmp52_ = _tmp51_;
			_tmp53_ = g_utf8_casefold ("srt", (gssize) (-1));
			_tmp54_ = _tmp53_;
			_tmp43_ = g_strcmp0 (_tmp52_, _tmp54_) == 0;
			_g_free0 (_tmp54_);
			_g_free0 (_tmp52_);
		}
		if (_tmp43_) {
			SubmarineSubtitle* _tmp55_ = NULL;
			const gchar* _tmp56_ = NULL;
			SubmarineSubtitle* _tmp57_ = NULL;
			SoupMessage* _tmp58_ = NULL;
			SoupMessageBody* _tmp59_ = NULL;
			guint8* _tmp60_ = NULL;
			gint _tmp60__length1 = 0;
			SubmarineSubtitle* _tmp61_ = NULL;
			SubmarineSubtitle* _tmp62_ = NULL;
			_tmp55_ = subtitle;
			_tmp56_ = type;
			submarine_subtitle_set_format (_tmp55_, _tmp56_);
			_tmp57_ = subtitle;
			_tmp58_ = message;
			_tmp59_ = _tmp58_->response_body;
			_tmp60_ = _tmp59_->data;
			_tmp60__length1 = (gint) _tmp59_->length;
			submarine_subtitle_set_data (_tmp57_, (const gchar*) _tmp60_);
			_tmp61_ = subtitle;
			_tmp62_ = _submarine_subtitle_ref0 (_tmp61_);
			result = _tmp62_;
			_g_hash_table_unref0 (params);
			_g_free0 (cadena);
			_g_free0 (type);
			__vala_SoupMessageHeaders_free0 (rsp);
			_g_object_unref0 (message);
			return result;
		} else {
			result = NULL;
			_g_hash_table_unref0 (params);
			_g_free0 (cadena);
			_g_free0 (type);
			__vala_SoupMessageHeaders_free0 (rsp);
			_g_object_unref0 (message);
			return result;
		}
		_g_hash_table_unref0 (params);
		_g_free0 (cadena);
		_g_free0 (type);
		__vala_SoupMessageHeaders_free0 (rsp);
	}
	result = NULL;
	_g_object_unref0 (message);
	return result;
}


SubmarineSubtitulosESServer* submarine_subtitulos_es_server_construct (GType object_type) {
	SubmarineSubtitulosESServer * self = NULL;
	self = (SubmarineSubtitulosESServer*) submarine_subtitle_server_construct (object_type);
	return self;
}


SubmarineSubtitulosESServer* submarine_subtitulos_es_server_new (void) {
	return submarine_subtitulos_es_server_construct (SUBMARINE_TYPE_SUBTITULOS_ES_SERVER);
}


static GObject * submarine_subtitulos_es_server_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SubmarineSubtitulosESServer * self;
	SubmarineServerInfo _tmp0_ = {0};
	SubmarineServerInfo _tmp1_ = {0};
	gchar* _tmp2_ = NULL;
	parent_class = G_OBJECT_CLASS (submarine_subtitulos_es_server_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_SUBTITULOS_ES_SERVER, SubmarineSubtitulosESServer);
	submarine_server_info_init (&_tmp0_, "Subtitulos.es", "http://www.subtitulos.es", "es");
	_tmp1_ = _tmp0_;
	submarine_subtitle_server_set_info ((SubmarineSubtitleServer*) self, &_tmp1_);
	submarine_server_info_destroy (&_tmp1_);
	_tmp2_ = g_strdup ("");
	_g_free0 (self->priv->filepath);
	self->priv->filepath = _tmp2_;
	return obj;
}


static void submarine_subtitulos_es_server_class_init (SubmarineSubtitulosESServerClass * klass) {
	submarine_subtitulos_es_server_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SubmarineSubtitulosESServerPrivate));
	((SubmarineSubtitleServerClass *) klass)->connect = submarine_subtitulos_es_server_real_connect;
	((SubmarineSubtitleServerClass *) klass)->disconnect = submarine_subtitulos_es_server_real_disconnect;
	((SubmarineSubtitleServerClass *) klass)->search = submarine_subtitulos_es_server_real_search;
	((SubmarineSubtitleServerClass *) klass)->download = submarine_subtitulos_es_server_real_download;
	G_OBJECT_CLASS (klass)->constructor = submarine_subtitulos_es_server_constructor;
	G_OBJECT_CLASS (klass)->finalize = submarine_subtitulos_es_server_finalize;
}


static void submarine_subtitulos_es_server_instance_init (SubmarineSubtitulosESServer * self) {
	self->priv = SUBMARINE_SUBTITULOS_ES_SERVER_GET_PRIVATE (self);
}


static void submarine_subtitulos_es_server_finalize (GObject* obj) {
	SubmarineSubtitulosESServer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SUBMARINE_TYPE_SUBTITULOS_ES_SERVER, SubmarineSubtitulosESServer);
	_g_object_unref0 (self->priv->session);
	_g_free0 (self->priv->filepath);
	G_OBJECT_CLASS (submarine_subtitulos_es_server_parent_class)->finalize (obj);
}


GType submarine_subtitulos_es_server_get_type (void) {
	static volatile gsize submarine_subtitulos_es_server_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_subtitulos_es_server_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineSubtitulosESServerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_subtitulos_es_server_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineSubtitulosESServer), 0, (GInstanceInitFunc) submarine_subtitulos_es_server_instance_init, NULL };
		GType submarine_subtitulos_es_server_type_id;
		submarine_subtitulos_es_server_type_id = g_type_register_static (SUBMARINE_TYPE_SUBTITLE_SERVER, "SubmarineSubtitulosESServer", &g_define_type_info, 0);
		g_once_init_leave (&submarine_subtitulos_es_server_type_id__volatile, submarine_subtitulos_es_server_type_id);
	}
	return submarine_subtitulos_es_server_type_id__volatile;
}



