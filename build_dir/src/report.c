/* report.c generated by valac 0.28.0, the Vala compiler
 * generated from report.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#define REPORT_TYPE_VERBOSITY (report_verbosity_get_type ())

typedef enum  {
	REPORT_VERBOSITY_NONE = 0,
	REPORT_VERBOSITY_DEFAULT = 1,
	REPORT_VERBOSITY_ALL = 2
} ReportVerbosity;


extern ReportVerbosity report_verbosity;
ReportVerbosity report_verbosity = REPORT_VERBOSITY_DEFAULT;

GType report_verbosity_get_type (void) G_GNUC_CONST;
void report_message (const gchar* message, gboolean newline, ReportVerbosity message_verbosity);
void report_warning (const gchar* message, gboolean newline, ReportVerbosity message_verbosity);
void report_error (const gchar* message, gint ret_value, gboolean newline);


GType report_verbosity_get_type (void) {
	static volatile gsize report_verbosity_type_id__volatile = 0;
	if (g_once_init_enter (&report_verbosity_type_id__volatile)) {
		static const GEnumValue values[] = {{REPORT_VERBOSITY_NONE, "REPORT_VERBOSITY_NONE", "none"}, {REPORT_VERBOSITY_DEFAULT, "REPORT_VERBOSITY_DEFAULT", "default"}, {REPORT_VERBOSITY_ALL, "REPORT_VERBOSITY_ALL", "all"}, {0, NULL, NULL}};
		GType report_verbosity_type_id;
		report_verbosity_type_id = g_enum_register_static ("ReportVerbosity", values);
		g_once_init_leave (&report_verbosity_type_id__volatile, report_verbosity_type_id);
	}
	return report_verbosity_type_id__volatile;
}


void report_message (const gchar* message, gboolean newline, ReportVerbosity message_verbosity) {
	gboolean _tmp0_ = FALSE;
	ReportVerbosity _tmp1_ = 0;
	g_return_if_fail (message != NULL);
	_tmp1_ = report_verbosity;
	if (_tmp1_ > REPORT_VERBOSITY_NONE) {
		ReportVerbosity _tmp2_ = 0;
		ReportVerbosity _tmp3_ = 0;
		_tmp2_ = message_verbosity;
		_tmp3_ = report_verbosity;
		_tmp0_ = _tmp2_ <= _tmp3_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gboolean _tmp4_ = FALSE;
		_tmp4_ = newline;
		if (_tmp4_) {
			FILE* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp5_ = stdout;
			_tmp6_ = message;
			fprintf (_tmp5_, "%s\n", _tmp6_);
		} else {
			FILE* _tmp7_ = NULL;
			const gchar* _tmp8_ = NULL;
			_tmp7_ = stdout;
			_tmp8_ = message;
			fprintf (_tmp7_, "%s", _tmp8_);
		}
	}
}


void report_warning (const gchar* message, gboolean newline, ReportVerbosity message_verbosity) {
	gboolean _tmp0_ = FALSE;
	ReportVerbosity _tmp1_ = 0;
	g_return_if_fail (message != NULL);
	_tmp1_ = report_verbosity;
	if (_tmp1_ > REPORT_VERBOSITY_NONE) {
		ReportVerbosity _tmp2_ = 0;
		ReportVerbosity _tmp3_ = 0;
		_tmp2_ = message_verbosity;
		_tmp3_ = report_verbosity;
		_tmp0_ = _tmp2_ <= _tmp3_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gboolean _tmp4_ = FALSE;
		_tmp4_ = newline;
		if (_tmp4_) {
			FILE* _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp5_ = stdout;
			_tmp6_ = message;
			fprintf (_tmp5_, "WARNING: %s\n", _tmp6_);
		} else {
			FILE* _tmp7_ = NULL;
			const gchar* _tmp8_ = NULL;
			_tmp7_ = stdout;
			_tmp8_ = message;
			fprintf (_tmp7_, "WARNING: %s", _tmp8_);
		}
	}
}


void report_error (const gchar* message, gint ret_value, gboolean newline) {
	gboolean _tmp0_ = FALSE;
	gint _tmp5_ = 0;
	g_return_if_fail (message != NULL);
	_tmp0_ = newline;
	if (_tmp0_) {
		FILE* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		_tmp1_ = stderr;
		_tmp2_ = message;
		fprintf (_tmp1_, "ERROR: %s\n", _tmp2_);
	} else {
		FILE* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		_tmp3_ = stderr;
		_tmp4_ = message;
		fprintf (_tmp3_, "ERROR: %s", _tmp4_);
	}
	_tmp5_ = ret_value;
	exit (_tmp5_);
}



