/* submarine.c generated by valac 0.28.0, the Vala compiler
 * generated from submarine.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include "Submarine.h"
#include <glib/gstdio.h>
#include <libnotify/notify.h>
#include <gio/gio.h>


#define TYPE_SUBMARINE_CONSOLE (submarine_console_get_type ())
#define SUBMARINE_CONSOLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SUBMARINE_CONSOLE, SubmarineConsole))
#define SUBMARINE_CONSOLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SUBMARINE_CONSOLE, SubmarineConsoleClass))
#define IS_SUBMARINE_CONSOLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SUBMARINE_CONSOLE))
#define IS_SUBMARINE_CONSOLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SUBMARINE_CONSOLE))
#define SUBMARINE_CONSOLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SUBMARINE_CONSOLE, SubmarineConsoleClass))

typedef struct _SubmarineConsole SubmarineConsole;
typedef struct _SubmarineConsoleClass SubmarineConsoleClass;
typedef struct _SubmarineConsolePrivate SubmarineConsolePrivate;

#define SUBMARINE_CONSOLE_TYPE_EXIT_VALUE (submarine_console_exit_value_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __vala_SubmarineServerInfo_free0(var) ((var == NULL) ? NULL : (var = (_vala_SubmarineServerInfo_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

#define REPORT_TYPE_VERBOSITY (report_verbosity_get_type ())
#define __vala_SubmarineLanguageInfo_free0(var) ((var == NULL) ? NULL : (var = (_vala_SubmarineLanguageInfo_free (var), NULL)))
#define _submarine_subtitle_unref0(var) ((var == NULL) ? NULL : (var = (submarine_subtitle_unref (var), NULL)))

struct _SubmarineConsole {
	GObject parent_instance;
	SubmarineConsolePrivate * priv;
};

struct _SubmarineConsoleClass {
	GObjectClass parent_class;
};

typedef enum  {
	SUBMARINE_CONSOLE_EXIT_VALUE_OK = 0,
	SUBMARINE_CONSOLE_EXIT_VALUE_PROGRAM_ERROR = 1,
	SUBMARINE_CONSOLE_EXIT_VALUE_INPUT_ERROR = 2
} SubmarineConsoleExitValue;

typedef enum  {
	REPORT_VERBOSITY_NONE = 0,
	REPORT_VERBOSITY_DEFAULT = 1,
	REPORT_VERBOSITY_ALL = 2
} ReportVerbosity;


static gpointer submarine_console_parent_class = NULL;
static gchar** submarine_console__filenames;
static gchar** submarine_console__filenames = NULL;
static gchar** submarine_console__languages;
static gchar** submarine_console__languages = NULL;
static gchar** submarine_console__server_codes;
static gchar** submarine_console__server_codes = NULL;
static GeeSet* submarine_console_filenames;
static GeeSet* submarine_console_filenames = NULL;
static GeeMultiMap* submarine_console_existing_subtitles;
static GeeMultiMap* submarine_console_existing_subtitles = NULL;
static GeeSet* submarine_console_languages;
static GeeSet* submarine_console_languages = NULL;
static GeeSet* submarine_console_server_codes;
static GeeSet* submarine_console_server_codes = NULL;
static gboolean submarine_console_force;
static gboolean submarine_console_force = FALSE;
static gboolean submarine_console_quiet;
static gboolean submarine_console_quiet = FALSE;
static gboolean submarine_console_verbose;
static gboolean submarine_console_verbose = FALSE;
static gboolean submarine_console_info;
static gboolean submarine_console_info = FALSE;
static SubmarineSession* submarine_console_session;
static SubmarineSession* submarine_console_session = NULL;
extern ReportVerbosity report_verbosity;

GType submarine_console_get_type (void) G_GNUC_CONST;
enum  {
	SUBMARINE_CONSOLE_DUMMY_PROPERTY
};
static GType submarine_console_exit_value_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define CONSTANTS_RELEASE_NAME "submarine"
#define SUBMARINE_CONSOLE_name CONSTANTS_RELEASE_NAME
#define CONSTANTS_VERSION "0.1.6"
#define SUBMARINE_CONSOLE_version CONSTANTS_VERSION
static GeeSet* submarine_console_string_array_to_set (gchar** array, int array_length1);
static void submarine_console_init (gchar*** args, int* args_length1);
static void _vala_SubmarineServerInfo_free (SubmarineServerInfo* self);
void report_error (const gchar* message, gint ret_value, gboolean newline);
GType report_verbosity_get_type (void) G_GNUC_CONST;
void report_message (const gchar* message, gboolean newline, ReportVerbosity message_verbosity);
static void _vala_SubmarineLanguageInfo_free (SubmarineLanguageInfo* self);
void report_warning (const gchar* message, gboolean newline, ReportVerbosity message_verbosity);
static gchar* submarine_console_subtitle_save (const gchar* filename, SubmarineSubtitle* subtitle, gboolean force);
static GeeMap* submarine_console_subtitle_save_multiple (GeeMap* save_map, gboolean force);
static gint submarine_console_main (gchar** args, int args_length1);
SubmarineConsole* submarine_console_new (void);
SubmarineConsole* submarine_console_construct (GType object_type);
static void submarine_console_finalize (GObject* obj);
static gint _vala_array_length (gpointer array);

static const gchar* SUBMARINE_CONSOLE_SUBTITLE_EXTENSIONS[15] = {"aqt", "jss", "sub", "ttxt", "pjs", "psb", "rt", "smi", "ssf", "srt", "gsub", "ssa", "ass", "usf", "txt"};
static const GOptionEntry SUBMARINE_CONSOLE_options[8] = {{"", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &submarine_console__filenames, "List of movie files", "FILE..."}, {"language", 'l', 0, G_OPTION_ARG_STRING_ARRAY, &submarine_console__languages, "Set languages to filter (use '-l help' to list available options)", "CODE"}, {"server", 's', 0, G_OPTION_ARG_STRING_ARRAY, &submarine_console__server_codes, "Set servers to use (use '-s help' to list available options)", "CODE"}, {"force", 'f', 0, G_OPTION_ARG_NONE, &submarine_console_force, "Replace existing subtitles", NULL}, {"quiet", 'q', 0, G_OPTION_ARG_NONE, &submarine_console_quiet, "Be quiet", NULL}, {"verbose", 'v', 0, G_OPTION_ARG_NONE, &submarine_console_verbose, "Be verbose", NULL}, {"version", 'V', 0, G_OPTION_ARG_NONE, &submarine_console_info, "Show program information", NULL}, {NULL}};

static GType submarine_console_exit_value_get_type (void) {
	static volatile gsize submarine_console_exit_value_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_console_exit_value_type_id__volatile)) {
		static const GEnumValue values[] = {{SUBMARINE_CONSOLE_EXIT_VALUE_OK, "SUBMARINE_CONSOLE_EXIT_VALUE_OK", "ok"}, {SUBMARINE_CONSOLE_EXIT_VALUE_PROGRAM_ERROR, "SUBMARINE_CONSOLE_EXIT_VALUE_PROGRAM_ERROR", "program-error"}, {SUBMARINE_CONSOLE_EXIT_VALUE_INPUT_ERROR, "SUBMARINE_CONSOLE_EXIT_VALUE_INPUT_ERROR", "input-error"}, {0, NULL, NULL}};
		GType submarine_console_exit_value_type_id;
		submarine_console_exit_value_type_id = g_enum_register_static ("SubmarineConsoleExitValue", values);
		g_once_init_leave (&submarine_console_exit_value_type_id__volatile, submarine_console_exit_value_type_id);
	}
	return submarine_console_exit_value_type_id__volatile;
}


static GeeSet* submarine_console_string_array_to_set (gchar** array, int array_length1) {
	GeeSet* result = NULL;
	GeeHashSet* hash_set = NULL;
	GeeHashSet* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
	hash_set = _tmp0_;
	_tmp1_ = array;
	_tmp1__length1 = array_length1;
	{
		gchar** el_collection = NULL;
		gint el_collection_length1 = 0;
		gint _el_collection_size_ = 0;
		gint el_it = 0;
		el_collection = _tmp1_;
		el_collection_length1 = _tmp1__length1;
		for (el_it = 0; el_it < _tmp1__length1; el_it = el_it + 1) {
			gchar* _tmp2_ = NULL;
			gchar* el = NULL;
			_tmp2_ = g_strdup (el_collection[el_it]);
			el = _tmp2_;
			{
				GeeHashSet* _tmp3_ = NULL;
				const gchar* _tmp4_ = NULL;
				_tmp3_ = hash_set;
				_tmp4_ = el;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp3_, _tmp4_);
				_g_free0 (el);
			}
		}
	}
	result = (GeeSet*) hash_set;
	return result;
}


static void _vala_SubmarineServerInfo_free (SubmarineServerInfo* self) {
	submarine_server_info_destroy (self);
	g_free (self);
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	glong string_length = 0L;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	glong _tmp2_ = 0L;
	glong _tmp5_ = 0L;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_ = 0L;
	gboolean _tmp12_ = FALSE;
	glong _tmp13_ = 0L;
	glong _tmp16_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	gchar* _tmp21_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_ = 0L;
		glong _tmp7_ = 0L;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	g_return_val_if_fail (_tmp8_, NULL);
	_tmp13_ = end;
	if (_tmp13_ >= ((glong) 0)) {
		glong _tmp14_ = 0L;
		glong _tmp15_ = 0L;
		_tmp14_ = end;
		_tmp15_ = string_length;
		_tmp12_ = _tmp14_ <= _tmp15_;
	} else {
		_tmp12_ = FALSE;
	}
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp16_ = start;
	_tmp17_ = end;
	g_return_val_if_fail (_tmp16_ <= _tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	_tmp20_ = start;
	_tmp21_ = g_strndup (((gchar*) self) + _tmp18_, (gsize) (_tmp19_ - _tmp20_));
	result = _tmp21_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _vala_SubmarineLanguageInfo_free (SubmarineLanguageInfo* self) {
	submarine_language_info_destroy (self);
	g_free (self);
}


static gint string_last_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static void submarine_console_init (gchar*** args, int* args_length1) {
	gint args_length = 0;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	GOptionContext* opt_context = NULL;
	GOptionContext* _tmp1_ = NULL;
	gchar* description = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp25_ = NULL;
	gchar* _tmp26_ = NULL;
	GOptionContext* _tmp27_ = NULL;
	const gchar* _tmp28_ = NULL;
	GOptionContext* _tmp29_ = NULL;
	GOptionContext* _tmp30_ = NULL;
	gint _tmp34_ = 0;
	gchar** _tmp38_ = NULL;
	gint _tmp38__length1 = 0;
	GeeSet* _tmp39_ = NULL;
	gchar** _tmp40_ = NULL;
	gint _tmp40__length1 = 0;
	GeeSet* _tmp41_ = NULL;
	gchar** _tmp42_ = NULL;
	gint _tmp42__length1 = 0;
	GeeSet* _tmp43_ = NULL;
	gboolean _tmp44_ = FALSE;
	gboolean _tmp47_ = FALSE;
	GeeSet* _tmp134_ = NULL;
	gboolean _tmp135_ = FALSE;
	gboolean _tmp136_ = FALSE;
	GeeHashMultiMap* _tmp137_ = NULL;
	GeeSet* _tmp170_ = NULL;
	gboolean _tmp171_ = FALSE;
	gboolean _tmp172_ = FALSE;
	GeeSet* _tmp176_ = NULL;
	gboolean _tmp177_ = FALSE;
	gboolean _tmp178_ = FALSE;
	GError * _inner_error_ = NULL;
	_tmp0_ = *args;
	_tmp0__length1 = *args_length1;
	args_length = _tmp0__length1;
	_tmp1_ = g_option_context_new ("- download subtitles");
	opt_context = _tmp1_;
	_tmp2_ = g_strdup ("Powered by:\n");
	description = _tmp2_;
	{
		GeeList* _server_code_list = NULL;
		GeeList* _tmp3_ = NULL;
		gint _server_code_size = 0;
		GeeList* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		gint _server_code_index = 0;
		_tmp3_ = submarine_get_server_codes ();
		_server_code_list = _tmp3_;
		_tmp4_ = _server_code_list;
		_tmp5_ = gee_collection_get_size ((GeeCollection*) _tmp4_);
		_tmp6_ = _tmp5_;
		_server_code_size = _tmp6_;
		_server_code_index = -1;
		while (TRUE) {
			gint _tmp7_ = 0;
			gint _tmp8_ = 0;
			gint _tmp9_ = 0;
			gchar* server_code = NULL;
			GeeList* _tmp10_ = NULL;
			gint _tmp11_ = 0;
			gpointer _tmp12_ = NULL;
			SubmarineServerInfo* server_info = NULL;
			const gchar* _tmp13_ = NULL;
			SubmarineServerInfo* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			SubmarineServerInfo* _tmp16_ = NULL;
			const gchar* _tmp17_ = NULL;
			const gchar* _tmp18_ = NULL;
			SubmarineServerInfo* _tmp19_ = NULL;
			const gchar* _tmp20_ = NULL;
			const gchar* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			gchar* _tmp24_ = NULL;
			_tmp7_ = _server_code_index;
			_server_code_index = _tmp7_ + 1;
			_tmp8_ = _server_code_index;
			_tmp9_ = _server_code_size;
			if (!(_tmp8_ < _tmp9_)) {
				break;
			}
			_tmp10_ = _server_code_list;
			_tmp11_ = _server_code_index;
			_tmp12_ = gee_list_get (_tmp10_, _tmp11_);
			server_code = (gchar*) _tmp12_;
			_tmp13_ = server_code;
			_tmp14_ = submarine_get_server_info (_tmp13_);
			server_info = _tmp14_;
			_tmp15_ = description;
			_tmp16_ = server_info;
			_tmp17_ = submarine_server_info_get_name (_tmp16_);
			_tmp18_ = _tmp17_;
			_tmp19_ = server_info;
			_tmp20_ = submarine_server_info_get_address (_tmp19_);
			_tmp21_ = _tmp20_;
			_tmp22_ = g_strdup_printf ("  %s (%s)\n", _tmp18_, _tmp21_);
			_tmp23_ = _tmp22_;
			_tmp24_ = g_strconcat (_tmp15_, _tmp23_, NULL);
			_g_free0 (description);
			description = _tmp24_;
			_g_free0 (_tmp23_);
			__vala_SubmarineServerInfo_free0 (server_info);
			_g_free0 (server_code);
		}
		_g_object_unref0 (_server_code_list);
	}
	_tmp25_ = description;
	_tmp26_ = string_slice (_tmp25_, (glong) 0, (glong) (-1));
	_g_free0 (description);
	description = _tmp26_;
	_tmp27_ = opt_context;
	_tmp28_ = description;
	g_option_context_set_description (_tmp27_, _tmp28_);
	_tmp29_ = opt_context;
	g_option_context_set_help_enabled (_tmp29_, TRUE);
	_tmp30_ = opt_context;
	g_option_context_add_main_entries (_tmp30_, SUBMARINE_CONSOLE_options, NULL);
	{
		GOptionContext* _tmp31_ = NULL;
		_tmp31_ = opt_context;
		g_option_context_parse (_tmp31_, args_length1, args, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp32_ = NULL;
		const gchar* _tmp33_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp32_ = e;
		_tmp33_ = _tmp32_->message;
		report_error (_tmp33_, (gint) SUBMARINE_CONSOLE_EXIT_VALUE_INPUT_ERROR, TRUE);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (description);
		_g_option_context_free0 (opt_context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp34_ = args_length;
	if (_tmp34_ == 1) {
		GOptionContext* _tmp35_ = NULL;
		gchar* _tmp36_ = NULL;
		gchar* _tmp37_ = NULL;
		_tmp35_ = opt_context;
		_tmp36_ = g_option_context_get_help (_tmp35_, TRUE, NULL);
		_tmp37_ = _tmp36_;
		report_message (_tmp37_, FALSE, REPORT_VERBOSITY_DEFAULT);
		_g_free0 (_tmp37_);
		exit ((gint) SUBMARINE_CONSOLE_EXIT_VALUE_INPUT_ERROR);
	}
	_tmp38_ = submarine_console__filenames;
	_tmp38__length1 = _vala_array_length (submarine_console__filenames);
	_tmp39_ = submarine_console_string_array_to_set (_tmp38_, _tmp38__length1);
	_g_object_unref0 (submarine_console_filenames);
	submarine_console_filenames = _tmp39_;
	_tmp40_ = submarine_console__languages;
	_tmp40__length1 = _vala_array_length (submarine_console__languages);
	_tmp41_ = submarine_console_string_array_to_set (_tmp40_, _tmp40__length1);
	_g_object_unref0 (submarine_console_languages);
	submarine_console_languages = _tmp41_;
	_tmp42_ = submarine_console__server_codes;
	_tmp42__length1 = _vala_array_length (submarine_console__server_codes);
	_tmp43_ = submarine_console_string_array_to_set (_tmp42_, _tmp42__length1);
	_g_object_unref0 (submarine_console_server_codes);
	submarine_console_server_codes = _tmp43_;
	_tmp44_ = submarine_console_info;
	if (_tmp44_) {
		gchar* _tmp45_ = NULL;
		gchar* _tmp46_ = NULL;
		_tmp45_ = g_strdup_printf ("%s %s", SUBMARINE_CONSOLE_name, SUBMARINE_CONSOLE_version);
		_tmp46_ = _tmp45_;
		report_message (_tmp46_, TRUE, REPORT_VERBOSITY_DEFAULT);
		_g_free0 (_tmp46_);
		exit ((gint) SUBMARINE_CONSOLE_EXIT_VALUE_OK);
	}
	_tmp47_ = submarine_console_quiet;
	if (_tmp47_) {
		report_verbosity = REPORT_VERBOSITY_NONE;
	} else {
		gboolean _tmp48_ = FALSE;
		_tmp48_ = submarine_console_verbose;
		if (_tmp48_) {
			report_verbosity = REPORT_VERBOSITY_ALL;
		}
	}
	{
		GeeIterator* _code_it = NULL;
		GeeSet* _tmp49_ = NULL;
		GeeIterator* _tmp50_ = NULL;
		_tmp49_ = submarine_console_server_codes;
		_tmp50_ = gee_iterable_iterator ((GeeIterable*) _tmp49_);
		_code_it = _tmp50_;
		while (TRUE) {
			GeeIterator* _tmp51_ = NULL;
			gboolean _tmp52_ = FALSE;
			gchar* code = NULL;
			GeeIterator* _tmp53_ = NULL;
			gpointer _tmp54_ = NULL;
			GeeList* all_server_codes = NULL;
			GeeList* _tmp55_ = NULL;
			const gchar* _tmp56_ = NULL;
			_tmp51_ = _code_it;
			_tmp52_ = gee_iterator_next (_tmp51_);
			if (!_tmp52_) {
				break;
			}
			_tmp53_ = _code_it;
			_tmp54_ = gee_iterator_get (_tmp53_);
			code = (gchar*) _tmp54_;
			_tmp55_ = submarine_get_server_codes ();
			all_server_codes = _tmp55_;
			_tmp56_ = code;
			if (g_strcmp0 (_tmp56_, "help") == 0) {
				report_message ("Available servers:", TRUE, REPORT_VERBOSITY_DEFAULT);
				{
					GeeList* _all_code_list = NULL;
					GeeList* _tmp57_ = NULL;
					GeeList* _tmp58_ = NULL;
					gint _all_code_size = 0;
					GeeList* _tmp59_ = NULL;
					gint _tmp60_ = 0;
					gint _tmp61_ = 0;
					gint _all_code_index = 0;
					_tmp57_ = all_server_codes;
					_tmp58_ = _g_object_ref0 (_tmp57_);
					_all_code_list = _tmp58_;
					_tmp59_ = _all_code_list;
					_tmp60_ = gee_collection_get_size ((GeeCollection*) _tmp59_);
					_tmp61_ = _tmp60_;
					_all_code_size = _tmp61_;
					_all_code_index = -1;
					while (TRUE) {
						gint _tmp62_ = 0;
						gint _tmp63_ = 0;
						gint _tmp64_ = 0;
						gchar* all_code = NULL;
						GeeList* _tmp65_ = NULL;
						gint _tmp66_ = 0;
						gpointer _tmp67_ = NULL;
						SubmarineServerInfo* server_info = NULL;
						const gchar* _tmp68_ = NULL;
						SubmarineServerInfo* _tmp69_ = NULL;
						SubmarineServerInfo* _tmp70_ = NULL;
						const gchar* _tmp71_ = NULL;
						const gchar* _tmp72_ = NULL;
						SubmarineServerInfo* _tmp73_ = NULL;
						const gchar* _tmp74_ = NULL;
						const gchar* _tmp75_ = NULL;
						SubmarineServerInfo* _tmp76_ = NULL;
						const gchar* _tmp77_ = NULL;
						const gchar* _tmp78_ = NULL;
						gchar* _tmp79_ = NULL;
						gchar* _tmp80_ = NULL;
						_tmp62_ = _all_code_index;
						_all_code_index = _tmp62_ + 1;
						_tmp63_ = _all_code_index;
						_tmp64_ = _all_code_size;
						if (!(_tmp63_ < _tmp64_)) {
							break;
						}
						_tmp65_ = _all_code_list;
						_tmp66_ = _all_code_index;
						_tmp67_ = gee_list_get (_tmp65_, _tmp66_);
						all_code = (gchar*) _tmp67_;
						_tmp68_ = all_code;
						_tmp69_ = submarine_get_server_info (_tmp68_);
						server_info = _tmp69_;
						_tmp70_ = server_info;
						_tmp71_ = submarine_server_info_get_code (_tmp70_);
						_tmp72_ = _tmp71_;
						_tmp73_ = server_info;
						_tmp74_ = submarine_server_info_get_name (_tmp73_);
						_tmp75_ = _tmp74_;
						_tmp76_ = server_info;
						_tmp77_ = submarine_server_info_get_address (_tmp76_);
						_tmp78_ = _tmp77_;
						_tmp79_ = g_strdup_printf ("  %s - %s (%s)", _tmp72_, _tmp75_, _tmp78_);
						_tmp80_ = _tmp79_;
						report_message (_tmp80_, TRUE, REPORT_VERBOSITY_DEFAULT);
						_g_free0 (_tmp80_);
						__vala_SubmarineServerInfo_free0 (server_info);
						_g_free0 (all_code);
					}
					_g_object_unref0 (_all_code_list);
				}
				exit ((gint) SUBMARINE_CONSOLE_EXIT_VALUE_OK);
			} else {
				GeeList* _tmp81_ = NULL;
				const gchar* _tmp82_ = NULL;
				gboolean _tmp83_ = FALSE;
				_tmp81_ = all_server_codes;
				_tmp82_ = code;
				_tmp83_ = gee_collection_contains ((GeeCollection*) _tmp81_, _tmp82_);
				if (!_tmp83_) {
					const gchar* _tmp84_ = NULL;
					gchar* _tmp85_ = NULL;
					gchar* _tmp86_ = NULL;
					_tmp84_ = code;
					_tmp85_ = g_strdup_printf ("Server '%s' does not exist! Use '-s help' to list available options.", _tmp84_);
					_tmp86_ = _tmp85_;
					report_error (_tmp86_, (gint) SUBMARINE_CONSOLE_EXIT_VALUE_INPUT_ERROR, TRUE);
					_g_free0 (_tmp86_);
				}
			}
			_g_object_unref0 (all_server_codes);
			_g_free0 (code);
		}
		_g_object_unref0 (_code_it);
	}
	{
		GeeIterator* _language_it = NULL;
		GeeSet* _tmp87_ = NULL;
		GeeIterator* _tmp88_ = NULL;
		_tmp87_ = submarine_console_languages;
		_tmp88_ = gee_iterable_iterator ((GeeIterable*) _tmp87_);
		_language_it = _tmp88_;
		while (TRUE) {
			GeeIterator* _tmp89_ = NULL;
			gboolean _tmp90_ = FALSE;
			gchar* language = NULL;
			GeeIterator* _tmp91_ = NULL;
			gpointer _tmp92_ = NULL;
			GeeList* all_language_codes = NULL;
			GeeList* _tmp93_ = NULL;
			const gchar* _tmp94_ = NULL;
			_tmp89_ = _language_it;
			_tmp90_ = gee_iterator_next (_tmp89_);
			if (!_tmp90_) {
				break;
			}
			_tmp91_ = _language_it;
			_tmp92_ = gee_iterator_get (_tmp91_);
			language = (gchar*) _tmp92_;
			_tmp93_ = submarine_get_language_codes ();
			all_language_codes = _tmp93_;
			_tmp94_ = language;
			if (g_strcmp0 (_tmp94_, "help") == 0) {
				report_message ("Available languages:", TRUE, REPORT_VERBOSITY_DEFAULT);
				{
					GeeList* _all_code_list = NULL;
					GeeList* _tmp95_ = NULL;
					GeeList* _tmp96_ = NULL;
					gint _all_code_size = 0;
					GeeList* _tmp97_ = NULL;
					gint _tmp98_ = 0;
					gint _tmp99_ = 0;
					gint _all_code_index = 0;
					_tmp95_ = all_language_codes;
					_tmp96_ = _g_object_ref0 (_tmp95_);
					_all_code_list = _tmp96_;
					_tmp97_ = _all_code_list;
					_tmp98_ = gee_collection_get_size ((GeeCollection*) _tmp97_);
					_tmp99_ = _tmp98_;
					_all_code_size = _tmp99_;
					_all_code_index = -1;
					while (TRUE) {
						gint _tmp100_ = 0;
						gint _tmp101_ = 0;
						gint _tmp102_ = 0;
						gchar* all_code = NULL;
						GeeList* _tmp103_ = NULL;
						gint _tmp104_ = 0;
						gpointer _tmp105_ = NULL;
						SubmarineLanguageInfo* language_info = NULL;
						const gchar* _tmp106_ = NULL;
						SubmarineLanguageInfo* _tmp107_ = NULL;
						SubmarineLanguageInfo* _tmp108_ = NULL;
						const gchar* _tmp109_ = NULL;
						const gchar* _tmp110_ = NULL;
						const gchar* _tmp111_ = NULL;
						_tmp100_ = _all_code_index;
						_all_code_index = _tmp100_ + 1;
						_tmp101_ = _all_code_index;
						_tmp102_ = _all_code_size;
						if (!(_tmp101_ < _tmp102_)) {
							break;
						}
						_tmp103_ = _all_code_list;
						_tmp104_ = _all_code_index;
						_tmp105_ = gee_list_get (_tmp103_, _tmp104_);
						all_code = (gchar*) _tmp105_;
						_tmp106_ = all_code;
						_tmp107_ = submarine_get_language_info (_tmp106_);
						language_info = _tmp107_;
						_tmp108_ = language_info;
						_tmp109_ = submarine_language_info_get_long_code (_tmp108_);
						_tmp110_ = _tmp109_;
						_tmp111_ = all_code;
						if (g_strcmp0 (_tmp110_, _tmp111_) == 0) {
							const gchar* _tmp112_ = NULL;
							SubmarineLanguageInfo* _tmp113_ = NULL;
							const gchar* _tmp114_ = NULL;
							const gchar* _tmp115_ = NULL;
							const gchar* _tmp116_ = NULL;
							SubmarineLanguageInfo* _tmp117_ = NULL;
							const gchar* _tmp118_ = NULL;
							const gchar* _tmp119_ = NULL;
							SubmarineLanguageInfo* _tmp120_ = NULL;
							const gchar* _tmp121_ = NULL;
							const gchar* _tmp122_ = NULL;
							SubmarineLanguageInfo* _tmp123_ = NULL;
							const gchar* _tmp124_ = NULL;
							const gchar* _tmp125_ = NULL;
							gchar* _tmp126_ = NULL;
							gchar* _tmp127_ = NULL;
							_tmp113_ = language_info;
							_tmp114_ = submarine_language_info_get_long_code_alt (_tmp113_);
							_tmp115_ = _tmp114_;
							_tmp112_ = _tmp115_;
							if (_tmp112_ == NULL) {
								_tmp112_ = "   ";
							}
							_tmp117_ = language_info;
							_tmp118_ = submarine_language_info_get_short_code (_tmp117_);
							_tmp119_ = _tmp118_;
							_tmp116_ = _tmp119_;
							if (_tmp116_ == NULL) {
								_tmp116_ = "  ";
							}
							_tmp120_ = language_info;
							_tmp121_ = submarine_language_info_get_long_code (_tmp120_);
							_tmp122_ = _tmp121_;
							_tmp123_ = language_info;
							_tmp124_ = submarine_language_info_get_name (_tmp123_);
							_tmp125_ = _tmp124_;
							_tmp126_ = g_strdup_printf ("  %s %s %s - %s", _tmp122_, _tmp112_, _tmp116_, _tmp125_);
							_tmp127_ = _tmp126_;
							report_message (_tmp127_, TRUE, REPORT_VERBOSITY_DEFAULT);
							_g_free0 (_tmp127_);
						}
						__vala_SubmarineLanguageInfo_free0 (language_info);
						_g_free0 (all_code);
					}
					_g_object_unref0 (_all_code_list);
				}
				exit ((gint) SUBMARINE_CONSOLE_EXIT_VALUE_OK);
			} else {
				GeeList* _tmp128_ = NULL;
				const gchar* _tmp129_ = NULL;
				gboolean _tmp130_ = FALSE;
				_tmp128_ = all_language_codes;
				_tmp129_ = language;
				_tmp130_ = gee_collection_contains ((GeeCollection*) _tmp128_, _tmp129_);
				if (!_tmp130_) {
					const gchar* _tmp131_ = NULL;
					gchar* _tmp132_ = NULL;
					gchar* _tmp133_ = NULL;
					_tmp131_ = language;
					_tmp132_ = g_strdup_printf ("Language '%s' does not exist! Use '-l help' to list available options.", _tmp131_);
					_tmp133_ = _tmp132_;
					report_error (_tmp133_, (gint) SUBMARINE_CONSOLE_EXIT_VALUE_INPUT_ERROR, TRUE);
					_g_free0 (_tmp133_);
				}
			}
			_g_object_unref0 (all_language_codes);
			_g_free0 (language);
		}
		_g_object_unref0 (_language_it);
	}
	_tmp134_ = submarine_console_filenames;
	_tmp135_ = gee_collection_get_is_empty ((GeeCollection*) _tmp134_);
	_tmp136_ = _tmp135_;
	if (_tmp136_) {
		report_error ("No file selected!", (gint) SUBMARINE_CONSOLE_EXIT_VALUE_INPUT_ERROR, TRUE);
	}
	_tmp137_ = gee_hash_multi_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (submarine_console_existing_subtitles);
	submarine_console_existing_subtitles = (GeeMultiMap*) _tmp137_;
	{
		GeeIterator* _filename_it = NULL;
		GeeSet* _tmp138_ = NULL;
		GeeIterator* _tmp139_ = NULL;
		_tmp138_ = submarine_console_filenames;
		_tmp139_ = gee_iterable_iterator ((GeeIterable*) _tmp138_);
		_filename_it = _tmp139_;
		while (TRUE) {
			GeeIterator* _tmp140_ = NULL;
			gboolean _tmp141_ = FALSE;
			gchar* filename = NULL;
			GeeIterator* _tmp142_ = NULL;
			gpointer _tmp143_ = NULL;
			const gchar* _tmp144_ = NULL;
			gboolean _tmp145_ = FALSE;
			_tmp140_ = _filename_it;
			_tmp141_ = gee_iterator_next (_tmp140_);
			if (!_tmp141_) {
				break;
			}
			_tmp142_ = _filename_it;
			_tmp143_ = gee_iterator_get (_tmp142_);
			filename = (gchar*) _tmp143_;
			_tmp144_ = filename;
			_tmp145_ = g_file_test (_tmp144_, G_FILE_TEST_IS_REGULAR);
			if (!_tmp145_) {
				const gchar* _tmp146_ = NULL;
				gchar* _tmp147_ = NULL;
				gchar* _tmp148_ = NULL;
				_tmp146_ = filename;
				_tmp147_ = g_strdup_printf ("File '%s' does not exist!", _tmp146_);
				_tmp148_ = _tmp147_;
				report_error (_tmp148_, (gint) SUBMARINE_CONSOLE_EXIT_VALUE_INPUT_ERROR, TRUE);
				_g_free0 (_tmp148_);
			}
			{
				const gchar** sub_extension_collection = NULL;
				gint sub_extension_collection_length1 = 0;
				gint _sub_extension_collection_size_ = 0;
				gint sub_extension_it = 0;
				sub_extension_collection = SUBMARINE_CONSOLE_SUBTITLE_EXTENSIONS;
				sub_extension_collection_length1 = G_N_ELEMENTS (SUBMARINE_CONSOLE_SUBTITLE_EXTENSIONS);
				for (sub_extension_it = 0; sub_extension_it < G_N_ELEMENTS (SUBMARINE_CONSOLE_SUBTITLE_EXTENSIONS); sub_extension_it = sub_extension_it + 1) {
					const gchar* sub_extension = NULL;
					sub_extension = sub_extension_collection[sub_extension_it];
					{
						gchar* sub_filename = NULL;
						const gchar* _tmp149_ = NULL;
						gchar* _tmp150_ = NULL;
						const gchar* _tmp151_ = NULL;
						const gchar* _tmp152_ = NULL;
						gint _tmp153_ = 0;
						gchar* _tmp154_ = NULL;
						gchar* _tmp155_ = NULL;
						const gchar* _tmp156_ = NULL;
						gchar* _tmp157_ = NULL;
						const gchar* _tmp158_ = NULL;
						gboolean _tmp159_ = FALSE;
						_tmp149_ = filename;
						_tmp150_ = g_strdup (_tmp149_);
						sub_filename = _tmp150_;
						_tmp151_ = sub_filename;
						_tmp152_ = sub_filename;
						_tmp153_ = string_last_index_of (_tmp152_, ".", 0);
						_tmp154_ = string_slice (_tmp151_, (glong) 0, (glong) (_tmp153_ + 1));
						_tmp155_ = _tmp154_;
						_tmp156_ = sub_extension;
						_tmp157_ = g_strconcat (_tmp155_, _tmp156_, NULL);
						_g_free0 (sub_filename);
						sub_filename = _tmp157_;
						_g_free0 (_tmp155_);
						_tmp158_ = sub_filename;
						_tmp159_ = g_file_test (_tmp158_, G_FILE_TEST_EXISTS);
						if (_tmp159_) {
							GeeMultiMap* _tmp160_ = NULL;
							const gchar* _tmp161_ = NULL;
							const gchar* _tmp162_ = NULL;
							gboolean _tmp163_ = FALSE;
							_tmp160_ = submarine_console_existing_subtitles;
							_tmp161_ = filename;
							_tmp162_ = sub_filename;
							gee_multi_map_set (_tmp160_, _tmp161_, _tmp162_);
							_tmp163_ = submarine_console_force;
							if (!_tmp163_) {
								const gchar* _tmp164_ = NULL;
								gchar* _tmp165_ = NULL;
								gchar* _tmp166_ = NULL;
								_tmp164_ = filename;
								_tmp165_ = g_strdup_printf ("File '%s' already has a subtitle! Use '--force' to replace.", _tmp164_);
								_tmp166_ = _tmp165_;
								report_warning (_tmp166_, TRUE, REPORT_VERBOSITY_ALL);
								_g_free0 (_tmp166_);
								_g_free0 (sub_filename);
								break;
							} else {
								const gchar* _tmp167_ = NULL;
								gchar* _tmp168_ = NULL;
								gchar* _tmp169_ = NULL;
								_tmp167_ = sub_filename;
								_tmp168_ = g_strdup_printf ("Replacing '%s' subtitle.", _tmp167_);
								_tmp169_ = _tmp168_;
								report_warning (_tmp169_, TRUE, REPORT_VERBOSITY_ALL);
								_g_free0 (_tmp169_);
							}
						}
						_g_free0 (sub_filename);
					}
				}
			}
			_g_free0 (filename);
		}
		_g_object_unref0 (_filename_it);
	}
	_tmp170_ = submarine_console_server_codes;
	_tmp171_ = gee_collection_get_is_empty ((GeeCollection*) _tmp170_);
	_tmp172_ = _tmp171_;
	if (_tmp172_) {
		GeeSet* _tmp173_ = NULL;
		GeeList* _tmp174_ = NULL;
		GeeList* _tmp175_ = NULL;
		_tmp173_ = submarine_console_server_codes;
		_tmp174_ = submarine_get_server_codes ();
		_tmp175_ = _tmp174_;
		gee_collection_add_all ((GeeCollection*) _tmp173_, (GeeCollection*) _tmp175_);
		_g_object_unref0 (_tmp175_);
		report_warning ("No server(s) selected, using all servers.", TRUE, REPORT_VERBOSITY_ALL);
	}
	_tmp176_ = submarine_console_languages;
	_tmp177_ = gee_collection_get_is_empty ((GeeCollection*) _tmp176_);
	_tmp178_ = _tmp177_;
	if (_tmp178_) {
		GeeSet* _tmp179_ = NULL;
		GeeSet* _tmp180_ = NULL;
		_tmp179_ = submarine_console_languages;
		gee_collection_add ((GeeCollection*) _tmp179_, "eng");
		_tmp180_ = submarine_console_languages;
		gee_collection_add ((GeeCollection*) _tmp180_, "en");
		report_warning ("No language(s) selected, using ['eng', 'en'] languages.", TRUE, REPORT_VERBOSITY_ALL);
	}
	notify_init ("Submarine");
	_g_free0 (description);
	_g_option_context_free0 (opt_context);
}


static gchar* submarine_console_subtitle_save (const gchar* filename, SubmarineSubtitle* subtitle, gboolean force) {
	gchar* result = NULL;
	gchar* sub_filename = NULL;
	SubmarineSubtitle* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	GFile* file = NULL;
	const gchar* _tmp3_ = NULL;
	GFile* _tmp4_ = NULL;
	SubmarineSubtitle* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	g_return_val_if_fail (subtitle != NULL, NULL);
	_tmp0_ = subtitle;
	_tmp1_ = filename;
	_tmp2_ = submarine_subtitle_get_filename (_tmp0_, _tmp1_);
	sub_filename = _tmp2_;
	_tmp3_ = sub_filename;
	_tmp4_ = g_file_new_for_commandline_arg (_tmp3_);
	file = _tmp4_;
	_tmp5_ = subtitle;
	_tmp6_ = submarine_subtitle_get_has_data (_tmp5_);
	_tmp7_ = _tmp6_;
	if (_tmp7_) {
		gboolean _tmp8_ = FALSE;
		GFile* _tmp9_ = NULL;
		gboolean _tmp10_ = FALSE;
		_tmp9_ = file;
		_tmp10_ = g_file_query_exists (_tmp9_, NULL);
		if (!_tmp10_) {
			_tmp8_ = TRUE;
		} else {
			gboolean _tmp11_ = FALSE;
			GFile* _tmp12_ = NULL;
			gboolean _tmp13_ = FALSE;
			_tmp12_ = file;
			_tmp13_ = g_file_query_exists (_tmp12_, NULL);
			if (_tmp13_) {
				gboolean _tmp14_ = FALSE;
				_tmp14_ = force;
				_tmp11_ = _tmp14_;
			} else {
				_tmp11_ = FALSE;
			}
			_tmp8_ = _tmp11_;
		}
		if (_tmp8_) {
			{
				const gchar* _tmp15_ = NULL;
				SubmarineSubtitle* _tmp16_ = NULL;
				const gchar* _tmp17_ = NULL;
				const gchar* _tmp18_ = NULL;
				_tmp15_ = sub_filename;
				_tmp16_ = subtitle;
				_tmp17_ = submarine_subtitle_get_data (_tmp16_);
				_tmp18_ = _tmp17_;
				g_file_set_contents (_tmp15_, _tmp18_, (gssize) (-1), &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch1_g_error;
				}
				result = sub_filename;
				_g_object_unref0 (file);
				return result;
			}
			goto __finally1;
			__catch1_g_error:
			{
				GError* e = NULL;
				const gchar* _tmp19_ = NULL;
				GError* _tmp20_ = NULL;
				const gchar* _tmp21_ = NULL;
				gchar* _tmp22_ = NULL;
				gchar* _tmp23_ = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp19_ = sub_filename;
				_tmp20_ = e;
				_tmp21_ = _tmp20_->message;
				_tmp22_ = g_strdup_printf ("Could not save '%s': %s", _tmp19_, _tmp21_);
				_tmp23_ = _tmp22_;
				report_warning (_tmp23_, TRUE, REPORT_VERBOSITY_DEFAULT);
				_g_free0 (_tmp23_);
				_g_error_free0 (e);
			}
			__finally1:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file);
				_g_free0 (sub_filename);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = NULL;
	_g_object_unref0 (file);
	_g_free0 (sub_filename);
	return result;
}


static GeeMap* submarine_console_subtitle_save_multiple (GeeMap* save_map, gboolean force) {
	GeeMap* result = NULL;
	GeeHashMap* subtitles_saved = NULL;
	GeeHashMap* _tmp0_ = NULL;
	g_return_val_if_fail (save_map != NULL, NULL);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	subtitles_saved = _tmp0_;
	{
		GeeIterator* _entry_it = NULL;
		GeeMap* _tmp1_ = NULL;
		GeeSet* _tmp2_ = NULL;
		GeeSet* _tmp3_ = NULL;
		GeeSet* _tmp4_ = NULL;
		GeeIterator* _tmp5_ = NULL;
		GeeIterator* _tmp6_ = NULL;
		_tmp1_ = save_map;
		_tmp2_ = gee_map_get_entries (_tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = _tmp3_;
		_tmp5_ = gee_iterable_iterator ((GeeIterable*) _tmp4_);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (_tmp4_);
		_entry_it = _tmp6_;
		while (TRUE) {
			GeeIterator* _tmp7_ = NULL;
			gboolean _tmp8_ = FALSE;
			GeeMapEntry* entry = NULL;
			GeeIterator* _tmp9_ = NULL;
			gpointer _tmp10_ = NULL;
			gchar* sub_filename = NULL;
			GeeMapEntry* _tmp11_ = NULL;
			gconstpointer _tmp12_ = NULL;
			const gchar* _tmp13_ = NULL;
			GeeMapEntry* _tmp14_ = NULL;
			gconstpointer _tmp15_ = NULL;
			SubmarineSubtitle* _tmp16_ = NULL;
			gboolean _tmp17_ = FALSE;
			gchar* _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			_tmp7_ = _entry_it;
			_tmp8_ = gee_iterator_next (_tmp7_);
			if (!_tmp8_) {
				break;
			}
			_tmp9_ = _entry_it;
			_tmp10_ = gee_iterator_get (_tmp9_);
			entry = (GeeMapEntry*) _tmp10_;
			_tmp11_ = entry;
			_tmp12_ = gee_map_entry_get_key (_tmp11_);
			_tmp13_ = _tmp12_;
			_tmp14_ = entry;
			_tmp15_ = gee_map_entry_get_value (_tmp14_);
			_tmp16_ = _tmp15_;
			_tmp17_ = force;
			_tmp18_ = submarine_console_subtitle_save ((const gchar*) _tmp13_, (SubmarineSubtitle*) _tmp16_, _tmp17_);
			sub_filename = _tmp18_;
			_tmp19_ = sub_filename;
			if (_tmp19_ != NULL) {
				GeeHashMap* _tmp20_ = NULL;
				GeeMapEntry* _tmp21_ = NULL;
				gconstpointer _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				const gchar* _tmp24_ = NULL;
				_tmp20_ = subtitles_saved;
				_tmp21_ = entry;
				_tmp22_ = gee_map_entry_get_key (_tmp21_);
				_tmp23_ = _tmp22_;
				_tmp24_ = sub_filename;
				gee_abstract_map_set ((GeeAbstractMap*) _tmp20_, (const gchar*) _tmp23_, _tmp24_);
			}
			_g_free0 (sub_filename);
			_g_object_unref0 (entry);
		}
		_g_object_unref0 (_entry_it);
	}
	result = (GeeMap*) subtitles_saved;
	return result;
}


static gint submarine_console_main (gchar** args, int args_length1) {
	gint result = 0;
	NotifyNotification* success = NULL;
	NotifyNotification* _tmp0_ = NULL;
	NotifyNotification* fails = NULL;
	NotifyNotification* _tmp1_ = NULL;
	NotifyNotification* faild = NULL;
	NotifyNotification* _tmp2_ = NULL;
	SubmarineSession* _tmp3_ = NULL;
	GeeSet* connected_servers = NULL;
	SubmarineSession* _tmp4_ = NULL;
	GeeSet* _tmp5_ = NULL;
	GeeSet* _tmp6_ = NULL;
	GeeSet* _tmp34_ = NULL;
	gboolean _tmp35_ = FALSE;
	gboolean _tmp36_ = FALSE;
	GError * _inner_error_ = NULL;
	submarine_console_init (&args, &args_length1);
	_tmp0_ = notify_notification_new ("Download successful", "Found subtitle", "dialog-information");
	success = _tmp0_;
	_tmp1_ = notify_notification_new ("Download Failed", "Connection to servers failed", "dialog-warning");
	fails = _tmp1_;
	_tmp2_ = notify_notification_new ("Download Failed", "Unable to find subtitle or save", "dialog-warning");
	faild = _tmp2_;
	_tmp3_ = submarine_session_new ();
	_g_object_unref0 (submarine_console_session);
	submarine_console_session = _tmp3_;
	report_message ("Connecting to servers:", TRUE, REPORT_VERBOSITY_DEFAULT);
	_tmp4_ = submarine_console_session;
	_tmp5_ = submarine_console_server_codes;
	_tmp6_ = submarine_session_server_connect_multiple (_tmp4_, (GeeCollection*) _tmp5_);
	connected_servers = _tmp6_;
	{
		GeeIterator* _code_it = NULL;
		GeeSet* _tmp7_ = NULL;
		GeeIterator* _tmp8_ = NULL;
		_tmp7_ = submarine_console_server_codes;
		_tmp8_ = gee_iterable_iterator ((GeeIterable*) _tmp7_);
		_code_it = _tmp8_;
		while (TRUE) {
			GeeIterator* _tmp9_ = NULL;
			gboolean _tmp10_ = FALSE;
			gchar* code = NULL;
			GeeIterator* _tmp11_ = NULL;
			gpointer _tmp12_ = NULL;
			SubmarineServerInfo* server_info = NULL;
			const gchar* _tmp13_ = NULL;
			SubmarineServerInfo* _tmp14_ = NULL;
			GeeSet* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gboolean _tmp17_ = FALSE;
			_tmp9_ = _code_it;
			_tmp10_ = gee_iterator_next (_tmp9_);
			if (!_tmp10_) {
				break;
			}
			_tmp11_ = _code_it;
			_tmp12_ = gee_iterator_get (_tmp11_);
			code = (gchar*) _tmp12_;
			_tmp13_ = code;
			_tmp14_ = submarine_get_server_info (_tmp13_);
			server_info = _tmp14_;
			_tmp15_ = connected_servers;
			_tmp16_ = code;
			_tmp17_ = gee_collection_contains ((GeeCollection*) _tmp15_, _tmp16_);
			if (_tmp17_) {
				SubmarineServerInfo* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				const gchar* _tmp20_ = NULL;
				SubmarineServerInfo* _tmp21_ = NULL;
				const gchar* _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				gchar* _tmp24_ = NULL;
				gchar* _tmp25_ = NULL;
				_tmp18_ = server_info;
				_tmp19_ = submarine_server_info_get_name (_tmp18_);
				_tmp20_ = _tmp19_;
				_tmp21_ = server_info;
				_tmp22_ = submarine_server_info_get_address (_tmp21_);
				_tmp23_ = _tmp22_;
				_tmp24_ = g_strdup_printf ("  (Success) %s (%s)", _tmp20_, _tmp23_);
				_tmp25_ = _tmp24_;
				report_message (_tmp25_, TRUE, REPORT_VERBOSITY_DEFAULT);
				_g_free0 (_tmp25_);
			} else {
				SubmarineServerInfo* _tmp26_ = NULL;
				const gchar* _tmp27_ = NULL;
				const gchar* _tmp28_ = NULL;
				SubmarineServerInfo* _tmp29_ = NULL;
				const gchar* _tmp30_ = NULL;
				const gchar* _tmp31_ = NULL;
				gchar* _tmp32_ = NULL;
				gchar* _tmp33_ = NULL;
				_tmp26_ = server_info;
				_tmp27_ = submarine_server_info_get_name (_tmp26_);
				_tmp28_ = _tmp27_;
				_tmp29_ = server_info;
				_tmp30_ = submarine_server_info_get_address (_tmp29_);
				_tmp31_ = _tmp30_;
				_tmp32_ = g_strdup_printf ("  (Failure) %s (%s)", _tmp28_, _tmp31_);
				_tmp33_ = _tmp32_;
				report_message (_tmp33_, TRUE, REPORT_VERBOSITY_DEFAULT);
				_g_free0 (_tmp33_);
			}
			__vala_SubmarineServerInfo_free0 (server_info);
			_g_free0 (code);
		}
		_g_object_unref0 (_code_it);
	}
	_tmp34_ = connected_servers;
	_tmp35_ = gee_collection_get_is_empty ((GeeCollection*) _tmp34_);
	_tmp36_ = _tmp35_;
	if (!_tmp36_) {
		GeeSet* search_filenames = NULL;
		gboolean _tmp37_ = FALSE;
		GeeSet* _tmp47_ = NULL;
		gboolean _tmp48_ = FALSE;
		gboolean _tmp49_ = FALSE;
		GeeMultiMap* subtitles_found_map = NULL;
		SubmarineSession* _tmp50_ = NULL;
		GeeSet* _tmp51_ = NULL;
		GeeSet* _tmp52_ = NULL;
		GeeMultiMap* _tmp53_ = NULL;
		GeeHashMap* subtitles_download_map = NULL;
		GeeHashMap* _tmp75_ = NULL;
		GeeMultiMap* _tmp114_ = NULL;
		gint _tmp115_ = 0;
		gint _tmp116_ = 0;
		GeeSet* subtitles_downloaded = NULL;
		SubmarineSession* _tmp117_ = NULL;
		GeeHashMap* _tmp118_ = NULL;
		GeeCollection* _tmp119_ = NULL;
		GeeCollection* _tmp120_ = NULL;
		GeeCollection* _tmp121_ = NULL;
		GeeSet* _tmp122_ = NULL;
		GeeSet* _tmp123_ = NULL;
		GeeHashMap* subtitles_save_map = NULL;
		GeeHashMap* _tmp124_ = NULL;
		gboolean _tmp172_ = FALSE;
		GeeMap* subtitles_saved_map = NULL;
		GeeHashMap* _tmp194_ = NULL;
		gboolean _tmp195_ = FALSE;
		GeeMap* _tmp196_ = NULL;
		gboolean _error_ = FALSE;
		gboolean _tmp287_ = FALSE;
		_tmp37_ = submarine_console_force;
		if (!_tmp37_) {
			GeeHashSet* _tmp38_ = NULL;
			GeeSet* _tmp39_ = NULL;
			GeeSet* _tmp40_ = NULL;
			GeeSet* _tmp41_ = NULL;
			GeeMultiMap* _tmp42_ = NULL;
			GeeSet* _tmp43_ = NULL;
			GeeSet* _tmp44_ = NULL;
			_tmp38_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL);
			_g_object_unref0 (search_filenames);
			search_filenames = (GeeSet*) _tmp38_;
			_tmp39_ = search_filenames;
			_tmp40_ = submarine_console_filenames;
			gee_collection_add_all ((GeeCollection*) _tmp39_, (GeeCollection*) _tmp40_);
			_tmp41_ = search_filenames;
			_tmp42_ = submarine_console_existing_subtitles;
			_tmp43_ = gee_multi_map_get_keys (_tmp42_);
			_tmp44_ = _tmp43_;
			gee_collection_remove_all ((GeeCollection*) _tmp41_, (GeeCollection*) _tmp44_);
			_g_object_unref0 (_tmp44_);
		} else {
			GeeSet* _tmp45_ = NULL;
			GeeSet* _tmp46_ = NULL;
			_tmp45_ = submarine_console_filenames;
			_tmp46_ = _g_object_ref0 (_tmp45_);
			_g_object_unref0 (search_filenames);
			search_filenames = _tmp46_;
		}
		_tmp47_ = search_filenames;
		_tmp48_ = gee_collection_get_is_empty ((GeeCollection*) _tmp47_);
		_tmp49_ = _tmp48_;
		if (!_tmp49_) {
			report_message ("Searching for subtitles:", TRUE, REPORT_VERBOSITY_DEFAULT);
		}
		_tmp50_ = submarine_console_session;
		_tmp51_ = search_filenames;
		_tmp52_ = submarine_console_languages;
		_tmp53_ = submarine_session_subtitle_search_multiple (_tmp50_, (GeeCollection*) _tmp51_, (GeeCollection*) _tmp52_);
		subtitles_found_map = _tmp53_;
		{
			GeeIterator* _filename_it = NULL;
			GeeSet* _tmp54_ = NULL;
			GeeIterator* _tmp55_ = NULL;
			_tmp54_ = search_filenames;
			_tmp55_ = gee_iterable_iterator ((GeeIterable*) _tmp54_);
			_filename_it = _tmp55_;
			while (TRUE) {
				GeeIterator* _tmp56_ = NULL;
				gboolean _tmp57_ = FALSE;
				gchar* filename = NULL;
				GeeIterator* _tmp58_ = NULL;
				gpointer _tmp59_ = NULL;
				GeeMultiMap* _tmp60_ = NULL;
				const gchar* _tmp61_ = NULL;
				gboolean _tmp62_ = FALSE;
				_tmp56_ = _filename_it;
				_tmp57_ = gee_iterator_next (_tmp56_);
				if (!_tmp57_) {
					break;
				}
				_tmp58_ = _filename_it;
				_tmp59_ = gee_iterator_get (_tmp58_);
				filename = (gchar*) _tmp59_;
				_tmp60_ = subtitles_found_map;
				_tmp61_ = filename;
				_tmp62_ = gee_multi_map_contains (_tmp60_, _tmp61_);
				if (_tmp62_) {
					GeeMultiMap* _tmp63_ = NULL;
					const gchar* _tmp64_ = NULL;
					GeeCollection* _tmp65_ = NULL;
					GeeCollection* _tmp66_ = NULL;
					gint _tmp67_ = 0;
					gint _tmp68_ = 0;
					const gchar* _tmp69_ = NULL;
					gchar* _tmp70_ = NULL;
					gchar* _tmp71_ = NULL;
					_tmp63_ = subtitles_found_map;
					_tmp64_ = filename;
					_tmp65_ = gee_multi_map_get (_tmp63_, _tmp64_);
					_tmp66_ = _tmp65_;
					_tmp67_ = gee_collection_get_size (_tmp66_);
					_tmp68_ = _tmp67_;
					_tmp69_ = filename;
					_tmp70_ = g_strdup_printf ("  (%d) %s", _tmp68_, _tmp69_);
					_tmp71_ = _tmp70_;
					report_message (_tmp71_, TRUE, REPORT_VERBOSITY_DEFAULT);
					_g_free0 (_tmp71_);
					_g_object_unref0 (_tmp66_);
				} else {
					const gchar* _tmp72_ = NULL;
					gchar* _tmp73_ = NULL;
					gchar* _tmp74_ = NULL;
					_tmp72_ = filename;
					_tmp73_ = g_strdup_printf ("  (0) %s", _tmp72_);
					_tmp74_ = _tmp73_;
					report_message (_tmp74_, TRUE, REPORT_VERBOSITY_DEFAULT);
					_g_free0 (_tmp74_);
				}
				_g_free0 (filename);
			}
			_g_object_unref0 (_filename_it);
		}
		_tmp75_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		subtitles_download_map = _tmp75_;
		{
			GeeIterator* _key_it = NULL;
			GeeMultiMap* _tmp76_ = NULL;
			GeeSet* _tmp77_ = NULL;
			GeeSet* _tmp78_ = NULL;
			GeeIterator* _tmp79_ = NULL;
			GeeIterator* _tmp80_ = NULL;
			_tmp76_ = subtitles_found_map;
			_tmp77_ = gee_multi_map_get_keys (_tmp76_);
			_tmp78_ = _tmp77_;
			_tmp79_ = gee_iterable_iterator ((GeeIterable*) _tmp78_);
			_tmp80_ = _tmp79_;
			_g_object_unref0 (_tmp78_);
			_key_it = _tmp80_;
			while (TRUE) {
				GeeIterator* _tmp81_ = NULL;
				gboolean _tmp82_ = FALSE;
				gchar* key = NULL;
				GeeIterator* _tmp83_ = NULL;
				gpointer _tmp84_ = NULL;
				_tmp81_ = _key_it;
				_tmp82_ = gee_iterator_next (_tmp81_);
				if (!_tmp82_) {
					break;
				}
				_tmp83_ = _key_it;
				_tmp84_ = gee_iterator_get (_tmp83_);
				key = (gchar*) _tmp84_;
				{
					GeeIterator* _subtitle_it = NULL;
					GeeMultiMap* _tmp85_ = NULL;
					const gchar* _tmp86_ = NULL;
					GeeCollection* _tmp87_ = NULL;
					GeeCollection* _tmp88_ = NULL;
					GeeIterator* _tmp89_ = NULL;
					GeeIterator* _tmp90_ = NULL;
					_tmp85_ = subtitles_found_map;
					_tmp86_ = key;
					_tmp87_ = gee_multi_map_get (_tmp85_, _tmp86_);
					_tmp88_ = _tmp87_;
					_tmp89_ = gee_iterable_iterator ((GeeIterable*) _tmp88_);
					_tmp90_ = _tmp89_;
					_g_object_unref0 (_tmp88_);
					_subtitle_it = _tmp90_;
					while (TRUE) {
						GeeIterator* _tmp91_ = NULL;
						gboolean _tmp92_ = FALSE;
						SubmarineSubtitle* subtitle = NULL;
						GeeIterator* _tmp93_ = NULL;
						gpointer _tmp94_ = NULL;
						GeeHashMap* _tmp95_ = NULL;
						const gchar* _tmp96_ = NULL;
						gboolean _tmp97_ = FALSE;
						_tmp91_ = _subtitle_it;
						_tmp92_ = gee_iterator_next (_tmp91_);
						if (!_tmp92_) {
							break;
						}
						_tmp93_ = _subtitle_it;
						_tmp94_ = gee_iterator_get (_tmp93_);
						subtitle = (SubmarineSubtitle*) _tmp94_;
						_tmp95_ = subtitles_download_map;
						_tmp96_ = key;
						_tmp97_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp95_, _tmp96_);
						if (!_tmp97_) {
							GeeHashMap* _tmp98_ = NULL;
							const gchar* _tmp99_ = NULL;
							SubmarineSubtitle* _tmp100_ = NULL;
							_tmp98_ = subtitles_download_map;
							_tmp99_ = key;
							_tmp100_ = subtitle;
							gee_abstract_map_set ((GeeAbstractMap*) _tmp98_, _tmp99_, _tmp100_);
						} else {
							SubmarineSubtitle* _tmp101_ = NULL;
							gdouble _tmp102_ = 0.0;
							gdouble _tmp103_ = 0.0;
							GeeHashMap* _tmp104_ = NULL;
							const gchar* _tmp105_ = NULL;
							gpointer _tmp106_ = NULL;
							SubmarineSubtitle* _tmp107_ = NULL;
							gdouble _tmp108_ = 0.0;
							gdouble _tmp109_ = 0.0;
							gboolean _tmp110_ = FALSE;
							_tmp101_ = subtitle;
							_tmp102_ = submarine_subtitle_get_rating (_tmp101_);
							_tmp103_ = _tmp102_;
							_tmp104_ = subtitles_download_map;
							_tmp105_ = key;
							_tmp106_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp104_, _tmp105_);
							_tmp107_ = (SubmarineSubtitle*) _tmp106_;
							_tmp108_ = submarine_subtitle_get_rating (_tmp107_);
							_tmp109_ = _tmp108_;
							_tmp110_ = _tmp103_ > _tmp109_;
							_submarine_subtitle_unref0 (_tmp107_);
							if (_tmp110_) {
								GeeHashMap* _tmp111_ = NULL;
								const gchar* _tmp112_ = NULL;
								SubmarineSubtitle* _tmp113_ = NULL;
								_tmp111_ = subtitles_download_map;
								_tmp112_ = key;
								_tmp113_ = subtitle;
								gee_abstract_map_set ((GeeAbstractMap*) _tmp111_, _tmp112_, _tmp113_);
							}
						}
						_submarine_subtitle_unref0 (subtitle);
					}
					_g_object_unref0 (_subtitle_it);
				}
				_g_free0 (key);
			}
			_g_object_unref0 (_key_it);
		}
		_tmp114_ = subtitles_found_map;
		_tmp115_ = gee_multi_map_get_size (_tmp114_);
		_tmp116_ = _tmp115_;
		if (_tmp116_ > 0) {
			report_message ("Downloading subtitles:", TRUE, REPORT_VERBOSITY_DEFAULT);
		}
		_tmp117_ = submarine_console_session;
		_tmp118_ = subtitles_download_map;
		_tmp119_ = gee_abstract_map_get_values ((GeeMap*) _tmp118_);
		_tmp120_ = _tmp119_;
		_tmp121_ = _tmp120_;
		_tmp122_ = submarine_session_subtitle_download_multiple (_tmp117_, _tmp121_);
		_tmp123_ = _tmp122_;
		_g_object_unref0 (_tmp121_);
		subtitles_downloaded = _tmp123_;
		_tmp124_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, SUBMARINE_TYPE_SUBTITLE, (GBoxedCopyFunc) submarine_subtitle_ref, submarine_subtitle_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
		subtitles_save_map = _tmp124_;
		{
			GeeIterator* _entry_it = NULL;
			GeeHashMap* _tmp125_ = NULL;
			GeeSet* _tmp126_ = NULL;
			GeeSet* _tmp127_ = NULL;
			GeeSet* _tmp128_ = NULL;
			GeeIterator* _tmp129_ = NULL;
			GeeIterator* _tmp130_ = NULL;
			_tmp125_ = subtitles_download_map;
			_tmp126_ = gee_abstract_map_get_entries ((GeeMap*) _tmp125_);
			_tmp127_ = _tmp126_;
			_tmp128_ = _tmp127_;
			_tmp129_ = gee_iterable_iterator ((GeeIterable*) _tmp128_);
			_tmp130_ = _tmp129_;
			_g_object_unref0 (_tmp128_);
			_entry_it = _tmp130_;
			while (TRUE) {
				GeeIterator* _tmp131_ = NULL;
				gboolean _tmp132_ = FALSE;
				GeeMapEntry* entry = NULL;
				GeeIterator* _tmp133_ = NULL;
				gpointer _tmp134_ = NULL;
				GeeSet* _tmp135_ = NULL;
				GeeMapEntry* _tmp136_ = NULL;
				gconstpointer _tmp137_ = NULL;
				SubmarineSubtitle* _tmp138_ = NULL;
				gboolean _tmp139_ = FALSE;
				_tmp131_ = _entry_it;
				_tmp132_ = gee_iterator_next (_tmp131_);
				if (!_tmp132_) {
					break;
				}
				_tmp133_ = _entry_it;
				_tmp134_ = gee_iterator_get (_tmp133_);
				entry = (GeeMapEntry*) _tmp134_;
				_tmp135_ = subtitles_downloaded;
				_tmp136_ = entry;
				_tmp137_ = gee_map_entry_get_value (_tmp136_);
				_tmp138_ = _tmp137_;
				_tmp139_ = gee_collection_contains ((GeeCollection*) _tmp135_, (SubmarineSubtitle*) _tmp138_);
				if (_tmp139_) {
					GeeMapEntry* _tmp140_ = NULL;
					gconstpointer _tmp141_ = NULL;
					SubmarineSubtitle* _tmp142_ = NULL;
					gdouble _tmp143_ = 0.0;
					gdouble _tmp144_ = 0.0;
					GeeMapEntry* _tmp145_ = NULL;
					gconstpointer _tmp146_ = NULL;
					SubmarineSubtitle* _tmp147_ = NULL;
					GeeMapEntry* _tmp148_ = NULL;
					gconstpointer _tmp149_ = NULL;
					const gchar* _tmp150_ = NULL;
					gchar* _tmp151_ = NULL;
					gchar* _tmp152_ = NULL;
					gchar* _tmp153_ = NULL;
					gchar* _tmp154_ = NULL;
					GeeHashMap* _tmp155_ = NULL;
					GeeMapEntry* _tmp156_ = NULL;
					gconstpointer _tmp157_ = NULL;
					const gchar* _tmp158_ = NULL;
					GeeMapEntry* _tmp159_ = NULL;
					gconstpointer _tmp160_ = NULL;
					SubmarineSubtitle* _tmp161_ = NULL;
					_tmp140_ = entry;
					_tmp141_ = gee_map_entry_get_value (_tmp140_);
					_tmp142_ = _tmp141_;
					_tmp143_ = submarine_subtitle_get_rating ((SubmarineSubtitle*) _tmp142_);
					_tmp144_ = _tmp143_;
					_tmp145_ = entry;
					_tmp146_ = gee_map_entry_get_value (_tmp145_);
					_tmp147_ = _tmp146_;
					_tmp148_ = entry;
					_tmp149_ = gee_map_entry_get_key (_tmp148_);
					_tmp150_ = _tmp149_;
					_tmp151_ = submarine_subtitle_get_filename ((SubmarineSubtitle*) _tmp147_, (const gchar*) _tmp150_);
					_tmp152_ = _tmp151_;
					_tmp153_ = g_strdup_printf ("  (%.1f) %s", _tmp144_, _tmp152_);
					_tmp154_ = _tmp153_;
					report_message (_tmp154_, TRUE, REPORT_VERBOSITY_DEFAULT);
					_g_free0 (_tmp154_);
					_g_free0 (_tmp152_);
					_tmp155_ = subtitles_save_map;
					_tmp156_ = entry;
					_tmp157_ = gee_map_entry_get_key (_tmp156_);
					_tmp158_ = _tmp157_;
					_tmp159_ = entry;
					_tmp160_ = gee_map_entry_get_value (_tmp159_);
					_tmp161_ = _tmp160_;
					gee_abstract_map_set ((GeeAbstractMap*) _tmp155_, (const gchar*) _tmp158_, (SubmarineSubtitle*) _tmp161_);
				} else {
					GeeMapEntry* _tmp162_ = NULL;
					gconstpointer _tmp163_ = NULL;
					SubmarineSubtitle* _tmp164_ = NULL;
					GeeMapEntry* _tmp165_ = NULL;
					gconstpointer _tmp166_ = NULL;
					const gchar* _tmp167_ = NULL;
					gchar* _tmp168_ = NULL;
					gchar* _tmp169_ = NULL;
					gchar* _tmp170_ = NULL;
					gchar* _tmp171_ = NULL;
					_tmp162_ = entry;
					_tmp163_ = gee_map_entry_get_value (_tmp162_);
					_tmp164_ = _tmp163_;
					_tmp165_ = entry;
					_tmp166_ = gee_map_entry_get_key (_tmp165_);
					_tmp167_ = _tmp166_;
					_tmp168_ = submarine_subtitle_get_filename ((SubmarineSubtitle*) _tmp164_, (const gchar*) _tmp167_);
					_tmp169_ = _tmp168_;
					_tmp170_ = g_strdup_printf ("  (Could not download) %s", _tmp169_);
					_tmp171_ = _tmp170_;
					report_message (_tmp171_, TRUE, REPORT_VERBOSITY_DEFAULT);
					_g_free0 (_tmp171_);
					_g_free0 (_tmp169_);
				}
				_g_object_unref0 (entry);
			}
			_g_object_unref0 (_entry_it);
		}
		_tmp172_ = submarine_console_force;
		if (_tmp172_) {
			{
				GeeIterator* _filename_it = NULL;
				GeeHashMap* _tmp173_ = NULL;
				GeeSet* _tmp174_ = NULL;
				GeeSet* _tmp175_ = NULL;
				GeeSet* _tmp176_ = NULL;
				GeeIterator* _tmp177_ = NULL;
				GeeIterator* _tmp178_ = NULL;
				_tmp173_ = subtitles_save_map;
				_tmp174_ = gee_abstract_map_get_keys ((GeeMap*) _tmp173_);
				_tmp175_ = _tmp174_;
				_tmp176_ = _tmp175_;
				_tmp177_ = gee_iterable_iterator ((GeeIterable*) _tmp176_);
				_tmp178_ = _tmp177_;
				_g_object_unref0 (_tmp176_);
				_filename_it = _tmp178_;
				while (TRUE) {
					GeeIterator* _tmp179_ = NULL;
					gboolean _tmp180_ = FALSE;
					gchar* filename = NULL;
					GeeIterator* _tmp181_ = NULL;
					gpointer _tmp182_ = NULL;
					_tmp179_ = _filename_it;
					_tmp180_ = gee_iterator_next (_tmp179_);
					if (!_tmp180_) {
						break;
					}
					_tmp181_ = _filename_it;
					_tmp182_ = gee_iterator_get (_tmp181_);
					filename = (gchar*) _tmp182_;
					{
						GeeIterator* _sub_filename_it = NULL;
						GeeMultiMap* _tmp183_ = NULL;
						const gchar* _tmp184_ = NULL;
						GeeCollection* _tmp185_ = NULL;
						GeeCollection* _tmp186_ = NULL;
						GeeIterator* _tmp187_ = NULL;
						GeeIterator* _tmp188_ = NULL;
						_tmp183_ = submarine_console_existing_subtitles;
						_tmp184_ = filename;
						_tmp185_ = gee_multi_map_get (_tmp183_, _tmp184_);
						_tmp186_ = _tmp185_;
						_tmp187_ = gee_iterable_iterator ((GeeIterable*) _tmp186_);
						_tmp188_ = _tmp187_;
						_g_object_unref0 (_tmp186_);
						_sub_filename_it = _tmp188_;
						while (TRUE) {
							GeeIterator* _tmp189_ = NULL;
							gboolean _tmp190_ = FALSE;
							gchar* sub_filename = NULL;
							GeeIterator* _tmp191_ = NULL;
							gpointer _tmp192_ = NULL;
							const gchar* _tmp193_ = NULL;
							_tmp189_ = _sub_filename_it;
							_tmp190_ = gee_iterator_next (_tmp189_);
							if (!_tmp190_) {
								break;
							}
							_tmp191_ = _sub_filename_it;
							_tmp192_ = gee_iterator_get (_tmp191_);
							sub_filename = (gchar*) _tmp192_;
							_tmp193_ = sub_filename;
							g_remove (_tmp193_);
							_g_free0 (sub_filename);
						}
						_g_object_unref0 (_sub_filename_it);
					}
					_g_free0 (filename);
				}
				_g_object_unref0 (_filename_it);
			}
		}
		_tmp194_ = subtitles_save_map;
		_tmp195_ = submarine_console_force;
		_tmp196_ = submarine_console_subtitle_save_multiple ((GeeMap*) _tmp194_, _tmp195_);
		subtitles_saved_map = _tmp196_;
		_error_ = FALSE;
		report_message ("Summary:", TRUE, REPORT_VERBOSITY_DEFAULT);
		{
			GeeIterator* _filename_it = NULL;
			GeeSet* _tmp197_ = NULL;
			GeeIterator* _tmp198_ = NULL;
			_tmp197_ = submarine_console_filenames;
			_tmp198_ = gee_iterable_iterator ((GeeIterable*) _tmp197_);
			_filename_it = _tmp198_;
			while (TRUE) {
				GeeIterator* _tmp199_ = NULL;
				gboolean _tmp200_ = FALSE;
				gchar* filename = NULL;
				GeeIterator* _tmp201_ = NULL;
				gpointer _tmp202_ = NULL;
				GeeMap* _tmp203_ = NULL;
				GeeSet* _tmp204_ = NULL;
				GeeSet* _tmp205_ = NULL;
				GeeSet* _tmp206_ = NULL;
				const gchar* _tmp207_ = NULL;
				gboolean _tmp208_ = FALSE;
				gboolean _tmp209_ = FALSE;
				_tmp199_ = _filename_it;
				_tmp200_ = gee_iterator_next (_tmp199_);
				if (!_tmp200_) {
					break;
				}
				_tmp201_ = _filename_it;
				_tmp202_ = gee_iterator_get (_tmp201_);
				filename = (gchar*) _tmp202_;
				_tmp203_ = subtitles_saved_map;
				_tmp204_ = gee_map_get_keys (_tmp203_);
				_tmp205_ = _tmp204_;
				_tmp206_ = _tmp205_;
				_tmp207_ = filename;
				_tmp208_ = gee_collection_contains ((GeeCollection*) _tmp206_, _tmp207_);
				_tmp209_ = _tmp208_;
				_g_object_unref0 (_tmp206_);
				if (_tmp209_) {
					GeeMultiMap* _tmp210_ = NULL;
					GeeSet* _tmp211_ = NULL;
					GeeSet* _tmp212_ = NULL;
					const gchar* _tmp213_ = NULL;
					gboolean _tmp214_ = FALSE;
					gboolean _tmp215_ = FALSE;
					NotifyNotification* _tmp228_ = NULL;
					_tmp210_ = submarine_console_existing_subtitles;
					_tmp211_ = gee_multi_map_get_keys (_tmp210_);
					_tmp212_ = _tmp211_;
					_tmp213_ = filename;
					_tmp214_ = gee_collection_contains ((GeeCollection*) _tmp212_, _tmp213_);
					_tmp215_ = !_tmp214_;
					_g_object_unref0 (_tmp212_);
					if (_tmp215_) {
						GeeMap* _tmp216_ = NULL;
						const gchar* _tmp217_ = NULL;
						gpointer _tmp218_ = NULL;
						gchar* _tmp219_ = NULL;
						gchar* _tmp220_ = NULL;
						gchar* _tmp221_ = NULL;
						_tmp216_ = subtitles_saved_map;
						_tmp217_ = filename;
						_tmp218_ = gee_map_get (_tmp216_, _tmp217_);
						_tmp219_ = (gchar*) _tmp218_;
						_tmp220_ = g_strdup_printf ("  (Saved) %s", _tmp219_);
						_tmp221_ = _tmp220_;
						report_message (_tmp221_, TRUE, REPORT_VERBOSITY_DEFAULT);
						_g_free0 (_tmp221_);
						_g_free0 (_tmp219_);
					} else {
						GeeMap* _tmp222_ = NULL;
						const gchar* _tmp223_ = NULL;
						gpointer _tmp224_ = NULL;
						gchar* _tmp225_ = NULL;
						gchar* _tmp226_ = NULL;
						gchar* _tmp227_ = NULL;
						_tmp222_ = subtitles_saved_map;
						_tmp223_ = filename;
						_tmp224_ = gee_map_get (_tmp222_, _tmp223_);
						_tmp225_ = (gchar*) _tmp224_;
						_tmp226_ = g_strdup_printf ("  (Replaced) %s", _tmp225_);
						_tmp227_ = _tmp226_;
						report_message (_tmp227_, TRUE, REPORT_VERBOSITY_DEFAULT);
						_g_free0 (_tmp227_);
						_g_free0 (_tmp225_);
					}
					_tmp228_ = success;
					notify_notification_show (_tmp228_, &_inner_error_);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_free0 (filename);
						_g_object_unref0 (_filename_it);
						_g_object_unref0 (subtitles_saved_map);
						_g_object_unref0 (subtitles_save_map);
						_g_object_unref0 (subtitles_downloaded);
						_g_object_unref0 (subtitles_download_map);
						_g_object_unref0 (subtitles_found_map);
						_g_object_unref0 (search_filenames);
						_g_object_unref0 (connected_servers);
						_g_object_unref0 (faild);
						_g_object_unref0 (fails);
						_g_object_unref0 (success);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return 0;
					}
				} else {
					GeeHashMap* _tmp229_ = NULL;
					const gchar* _tmp230_ = NULL;
					gboolean _tmp231_ = FALSE;
					_tmp229_ = subtitles_save_map;
					_tmp230_ = filename;
					_tmp231_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp229_, _tmp230_);
					if (_tmp231_) {
						gchar* sub_filename = NULL;
						GeeHashMap* _tmp232_ = NULL;
						const gchar* _tmp233_ = NULL;
						gpointer _tmp234_ = NULL;
						SubmarineSubtitle* _tmp235_ = NULL;
						const gchar* _tmp236_ = NULL;
						gchar* _tmp237_ = NULL;
						gchar* _tmp238_ = NULL;
						const gchar* _tmp239_ = NULL;
						gchar* _tmp240_ = NULL;
						gchar* _tmp241_ = NULL;
						_tmp232_ = subtitles_download_map;
						_tmp233_ = filename;
						_tmp234_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp232_, _tmp233_);
						_tmp235_ = (SubmarineSubtitle*) _tmp234_;
						_tmp236_ = filename;
						_tmp237_ = submarine_subtitle_get_filename (_tmp235_, _tmp236_);
						_tmp238_ = _tmp237_;
						_submarine_subtitle_unref0 (_tmp235_);
						sub_filename = _tmp238_;
						_tmp239_ = sub_filename;
						_tmp240_ = g_strdup_printf ("  (Could not save) %s", _tmp239_);
						_tmp241_ = _tmp240_;
						report_message (_tmp241_, TRUE, REPORT_VERBOSITY_DEFAULT);
						_g_free0 (_tmp241_);
						_error_ = TRUE;
						_g_free0 (sub_filename);
					} else {
						GeeHashMap* _tmp242_ = NULL;
						GeeSet* _tmp243_ = NULL;
						GeeSet* _tmp244_ = NULL;
						GeeSet* _tmp245_ = NULL;
						const gchar* _tmp246_ = NULL;
						gboolean _tmp247_ = FALSE;
						gboolean _tmp248_ = FALSE;
						_tmp242_ = subtitles_download_map;
						_tmp243_ = gee_abstract_map_get_keys ((GeeMap*) _tmp242_);
						_tmp244_ = _tmp243_;
						_tmp245_ = _tmp244_;
						_tmp246_ = filename;
						_tmp247_ = gee_collection_contains ((GeeCollection*) _tmp245_, _tmp246_);
						_tmp248_ = _tmp247_;
						_g_object_unref0 (_tmp245_);
						if (_tmp248_) {
							GeeIterator* it = NULL;
							GeeMultiMap* _tmp249_ = NULL;
							const gchar* _tmp250_ = NULL;
							GeeCollection* _tmp251_ = NULL;
							GeeCollection* _tmp252_ = NULL;
							GeeIterator* _tmp253_ = NULL;
							GeeIterator* _tmp254_ = NULL;
							GeeIterator* _tmp255_ = NULL;
							gchar* sub_filename = NULL;
							GeeIterator* _tmp256_ = NULL;
							gpointer _tmp257_ = NULL;
							SubmarineSubtitle* _tmp258_ = NULL;
							const gchar* _tmp259_ = NULL;
							gchar* _tmp260_ = NULL;
							gchar* _tmp261_ = NULL;
							const gchar* _tmp262_ = NULL;
							gchar* _tmp263_ = NULL;
							gchar* _tmp264_ = NULL;
							_tmp249_ = subtitles_found_map;
							_tmp250_ = filename;
							_tmp251_ = gee_multi_map_get (_tmp249_, _tmp250_);
							_tmp252_ = _tmp251_;
							_tmp253_ = gee_iterable_iterator ((GeeIterable*) _tmp252_);
							_tmp254_ = _tmp253_;
							_g_object_unref0 (_tmp252_);
							it = _tmp254_;
							_tmp255_ = it;
							gee_iterator_next (_tmp255_);
							_tmp256_ = it;
							_tmp257_ = gee_iterator_get (_tmp256_);
							_tmp258_ = (SubmarineSubtitle*) _tmp257_;
							_tmp259_ = filename;
							_tmp260_ = submarine_subtitle_get_filename (_tmp258_, _tmp259_);
							_tmp261_ = _tmp260_;
							_submarine_subtitle_unref0 (_tmp258_);
							sub_filename = _tmp261_;
							_tmp262_ = sub_filename;
							_tmp263_ = g_strdup_printf ("  (Could not download) %s", _tmp262_);
							_tmp264_ = _tmp263_;
							report_message (_tmp264_, TRUE, REPORT_VERBOSITY_DEFAULT);
							_g_free0 (_tmp264_);
							_error_ = TRUE;
							_g_free0 (sub_filename);
							_g_object_unref0 (it);
						} else {
							gboolean _tmp265_ = FALSE;
							gboolean _tmp266_ = FALSE;
							_tmp266_ = submarine_console_force;
							if (!_tmp266_) {
								GeeMultiMap* _tmp267_ = NULL;
								GeeSet* _tmp268_ = NULL;
								GeeSet* _tmp269_ = NULL;
								const gchar* _tmp270_ = NULL;
								gboolean _tmp271_ = FALSE;
								_tmp267_ = submarine_console_existing_subtitles;
								_tmp268_ = gee_multi_map_get_keys (_tmp267_);
								_tmp269_ = _tmp268_;
								_tmp270_ = filename;
								_tmp271_ = gee_collection_contains ((GeeCollection*) _tmp269_, _tmp270_);
								_tmp265_ = _tmp271_;
								_g_object_unref0 (_tmp269_);
							} else {
								_tmp265_ = FALSE;
							}
							if (_tmp265_) {
								GeeIterator* it = NULL;
								GeeMultiMap* _tmp272_ = NULL;
								const gchar* _tmp273_ = NULL;
								GeeCollection* _tmp274_ = NULL;
								GeeCollection* _tmp275_ = NULL;
								GeeIterator* _tmp276_ = NULL;
								GeeIterator* _tmp277_ = NULL;
								GeeIterator* _tmp278_ = NULL;
								gchar* sub_filename = NULL;
								GeeIterator* _tmp279_ = NULL;
								gpointer _tmp280_ = NULL;
								const gchar* _tmp281_ = NULL;
								gchar* _tmp282_ = NULL;
								gchar* _tmp283_ = NULL;
								_tmp272_ = submarine_console_existing_subtitles;
								_tmp273_ = filename;
								_tmp274_ = gee_multi_map_get (_tmp272_, _tmp273_);
								_tmp275_ = _tmp274_;
								_tmp276_ = gee_iterable_iterator ((GeeIterable*) _tmp275_);
								_tmp277_ = _tmp276_;
								_g_object_unref0 (_tmp275_);
								it = _tmp277_;
								_tmp278_ = it;
								gee_iterator_next (_tmp278_);
								_tmp279_ = it;
								_tmp280_ = gee_iterator_get (_tmp279_);
								sub_filename = (gchar*) _tmp280_;
								_tmp281_ = sub_filename;
								_tmp282_ = g_strdup_printf ("  (Already exists) %s", _tmp281_);
								_tmp283_ = _tmp282_;
								report_message (_tmp283_, TRUE, REPORT_VERBOSITY_DEFAULT);
								_g_free0 (_tmp283_);
								_g_free0 (sub_filename);
								_g_object_unref0 (it);
							} else {
								const gchar* _tmp284_ = NULL;
								gchar* _tmp285_ = NULL;
								gchar* _tmp286_ = NULL;
								_tmp284_ = filename;
								_tmp285_ = g_strdup_printf ("  (Not found) %s", _tmp284_);
								_tmp286_ = _tmp285_;
								report_message (_tmp286_, TRUE, REPORT_VERBOSITY_DEFAULT);
								_g_free0 (_tmp286_);
								_error_ = TRUE;
							}
						}
					}
				}
				_g_free0 (filename);
			}
			_g_object_unref0 (_filename_it);
		}
		_tmp287_ = _error_;
		if (_tmp287_) {
			NotifyNotification* _tmp288_ = NULL;
			_tmp288_ = faild;
			notify_notification_show (_tmp288_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (subtitles_saved_map);
				_g_object_unref0 (subtitles_save_map);
				_g_object_unref0 (subtitles_downloaded);
				_g_object_unref0 (subtitles_download_map);
				_g_object_unref0 (subtitles_found_map);
				_g_object_unref0 (search_filenames);
				_g_object_unref0 (connected_servers);
				_g_object_unref0 (faild);
				_g_object_unref0 (fails);
				_g_object_unref0 (success);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0;
			}
			result = (gint) SUBMARINE_CONSOLE_EXIT_VALUE_PROGRAM_ERROR;
			_g_object_unref0 (subtitles_saved_map);
			_g_object_unref0 (subtitles_save_map);
			_g_object_unref0 (subtitles_downloaded);
			_g_object_unref0 (subtitles_download_map);
			_g_object_unref0 (subtitles_found_map);
			_g_object_unref0 (search_filenames);
			_g_object_unref0 (connected_servers);
			_g_object_unref0 (faild);
			_g_object_unref0 (fails);
			_g_object_unref0 (success);
			return result;
		}
		_g_object_unref0 (subtitles_saved_map);
		_g_object_unref0 (subtitles_save_map);
		_g_object_unref0 (subtitles_downloaded);
		_g_object_unref0 (subtitles_download_map);
		_g_object_unref0 (subtitles_found_map);
		_g_object_unref0 (search_filenames);
	} else {
		NotifyNotification* _tmp289_ = NULL;
		_tmp289_ = fails;
		notify_notification_show (_tmp289_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (connected_servers);
			_g_object_unref0 (faild);
			_g_object_unref0 (fails);
			_g_object_unref0 (success);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
		report_message ("Summary:", TRUE, REPORT_VERBOSITY_DEFAULT);
		report_message ("  Could not connect to any Server!", TRUE, REPORT_VERBOSITY_DEFAULT);
		result = (gint) SUBMARINE_CONSOLE_EXIT_VALUE_PROGRAM_ERROR;
		_g_object_unref0 (connected_servers);
		_g_object_unref0 (faild);
		_g_object_unref0 (fails);
		_g_object_unref0 (success);
		return result;
	}
	result = (gint) SUBMARINE_CONSOLE_EXIT_VALUE_OK;
	_g_object_unref0 (connected_servers);
	_g_object_unref0 (faild);
	_g_object_unref0 (fails);
	_g_object_unref0 (success);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return submarine_console_main (argv, argc);
}


SubmarineConsole* submarine_console_construct (GType object_type) {
	SubmarineConsole * self = NULL;
	self = (SubmarineConsole*) g_object_new (object_type, NULL);
	return self;
}


SubmarineConsole* submarine_console_new (void) {
	return submarine_console_construct (TYPE_SUBMARINE_CONSOLE);
}


static void submarine_console_class_init (SubmarineConsoleClass * klass) {
	submarine_console_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = submarine_console_finalize;
}


static void submarine_console_instance_init (SubmarineConsole * self) {
}


static void submarine_console_finalize (GObject* obj) {
	SubmarineConsole * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SUBMARINE_CONSOLE, SubmarineConsole);
	G_OBJECT_CLASS (submarine_console_parent_class)->finalize (obj);
}


GType submarine_console_get_type (void) {
	static volatile gsize submarine_console_type_id__volatile = 0;
	if (g_once_init_enter (&submarine_console_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SubmarineConsoleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) submarine_console_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SubmarineConsole), 0, (GInstanceInitFunc) submarine_console_instance_init, NULL };
		GType submarine_console_type_id;
		submarine_console_type_id = g_type_register_static (G_TYPE_OBJECT, "SubmarineConsole", &g_define_type_info, 0);
		g_once_init_leave (&submarine_console_type_id__volatile, submarine_console_type_id);
	}
	return submarine_console_type_id__volatile;
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



